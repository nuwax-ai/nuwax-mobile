<template>
	<view class="agent-detail-container">
		<!-- 导航栏 -->
		<custom-nav-bar :title="agentName" show-back :icon="agentInfo?.icon">
			<template v-slot:right>
				<view class="right-buttons">
					<uni-icons class="iconfont icon-More" size="50rpx" @tap="handleMorePopup"></uni-icons>
					<uni-icons class="iconfont icon-message-add" size="50rpx" @tap="createNewConversation"></uni-icons>
				</view> 
			</template>
		</custom-nav-bar>
		<view class="chat-container">
			<!-- 聊天内容 -->
			<view class="scroll-view-box">
				<scroll-view 
					direction="vertical"
					class="msg-list" 
					:scroll-into-view="scrollIntoView"
					id="msg-list"
					:scroll-with-animation="scrollWithAnimation"
					@scroll="onScroll"
					@touchstart="scrollTouch = true"
					@touchend="scrollTouch = false"
				>
					<template v-for="item in msgItemsForRender" :key="item._id">
						<uni-ai-x-msg v-if="item.from_uid == 'uni-ai'" :msg="item" @longpress="onlongTapMsg(item)" @changeThinkContent="changeThinkContent" :id="'msg-item-' + item._id"></uni-ai-x-msg>
						<text v-else class="user-msg" @longpress="onlongTapMsg(item)">{{item.body}}</text>
					</template>
					<!-- 内容 -->
					<view class="content" v-if="msgItemsForRender?.length == 0">
						<!-- 头部区域 -->
						<view class="title-section">
							<text class="subtitle">{{agentInfo?.description}}</text>
						</view>
						<!-- 功能按钮区域 -->
						<button-wrapper :buttons="agentInfo?.openingGuidQuestions || []" @button-click="handleButtonClick" />
					</view>
					<!-- 最后一项，用于快速滚动到最底部 -->
					<view style="height: 35px;" id="last-msg"></view>
				</scroll-view>
				<!-- <add-chat-btn :style="{visibility: scrollInBottom && state != 'processing' ? 'visible' : 'hidden'}" class="add-chat-btn" /> -->
				<!-- 滚动到最底部 -->
				<view :style="{visibility: scrollInBottom || scrolling ? 'hidden' : 'visible'}" class="scroll-to-bottom" @click="scrollToLastMsg(true)">
					<uni-icons type="down" size="20" color="#555"></uni-icons>
				</view>
			</view>
			<!-- 输入框 -->
			<chat-input-phone
				:manual-components="agentInfo?.manualComponents || []"
				@onSendMessage="handleSendMessage"
			/>
		</view>
		<more-popup ref="refMorePopup" :agent-info="agentInfo" @collect="handleCollect"/>
	</view>
</template>

<script setup lang="uts">
	import { apiPublishedAgentInfo,apiCollectAgent,apiUnCollectAgent } from '@/servers/agentDev'
	import type {
		AgentDetailDto,
		AgentBaseInfo,
	} from '@/types/interfaces/agent';
	import MorePopup from '@/pages/agent-detail/components/more-popup/more-popup.uvue'

	import { chatService } from '@/utils/chatService'
  import { markdownParser } from '@/utils/markdownParser'
  import { MarkdownConverter } from '@/utils/markdownConverter'
  // 导入SSE数据处理器
  import { createSSEProcessor, SSEChunk } from '@/utils/sseDataProcessor'
  // 导入Markdown解析器
  import ParseMarkdown from '@/uni_modules/uni-ai-x/sdk/parseMarkdown.uts'
  // 导入Markdown相关类型
  import { NodesToken as MarkdownToken } from '@/uni_modules/kux-marked'
  // 导入treeToList工具
  import treeToListSdk from '@/uni_modules/uni-ai-x/sdk/treeToList.uts'
  // 导入会话相关API和类型
  import { apiAgentConversationCreate } from '@/servers/conversation.uts'
  import { ConversationCreateParams } from '@/types/interfaces/conversationInfo.uts'
  import ChatInputPhone from '@/components/chat-input-phone/chat-input-phone.uvue'
  import { AgentManualComponentInfo, AgentSelectedComponentInfo } from '@/types/interfaces/agent.uts'
	import { BindConfigWithSub, UploadFileInfo } from '@/types/interfaces/common'
	import { MessageStatusEnum, ProcessingEnum } from '@/types/enums/common'
	import { OpenCloseEnum } from '@/types/enums/space'
	import { RequestResponse } from '@/types/interfaces/request'
	import { MessageModeEnum, ConversationEventTypeEnum, AssistantRoleEnum, MessageTypeEnum } from '@/types/enums/agent'
	import { ConversationInfo, MessageInfo, ConversationChatParams, ConversationChatSuggestParams, ConversationChatResponse, ProcessingInfo, MessageQuestionExtInfo, AttachmentFile } from '@/types/interfaces/conversationInfo'
	import { TempChatCompletionsParams } from '@/types/interfaces/tempChat'
	import { apiAgentConversationChatSuggest } from '@/servers/conversation'
	import { ACCESS_TOKEN } from '@/constants/home.constants'
	import { SUCCESS_CODE } from '@/constants/codes.constants'
	import { v4 as uuidv4 } from 'uuid'
	import { MarkdownElement } from '@/types/interfaces/chat'
	import { apiAgentConversation } from '@/servers/conversation.uts'

	// 会话id
	const conversationId = ref<number | null>(null)
	// 智能体id
	const agentId = ref<number | null>(null)
	// 智能体名称
	const agentName = ref<string>('')
	// 智能体信息
	const agentInfo = ref<AgentDetailDto | null>(null)
	// 更多弹窗
	const refMorePopup = ref<any>(null)

	// 替换原有的msgList为msgItemsForRender，用于uni-ai-x渲染
	const msgItemsForRender = ref<MsgItem[]>([])

	// 使用uni-ai-x的ParseMarkdown类进行解析
	let parseMarkdownInstance: ParseMarkdown | null = null

	const keyboardHeight = ref<number>(0)
	const scrollIntoView = ref<string>('')
	const scrollInBottom = ref<boolean>(true)
	const scrollWithAnimation = ref<boolean>(false)
	const scrollTouch = ref<boolean>(false)
	const scrolling = ref<boolean>(false)
	let autoToLastMsg = false
	let scrollingT = 0
	let mouseScroll = false
	let needSetLockAutoToLastMsg = true

	// 会话信息
	const conversationInfo = ref<ConversationInfo | null>(null)
  // 会话消息ID
  const currentConversationRequestId = ref<string>('')
  // 是否用户问题建议
  const isSuggest = ref<boolean>(false)
  // 会话信息
  const messageList = ref<MessageInfo[]>([])
  // 会话问题建议
  const chatSuggestList = ref<string[]>([])
  // 会话请求ID
  const requestId = ref<string>('')
  // 会话消息ID
  const messageIdRef = ref<string>('')
  // 是否需要更新主题
  const needUpdateTopicRef = ref<boolean>(true)
  // 是否正在加载会话
  const isLoadingConversation = ref<boolean>(false)
  // 会话是否正在进行中（有消息正在处理）
  const isConversationActive = ref<boolean>(false)
  // 是否显示点击下滚按钮
  // const showScrollBtn = ref<boolean>(false)
  // 可手动选择的组件列表
  const manualComponents = ref<AgentManualComponentInfo[]>([])
  // 变量参数
  const variables = ref<BindConfigWithSub[]>([])
  // 用户填写的变量参数
  const userFillVariables = ref<{ [key: string]: string | number }>(null)
  // 必填变量参数name列表
  const requiredNameList = ref<string[]>([])
  // 处理中的消息列表
  const processingList = ref<ProcessingInfo[]>([])
  // SSE数据处理器
  let sseProcessor: any = null
	// 最后接收的SSE数据，用于调试
	const lastSSEData = ref<string>('')
  
  // 初始化ParseMarkdown实例
  const initParseMarkdown = () => {
    if (!parseMarkdownInstance) {
      parseMarkdownInstance = new ParseMarkdown((markdownTokenList: MarkdownToken[]) => {
        // 将MarkdownToken转换为markdownElItem
        const markdownElList = (markdownTokenList as any[]).map((token: any) => {
          return {
            uniqueId: token.uniqueId || `token_${Date.now()}_${Math.random()}`,
            type: token.type || 'text',
            datasList: treeToListSdk.markTreeToList(token)
          }
        });
        
        // 更新最新AI消息的markdownElList
        if (msgItemsForRender.value.length > 0) {
          const lastMsg = msgItemsForRender.value[msgItemsForRender.value.length - 1];
          if (lastMsg.from_uid === 'uni-ai') {
            lastMsg.markdownElList = markdownElList;
            // 强制触发响应式更新
            msgItemsForRender.value = [...msgItemsForRender.value];
          }
        }
      });
    }
  };

	onLoad(async (params) => {
		// 智能体id
		agentId.value = Number(params.id) || ''
		agentName.value = params.name || ''
		// 消息信息
		const messageInfo = params.messageInfo ? decodeURIComponent(params.messageInfo) : ''
		// 文件信息
		const files = params.files ? JSON.parse(decodeURIComponent(params.files)) : []

		initParseMarkdown()
    // 如果会话id存在，则初始化ParseMarkdown，查询历史会话信息
		if (params.conversationId) {
			const id = Number(params.conversationId)
			// 会话id
			conversationId.value = id
			// 查询历史会话信息
			const res = await apiAgentConversation(id)
			if(res.code === SUCCESS_CODE){
				handleQueryConversation(res)
			}
			// 查询智能体详情信息
			getPublishedAgentInfo()
		} else {
			// 查询智能体详情信息，并初始化会话id
			getPublishedAgentInfo(true, messageInfo, files)
		}
	})

	// 使用uni-ai-x解析器的函数
	const parseMarkdownToElList = (text: string, msgId: string): any[] => {
    if (!text || text.trim().length === 0) {
      return [];
    }
    
    // 确保ParseMarkdown实例已初始化
    if (!parseMarkdownInstance) {
      initParseMarkdown();
    }
    
    // 使用ParseMarkdown解析
    parseMarkdownInstance!.runTask(text);
    
    // 返回空数组，因为结果会通过回调异步更新
    return [];
  };

	// 创建新会话
	const createNewConversation= async () => {
		if(!agentId.value){
			uni.showToast({
				title: '智能体id不存在',
				icon: 'none',
				type: 'error'
			})
			return;
		}
		msgItemsForRender.value = [];
		// 创建会话
		const conversationParams: ConversationCreateParams = {
			agentId: agentId.value,
			devMode: true
		};
		
		const { code, data, message } = await apiAgentConversationCreate(conversationParams);
		
		if (code === SUCCESS_CODE && data && data.id) {
			conversationId.value = data.id;
		} else {
			uni.showToast({
				title: message,
				icon: 'none',
				type: 'error'
			})
		}
	}

	// 处理变量参数
	const handleVariables = (_variables: BindConfigWithSub[]) => {
    variables.value = _variables;
    // 必填参数name列表
    const _requiredNameList = _variables
      ?.filter(
        (item: BindConfigWithSub) => !item.systemVariable && item.require,
      )
      ?.map((item: BindConfigWithSub) => item.name);
    requiredNameList.value = _requiredNameList || [];
  };

	// 检查会话是否正在进行中（有消息正在处理）
	const checkConversationActive = (messages: MessageInfo[]) => {
    const hasActiveMessage =
      (messages?.length &&
        messages.some(
          (message) =>
            message.status === MessageStatusEnum.Loading ||
            message.status === MessageStatusEnum.Incomplete,
        )) ||
      false;
    isConversationActive.value = hasActiveMessage;
  };

  // 处理查询会话
  const handleQueryConversation = (result: RequestResponse<ConversationInfo>) => {
    isLoadingConversation.value = true;
    const { data } = result;
    conversationInfo.value = data as unknown as ConversationInfo;
    // 是否开启用户问题建议
    isSuggest.value = data?.agent?.openSuggest === OpenCloseEnum.Open;
    // 可手动选择的组件列表
    manualComponents.value = data?.agent?.manualComponents || [];
    // 变量参数
    const _variables = data?.agent?.variables || [];
    // 处理变量参数
    handleVariables(_variables);
    // 用户填写的变量参数
    userFillVariables.value = data?.variables as any;
    // 消息列表
    const _messageList = data?.messageList || [];
    const len = _messageList?.length || 0;
    if (len) {
      messageList.value = _messageList;
      // 检查会话状态
      checkConversationActive(_messageList);
      // 最后一条消息为"问答"时，获取问题建议
      const lastMessage = _messageList[len - 1];
      if (
        lastMessage.type === MessageModeEnum.QUESTION &&
        lastMessage.ext?.length
      ) {
        // 问题建议列表
        const suggestList = lastMessage.ext.map((item) => item.content) || [];
        chatSuggestList.value = suggestList;
      }
      // 如果消息列表大于1时，说明已开始会话，就不显示预置问题，反之显示
      else if (len === 1) {
        // 如果存在预置问题，显示预置问题
        chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
      }
    }
    // 不存在会话消息时，才显示开场白预置问题
    else {
      chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
    }

    // 使用 setTimeout 确保在 DOM 完全渲染后再滚动
    // setTimeout(() => {
    //   // 滚动到底部
    //   messageViewScrollToBottom();
    // }, 800);
  };

	const handleChatProcessingList = (_processingList: ProcessingInfo[]) => {
    //先清空
    // processingList.value = [];

    // 去重逻辑：保留一条，如果status状态不是 EXECUTING，如果成功或者失败都有就仅保留成功
    const processedMap = new Map<string, ProcessingInfo>();

    _processingList.forEach((item) => {
      const key = item.executeId || '';
      const existing = processedMap.get(key);

      if (!existing) {
        // 如果不存在，直接添加
        processedMap.set(key, item);
      } else {
        // 如果已存在，根据状态优先级决定保留哪一个
        // const shouldReplace = shouldReplaceProcessingItem(existing, item);
        // if (shouldReplace) {
        //   processedMap.set(key, item);
        // }
      }
    });

    const newProcessingList: ProcessingInfo[] = []
    processedMap.forEach((value) => {
      newProcessingList.push(value)
    })
    processingList.value = newProcessingList;
  };

  // 修改消息列表
  const handleChangeMessageList = async (
    res: ConversationChatResponse,
    // 自定义随机id
    currentMessageId: string,
  ) => {
    const { data, eventType } = res;
    currentConversationRequestId.value = res.requestId;
    if (!messageList.value?.length) {
      return [];
    }
    // timeoutRef.current = setTimeout(() => {
        // 深拷贝消息列表
        const list = [...messageList.value];
        const index = list.findIndex((item) => item.id === currentMessageId);
        // 数组splice方法的第二个参数表示删除的数量，这里我们只需要删除一个元素，所以设置为1， 如果为0，则表示不删除元素。
        let arraySpliceAction = 1;
        // 当前消息
        const currentMessage = list.find(
          (item) => item.id === currentMessageId,
        ) as MessageInfo;
        // 消息不存在时
        if (!currentMessage) {
          // if (timeoutRef.current) {
          //   clearTimeout(timeoutRef.current);
          //   timeoutRef.current = null;
          // }
          // return messageList.value;
        }

        let newMessage: MessageInfo | null = null;

        // 更新UI状态...
        if (eventType === ConversationEventTypeEnum.PROCESSING) {
          const processingResult = data.result || {};
          data.executeId = processingResult.executeId;
          newMessage = {
            ...currentMessage,
            // todo: 需要处理markdown
            // text: getCustomBlock(currentMessage.text || '', data),
            status: MessageStatusEnum.Loading,
            processingList: [
              ...(currentMessage?.processingList || []),
              data,
            ] as ProcessingInfo[],
          };

          handleChatProcessingList([
            ...(currentMessage?.processingList || []),
            { ...data },
          ] as ProcessingInfo[]);
        }
        // MESSAGE事件
        if (eventType === ConversationEventTypeEnum.MESSAGE) {
          const { text, type, ext, id, finished } = data;

          const markdownElements: MarkdownElement[] = markdownParser.parse(text);
          // const markdownElList: markdownElItem[] = markdownElements.map((item) => ({
          //   uniqueId: item.uniqueId,
          //   type: item.type,
          //   datasList: item.datasList,
          // }));
          // if (markdownElements?.[0]?.type !== 'text') {
          //   console.log('text666666', markdownElements?.[0]?.content, markdownElements?.[0]?.type);
          // }

          // 使用转换器将MarkdownElement转换为MarkdownToken[][]格式
          const datasList: MarkdownToken[][] = MarkdownConverter.convertToTokenArray(markdownElements)

          const markdownElList: markdownElItem[] = [{
            uniqueId: '1',
            type: 'text',
            datasList,
          }];
          // 思考think
          if (type === MessageModeEnum.THINK) {
            newMessage = {
              ...currentMessage,
              think: `${currentMessage.think}${text}`,
              status: MessageStatusEnum.Incomplete,
            };
          }
          // 问答
          else if (type === MessageModeEnum.QUESTION) {
            newMessage = {
              ...currentMessage,
              text: `${currentMessage.text}${text}`,
              markdownElList,
              // 如果finished为true，则状态为null，此时不会显示运行状态组件，否则为Incomplete
              status: finished ? null : MessageStatusEnum.Incomplete,
            };
            if (ext?.length) {
              // 问题建议
              chatSuggestList.value = (
                ext.map((extItem: MessageQuestionExtInfo) => extItem.content) ||
                  [] as string[]
              );
            }
          } else {
            // 工作流过程输出
            if (
              (!messageIdRef.value || messageIdRef.value !== id) &&
              finished
            ) {
              newMessage = {
                ...currentMessage,
                id,
                text: `${currentMessage.text}${text}`, // 这里需要添加 展示MCP 或者其他工具调用
                markdownElList,
                status: null, // 隐藏运行状态
              };
              // 插入新的消息
              arraySpliceAction = 0;
            } else {
              messageIdRef.value = id;
              newMessage = {
                ...currentMessage,
                text: `${currentMessage.text}${text}`,
                markdownElList,
                status: MessageStatusEnum.Incomplete,
              };
            }
          }
        }
        // FINAL_RESULT事件
        if (eventType === ConversationEventTypeEnum.FINAL_RESULT) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Complete,
            finalResult: data,
            requestId: res.requestId,
          };

          // 调试结果
          requestId.value = res.requestId;
        }
        // ERROR事件
        if (eventType === ConversationEventTypeEnum.ERROR) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Error,
          };
        }

        // 会话事件兼容处理，防止消息为空时，页面渲染报length错误
        if (newMessage) {
          list.splice(index, arraySpliceAction, newMessage as MessageInfo);
        }

        // 检查会话状态
        checkConversationActive(list);

        messageList.value = list;
    // }, 200);
  };

  // 会话处理
  const handleConversation = async (
    params: ConversationChatParams,
    currentMessageId: string,
    // 是否同步会话记录
    // isSync: boolean = true,
  ) => {
    try {
      // 初始化SSE处理器
      if (!sseProcessor) {
        sseProcessor = createSSEProcessor('chat-' + params.conversationId)
      }

      await chatService.sendMessage(
        params,
        // 处理流式数据
        (chunk: string) => {
          try {
            // 解析SSE数据
            const result = JSON.parse(chunk)
            
            // 更新最后接收的SSE数据用于调试
            lastSSEData.value = JSON.stringify(result, null, 2)
            
            // 使用SSE处理器处理数据
            if (sseProcessor && result.eventType === 'MESSAGE') {
              const updatedMessages = sseProcessor.processChunk(result)
              
              // 强制更新渲染列表
              msgItemsForRender.value = [...updatedMessages]
              
              // 滚动到底部
              scrollToLastMsg(false)
            }
            
            // Direct SSE processing logic added to handleConversation
            if (result.eventType === 'MESSAGE' && result.data) {
              const { id, text, finished } = result.data;
              const existingMsgIndex = msgItemsForRender.value.findIndex(msg =>
                msg._id === id && msg.from_uid === 'uni-ai'
              );
              if (existingMsgIndex !== -1) {
                const existingMsg = msgItemsForRender.value[existingMsgIndex];
                existingMsg.body += text || '';
                
                // 生成简单的markdownElList
                if (existingMsg.body && existingMsg.body.length > 0) {
                  existingMsg.markdownElList = parseMarkdownToElList(existingMsg.body, existingMsg._id);
                }
                
                if (finished) {
                  existingMsg.state = 3;
                }
                msgItemsForRender.value = [...msgItemsForRender.value]; // Force reactive update
              } else {
                const newMsg: MsgItem = {
                  _id: id,
                  from_uid: 'uni-ai',
                  body: text || '',
                  create_time: Date.now(),
                  state: finished ? 3 : 2,
                  chat_id: 'chat-' + params.conversationId,
                  markdownElList: text ? parseMarkdownToElList(text, id) : [],
                  rendered: false
                };
                msgItemsForRender.value.push(newMsg);
              }
              scrollToLastMsg(false);
            }
            
            // 同时保持原有的处理逻辑
            handleChangeMessageList(result, currentMessageId)
          } catch (error) {
            console.error('解析SSE数据失败:', error, '原始数据:', chunk)
          }
        },
        // 完成回调
        () => {
          // 是否开启问题建议,可用值:Open,Close
          if (isSuggest.value) {
            // runChatSuggest(params as ConversationChatSuggestParams);
            const data = apiAgentConversationChatSuggest(params as ConversationChatSuggestParams);
            // setChatSuggestList(data);
            chatSuggestList.value = data as unknown as string[];
            // handleScrollBottom();
          }
        },
        // 错误回调
        (error: any) => {
          // if (currentAIMessage.value) {
          //   chatService.setMessageError(currentAIMessage.value, error.message || '请求失败')
          // }
          // isLoading.value = false
          // currentAIMessage.value = null
          // console.error('Chat error:', error)
        }
      )
    } catch (error) {
      // isLoading.value = false
      console.error('Chat error:', error)
    }
  };

	// 清除副作用
	// const handleClearSideEffect = () => {
  //   chatSuggestList.value = [];
  // };

	// 发送消息
	const handleSendMessage = async (
    messageInfo: string,
    files: UploadFileInfo[] = [],
    infos: AgentSelectedComponentInfo[] = [],
    variableParams?: { [key: string]: string | number },
  ) => {
    // 清除副作用
    // handleClearSideEffect();
    // 附件文件
    const attachments: AttachmentFile[] =
      files?.map((file) => ({
        fileKey: file.key || '',
        fileUrl: file.url || '',
        fileName: file.name || '',
        mimeType: file.type || '',
      })) || [];
	  
	  let chatMessageId: string = '';
	  
	  // #ifdef MP-WEIXIN
	  chatMessageId = uni.getRandomValues({
	    length: 16,
	  }).then(res => res.randomValues.toString()) as string;
	  // #endif
	  
	  // #ifdef H5
	  chatMessageId = uuidv4() as string;
	  // #endif

    // 将文件和消息加入会话中
    const chatMessage = {
      role: AssistantRoleEnum.USER,
      type: MessageModeEnum.CHAT,
      text: messageInfo,
      time: new Date().toISOString(),
      attachments,
      id: chatMessageId,
      messageType: MessageTypeEnum.USER,
    };

		let currentMessageId: string = '';
			// #ifdef MP-WEIXIN
			currentMessageId = uni.getRandomValues({
				length: 16,
			}).then(res => res.randomValues.toString()) as string;
			// #endif

			// #ifdef H5
			currentMessageId = uuidv4() as string;
			// #endif
			
			// 当前助手信息
			const currentMessage = {
				role: AssistantRoleEnum.ASSISTANT,
				type: MessageModeEnum.CHAT,
				text: '',
				think: '',
				time: new Date().toISOString(),
				id: currentMessageId,
				messageType: MessageTypeEnum.ASSISTANT,
				status: MessageStatusEnum.Loading,
			} as MessageInfo;

			// 将Incomplete状态的消息改为Complete状态
			const completeMessageList =
				messageList.value?.map((item: MessageInfo) => {
					if (item.status === MessageStatusEnum.Incomplete) {
						item.status = MessageStatusEnum.Complete;
					}
					return item;
				}) || [];
			const newMessageList = [
				...completeMessageList,
				chatMessage,
				currentMessage,
			] as MessageInfo[];
			checkConversationActive(newMessageList);
			messageList.value = newMessageList;
    
			// 同时更新msgItemsForRender，添加用户消息
			// 创建用户消息的MsgItem
			const userMsgItem = {
				_id: chatMessageId,
				from_uid: 'user',
				body: messageInfo,
				create_time: Date.now(),
				state: 3, // 完成状态
				chat_id: 'chat-' + conversationId.value,
				markdownElList: parseMarkdownToElList(messageInfo, chatMessageId),
				rendered: false
			} as MsgItem;
			
			// 创建AI消息占位
			const aiMsgItem = {
				_id: currentMessageId,
				from_uid: 'uni-ai',
				body: '',
				create_time: Date.now(),
				state: 2, // 未完成状态
				chat_id: 'chat-' + conversationId.value,
				markdownElList: [],
				rendered: false
			} as MsgItem;
			
			// 添加到渲染列表
			msgItemsForRender.value.push(userMsgItem, aiMsgItem);
			
			// 滚动到底部
			scrollToLastMsg(false);
    
			// 缓存消息列表
			// messageListRef.current = newMessageList;

			// 允许滚动
			// allowAutoScrollRef.value = true;
			// 隐藏点击下滚按钮
			// showScrollBtn.value = false;
			// 滚动
			// handleScrollBottom();
			// 会话请求参数
			const params: ConversationChatParams = {
				conversationId: conversationId.value,
				variableParams,
				message: messageInfo,
				attachments,
				debug: false,
				selectedComponents: infos,
			};
			// 处理会话
			handleConversation(params, currentMessageId);
  };

	const state = computed<string>(() => {
		return uniAi.currentChat?.state ?? 'none'
	})

	const chatInputContent = ref<string>(uniAi.currentChat?.inputContent ?? '')
	
	watch(chatInputContent, (newValue: string) => {
		if (uniAi.currentChat != null) {
			uniAi.currentChat!.inputContent = newValue
		}
	})
	
	watch((): string | null => {
		return uniAi.currentChat?.inputContent ?? null
	}, (newValue: string | null) => {
		if (newValue != null) {
			chatInputContent.value = newValue
		}
	})
	
	const lastMsg = computed<MsgItem | null>(() => {
		return uniAi.lastAiMsg
	})
	
	const chatActiveId = computed<string>(() => {
		return uniAi.chat.activeId
	})
	
	const chatTitle = computed<string>(() => {
		const title = uniAi.currentChat?.title ?? ''
		if (title.length > 0) {
			return title.length > 10 ? title.slice(0, 10) + '...' : title
		}
		return '新对话'
	})
	function scrollToLastMsg(userClick: boolean){
		autoToLastMsg = true
		scrollIntoView.value = ""
		scrollWithAnimation.value = userClick
		nextTick(() => {
			scrollIntoView.value = "last-msg"
			scrollInBottom.value = true
		})
	}
	
	const setIsInScrollBottom = () => {
		nextTick(() => {
			const scrollList = uni.getElementById('msg-list')
			const diff: number = scrollList!.scrollHeight - scrollList!.scrollTop - scrollList!.offsetHeight
			scrollInBottom.value = diff < 30
			if (scrollTouch.value || mouseScroll) {
				autoToLastMsg = !(diff > 3)
			}
		})
	}
	
	watch(scrollInBottom, () => {
		uniAi.canRender = !scrollTouch.value && !scrolling.value
	}, { immediate: true })
	
	watch(scrolling, () => {
		uniAi.canRender = !scrollTouch.value && !scrolling.value
	}, { immediate: true })
	
	watch(chatActiveId, () => {
		scrollToLastMsg(false)
		nextTick(() => {
			if (lastMsg.value != null) lastMsg.value.rendered = true
		})
	}, { deep: true, immediate: true })
	
	const lockAutoToLastMsg = () => {
		if (!needSetLockAutoToLastMsg) return
		const lastMsgEl: UniElement | null = uni.getElementById('msg-item-' + lastMsg.value?._id)
		const scrollList: UniElement | null = uni.getElementById('msg-list')
		if (lastMsgEl == null || scrollList == null) return 
		// if (msgList.value.length < 3 || scrollList.offsetHeight < lastMsgEl.offsetHeight) {
		if (messageList.value.length < 3 || scrollList.offsetHeight < lastMsgEl.offsetHeight) {
			autoToLastMsg = false
			needSetLockAutoToLastMsg = false
		}
	}
	
	watch(lastMsg, async () => {
		setIsInScrollBottom()
		lockAutoToLastMsg()
		if (!scrollTouch.value && autoToLastMsg) {
			await nextTick()
			scrollToLastMsg(false)
		}
	}, { deep: true })

	const changeThinkContent = (hideThinkContent: boolean) => {
		setIsInScrollBottom()
	}
	
	// 长按消息
	const onlongTapMsg = (item: any) => {
		// 显示操作菜单
	}
		
	// 选择消息
	const onSelectMsg = (item: any) => {
		// 选择消息逻辑
	}
		
	// 修改消息
	const onEditMsg = (item: any) => {
		// 修改消息逻辑
	}
	
	const onKeyboardheightchange = (res: UniInputKeyboardHeightChangeEvent) => {
		keyboardHeight.value = res.detail.height
	}
	
	const onScroll = (e: UniScrollEvent) => {
		setIsInScrollBottom()
		scrolling.value = true
		if (scrollingT != 0) {
			clearTimeout(scrollingT)
		}
		scrollingT = setTimeout(() => {
			scrolling.value = false
		}, 500)
	}

	const onInputKeydown = (e: UniApp.KeyboardEvent) => {
		if (e.keyCode === 13) { // Enter键
			// 使用我们的备用消息发送机制
			if (chatInputContent.value.trim()) {
				if (conversationId.value) {
					fallbackMessageSend(chatInputContent.value);
					chatInputContent.value = '';
				} else {
					// 先创建会话，然后发送消息
					createConversationAndHandle().then(() => {
						if (conversationId.value) {
							fallbackMessageSend(chatInputContent.value);
							chatInputContent.value = '';
						}
					});
				}
			}
		}
	};

	// 处理更多弹窗
	const handleMorePopup = () => {
		// 确保组件已经挂载
		if (refMorePopup.value) {
			// 在微信小程序中，使用 nextTick 确保DOM更新完成
			nextTick(() => {
				refMorePopup.value?.open()
			})
		} else {
			console.warn('refMorePopup is null')
		}
	}

	/**
	 * 获取基本信息
	 * @param withConversationId 是否初始化会话id，默认false
	 * @param messageInfo 消息信息，默认''
	 * @param files 文件信息，默认[]
	 */
	const getPublishedAgentInfo = async (withConversationId: boolean = false, messageInfo: string = '', files: UploadFileInfo[] = []) => {
		const { code, data, message } = await apiPublishedAgentInfo(agentId.value, withConversationId)
		if (code === SUCCESS_CODE) {
			agentInfo.value = data
			if(withConversationId){
				conversationId.value = data.conversationId
				// 如果存在消息或文件，则发送消息
				if(messageInfo || files?.length > 0){
					// 初始化会话时，发送消息
					handleSendMessage(messageInfo, files)
				}
			}
		} else {
			uni.showToast({
				title: message,
				icon: 'none',
				type: 'error'
			})
		}
	}

	// 处理功能按钮点击
	const handleButtonClick = (buttonText : string) => {
		// 这里可以添加具体的功能逻辑
		uni.showToast({
			title: `点击了${buttonText}`,
			icon: 'none'
		})
	}
	// 收藏/取消收藏
	const handleCollect = async () => {
	if (!agentInfo.value) {
		return
	}
	if(agentInfo.value.collect){
		const { code, data } =  await apiUnCollectAgent(agentInfo.value.agentId)
		if (code === SUCCESS_CODE) {
			uni.showToast({
				title: '已取消收藏',
				icon: 'success',
				duration: 2000
			})
			agentInfo.value.collect = false
		}
	}else{
		const { code, data } = await apiCollectAgent(agentInfo.value.agentId)
		if (code === SUCCESS_CODE) {
			uni.showToast({
				title: '已添加到收藏',
				icon: 'success',
				duration: 2000
			})
			agentInfo.value.collect = true
		}
	}
}
</script>

<style lang="scss" scoped>
	.agent-detail-container {
		height: 100%;
		display: flex;
		padding-top: env(safe-area-inset-top);

		.right-buttons{
			display: flex;
			flex-direction: row;
			.iconfont{
				margin: 0 15rpx;
			}
		}

		.content {
			flex: 1;
			padding: 32rpx;

			.title-section {
				margin-bottom: 40rpx;

				.subtitle {
					font-size: 32rpx;
					font-weight: 400;
					color: rgba(21, 23, 31, 1);
					line-height: 48rpx;
					overflow: hidden;
					text-overflow: ellipsis;
					display: -webkit-box;
					-webkit-line-clamp: 2;
					-webkit-box-orient: vertical;
				}
			}
		}

		.chat-container {
			flex: 1;

			.scroll-view-box {
				flex: 1;
				position: relative;
				.msg-list {
					flex: 1;
					.user-msg {
						font-size: 16px;
						margin-left: auto;
						margin-right: 10px;
						margin-bottom: 10px;
						max-width: 600rpx;
						padding: 12px;
						border-radius: 15px 15px 0 15px;
						background-color: #eff6ff;
						/* #ifdef WEB */
						// 可以滑选 用于复制
						cursor: text;
						user-select: text;
						white-space: pre-wrap;
						word-break: break-all;
						/* #endif */;
					}
				}
				.add-chat-btn {
					position: absolute;
					bottom: 5px;
					left: 50%;
					transform: translateX(-50%);
				}
				.scroll-to-bottom {
					position: absolute;
					bottom: 10px;
					right: 10px;
					width: 35px;
					height: 35px;
					justify-content: center;
					align-items: center;
					background-color: #FFF;
					border-radius: 50px;
					padding: 5px;
					box-shadow: 0 0 10px 0 rgba(0,0,0,0.3);
					// #ifdef APP-HARMONY
					border: 1px solid #efefef;
					// #endif
					z-index: 10;
				}
			}
		}
	}
</style>