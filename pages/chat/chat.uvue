<template>
	<view>
		<image class="logo" src="/static/logo.png"></image>
    <view class="message-list">
      <view class="message-item" v-for="item in messageList" :key="item.id">
        <view class="message-item-content">
          <text class="message-item-text">{{ item.text }}</text>
        </view>
      </view>
    </view>
	</view>
</template>

<script setup lang="uts">
  import { AgentManualComponentInfo, AgentSelectedComponentInfo } from '@/types/interfaces/agent'
  import { BindConfigWithSub, UploadFileInfo } from '@/types/interfaces/common'
  import { MessageStatusEnum, ProcessingEnum } from '@/types/enums/common'
  import { OpenCloseEnum } from '@/types/enums/space'
  import { RequestResponse } from '@/types/interfaces/request'
  import { MessageModeEnum, ConversationEventTypeEnum, AssistantRoleEnum, MessageTypeEnum } from '@/types/enums/agent'
  import { ConversationInfo, MessageInfo, ConversationChatParams, ConversationChatSuggestParams, ConversationChatResponse, ProcessingInfo, MessageQuestionExtInfo, AttachmentFile } from '@/types/interfaces/conversationInfo'
  import { TempChatCompletionsParams } from '@/types/interfaces/tempChat'
  import { apiAgentConversationChatSuggest, apiAgentConversationCreate } from '@/servers/conversation'
  import { ACCESS_TOKEN } from '@/constants/home.constants'
   import { SUCCESS_CODE } from '@/constants/codes.constants'
   // #ifdef MP-WEIXIN || H5
   import { weappEventSource } from '@/servers/useRequest'
   // #endif
   import { CONVERSATION_CONNECTION_URL } from '@/constants/common.constants'
   // #ifdef H5
   import { createSSEConnection } from '@/servers/useRequest'
   import { EventSourceMessage } from '@microsoft/fetch-event-source'
   import { v4 as uuidv4 } from 'uuid'
   // #endif

    // 会话信息
	const conversationInfo = ref<ConversationInfo | null>(null)
      // 会话消息ID
    const currentConversationRequestId = ref<string>('')
        // 是否用户问题建议
    const isSuggest = ref<boolean>(false)
        // 会话信息
    const messageList = ref<MessageInfo[]>([])
    // 会话问题建议
    const chatSuggestList = ref<string[]>([])
    // 会话请求ID
    const requestId = ref<string>('')
    // 会话消息ID
    const messageIdRef = ref<string>('')
    // 是否需要更新主题
    const needUpdateTopicRef = ref<boolean>(true)
    // 是否正在加载会话
    const isLoadingConversation = ref<boolean>(false)
    // 会话是否正在进行中（有消息正在处理）
    const isConversationActive = ref<boolean>(false)
    // 添加一个 ref 来控制是否允许自动滚动
    const allowAutoScrollRef = ref<boolean>(true)
    // 是否显示点击下滚按钮
    const showScrollBtn = ref<boolean>(false)
    // 可手动选择的组件列表
    const manualComponents = ref<AgentManualComponentInfo[]>([])
    // 变量参数
    const variables = ref<BindConfigWithSub[]>([])
    // 用户填写的变量参数
    const userFillVariables = ref<{ [key: string]: string | number }>(null)
    // 必填变量参数name列表
    const requiredNameList = ref<string[]>([])
    // 滚动定时器
    const scrollTimeoutRef = ref<number | null>(null);
    const abortConnectionRef = ref<any>(null);
    // 处理中的消息列表
    const processingList = ref<ProcessingInfo[]>([])

  // 滚动到底部
  const messageViewScrollToBottom = () => {
    // 滚动到底部
    // messageViewRef.current?.scrollTo({
    //   top: messageViewRef.current?.scrollHeight,
    //   behavior: 'smooth',
    // });
  };

    // 修改 handleScrollBottom 函数，添加自动滚动控制
    const handleScrollBottom = () => {
    if (allowAutoScrollRef.value) {
      scrollTimeoutRef.value = setTimeout(() => {
        // 滚动到底部
        messageViewScrollToBottom();
      }, 400);
    }
  };

  // 处理变量参数
  const handleVariables = (_variables: BindConfigWithSub[]) => {
    variables.value = _variables;
    // 必填参数name列表
    const _requiredNameList = _variables
      ?.filter(
        (item: BindConfigWithSub) => !item.systemVariable && item.require,
      )
      ?.map((item: BindConfigWithSub) => item.name);
    requiredNameList.value = _requiredNameList || [];
  };

  // 检查会话是否正在进行中（有消息正在处理）
  const checkConversationActive = (messages: MessageInfo[]) => {
    const hasActiveMessage =
      (messages?.length &&
        messages.some(
          (message) =>
            message.status === MessageStatusEnum.Loading ||
            message.status === MessageStatusEnum.Incomplete,
        )) ||
      false;
    isConversationActive.value = hasActiveMessage;
  };

  // 处理查询会话
  const handleQueryConversation = (result: RequestResponse<ConversationInfo>) => {
    isLoadingConversation.value = true;
    const { data } = result;
    conversationInfo.value = data as unknown as ConversationInfo;
    // 是否开启用户问题建议
    isSuggest.value = data?.agent?.openSuggest === OpenCloseEnum.Open;
    // 可手动选择的组件列表
    manualComponents.value = data?.agent?.manualComponents || [];
    // 变量参数
    const _variables = data?.agent?.variables || [];
    // 处理变量参数
    handleVariables(_variables);
    // 用户填写的变量参数
    userFillVariables.value = data?.variables as any;
    // 消息列表
    const _messageList = data?.messageList || [];
    const len = _messageList?.length || 0;
    if (len) {
      messageList.value = _messageList;
      // 检查会话状态
      checkConversationActive(_messageList);
      // 最后一条消息为"问答"时，获取问题建议
      const lastMessage = _messageList[len - 1];
      if (
        lastMessage.type === MessageModeEnum.QUESTION &&
        lastMessage.ext?.length
      ) {
        // 问题建议列表
        const suggestList = lastMessage.ext.map((item) => item.content) || [];
        chatSuggestList.value = suggestList;
      }
      // 如果消息列表大于1时，说明已开始会话，就不显示预置问题，反之显示
      else if (len === 1) {
        // 如果存在预置问题，显示预置问题
        chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
      }
    }
    // 不存在会话消息时，才显示开场白预置问题
    else {
      chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
    }

    // 使用 setTimeout 确保在 DOM 完全渲染后再滚动
    setTimeout(() => {
      // 滚动到底部
      messageViewScrollToBottom();
    }, 800);
  };

  const handleChatProcessingList = (_processingList: ProcessingInfo[]) => {
    //先清空
    // processingList.value = [];

    // 去重逻辑：保留一条，如果status状态不是 EXECUTING，如果成功或者失败都有就仅保留成功
    const processedMap = new Map<string, ProcessingInfo>();

    _processingList.forEach((item) => {
      const key = item.executeId || '';
      const existing = processedMap.get(key);

      if (!existing) {
        // 如果不存在，直接添加
        processedMap.set(key, item);
      } else {
        // 如果已存在，根据状态优先级决定保留哪一个
        // const shouldReplace = shouldReplaceProcessingItem(existing, item);
        // if (shouldReplace) {
        //   processedMap.set(key, item);
        // }
      }
    });

    const newProcessingList = Array.from(processedMap.values()) as ProcessingInfo[];
    processingList.value = newProcessingList;
  };

  // 修改消息列表
  const handleChangeMessageList = async (
    params: ConversationChatParams,
    res: ConversationChatResponse,
    // 自定义随机id
    currentMessageId: string,
  ) => {
    const { data, eventType } = res;
    currentConversationRequestId.value = res.requestId;
    if (!messageList.value?.length) {
      return [];
    }
    // timeoutRef.current = setTimeout(() => {
        // 深拷贝消息列表
        const list = [...messageList.value];
        const index = list.findIndex((item) => item.id === currentMessageId);
        // 数组splice方法的第二个参数表示删除的数量，这里我们只需要删除一个元素，所以设置为1， 如果为0，则表示不删除元素。
        let arraySpliceAction = 1;
        // 当前消息
        const currentMessage = list.find(
          (item) => item.id === currentMessageId,
        ) as MessageInfo;
        // 消息不存在时
        if (!currentMessage) {
          // if (timeoutRef.current) {
          //   clearTimeout(timeoutRef.current);
          //   timeoutRef.current = null;
          // }
          // return messageList.value;
        }

        let newMessage: MessageInfo | null = null;

        // 更新UI状态...
        if (eventType === ConversationEventTypeEnum.PROCESSING) {
          const processingResult = data.result || {};
          data.executeId = processingResult.executeId;
          newMessage = {
            ...currentMessage,
            // todo: 需要处理markdown
            // text: getCustomBlock(currentMessage.text || '', data),
            status: MessageStatusEnum.Loading,
            processingList: [
              ...(currentMessage?.processingList || []),
              data,
            ] as ProcessingInfo[],
          };

          handleChatProcessingList([
            ...(currentMessage?.processingList || []),
            { ...data },
          ] as ProcessingInfo[]);
        }
        // MESSAGE事件
        if (eventType === ConversationEventTypeEnum.MESSAGE) {
          const { text, type, ext, id, finished } = data;
          // 思考think
          if (type === MessageModeEnum.THINK) {
            newMessage = {
              ...currentMessage,
              think: `${currentMessage.think}${text}`,
              status: MessageStatusEnum.Incomplete,
            };
          }
          // 问答
          else if (type === MessageModeEnum.QUESTION) {
            newMessage = {
              ...currentMessage,
              text: `${currentMessage.text}${text}`,
              // 如果finished为true，则状态为null，此时不会显示运行状态组件，否则为Incomplete
              status: finished ? null : MessageStatusEnum.Incomplete,
            };
            if (ext?.length) {
              // 问题建议
              chatSuggestList.value = (
                ext.map((extItem: MessageQuestionExtInfo) => extItem.content) ||
                  [] as string[]
              );
            }
          } else {
            // 工作流过程输出
            if (
              (!messageIdRef.value || messageIdRef.value !== id) &&
              finished
            ) {
              newMessage = {
                ...currentMessage,
                id,
                text: `${currentMessage.text}${text}`, // 这里需要添加 展示MCP 或者其他工具调用
                status: null, // 隐藏运行状态
              };
              // 插入新的消息
              arraySpliceAction = 0;
            } else {
              messageIdRef.value = id;
              newMessage = {
                ...currentMessage,
                text: `${currentMessage.text}${text}`,
                status: MessageStatusEnum.Incomplete,
              };
            }
          }
        }
        // FINAL_RESULT事件
        if (eventType === ConversationEventTypeEnum.FINAL_RESULT) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Complete,
            finalResult: data,
            requestId: res.requestId,
          };

          // 调试结果
          requestId.value = res.requestId;
          // setFinalResult(data as ConversationFinalResult);
          // if (timeoutRef.current) {
          //   clearTimeout(timeoutRef.current);
          //   timeoutRef.current = null;
          // }
          // 是否开启问题建议,可用值:Open,Close
          if (isSuggest) {
            // runChatSuggest(params as ConversationChatSuggestParams);
            const data = apiAgentConversationChatSuggest(params as ConversationChatSuggestParams);
            // setChatSuggestList(data);
            handleScrollBottom();
          }
        }
        // ERROR事件
        if (eventType === ConversationEventTypeEnum.ERROR) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Error,
          };
        }

        // 会话事件兼容处理，防止消息为空时，页面渲染报length错误
        if (newMessage) {
          list.splice(index, arraySpliceAction, newMessage as MessageInfo);
        }

        // 检查会话状态
        checkConversationActive(list);

        messageList.value = list;
    // }, 200);
  };

  // 会话处理
  const handleConversation = async (
    params: ConversationChatParams,
    currentMessageId: string,
    // 是否同步会话记录
    // isSync: boolean = true,
  ) => {
    const token = uni.getStorageSync(ACCESS_TOKEN) ?? '';
    // #ifdef MP-WEIXIN || H5
    weappEventSource({
        url: CONVERSATION_CONNECTION_URL,
        data: params,
        onmessage: (res: string) => {
					console.log(res, 888)
          // try {
          //   const result = JSON.parse(res);
          //   handleChangeMessageList(params, result, currentMessageId);
          // } catch (error) {
          //   console.log('error ========= 333333', res);
          // }
        },
        onerror: () => {
        },
      })
    // #endif

    console.log('params1111', 111);
    return;

    console.log('params2222', params);

    // #ifdef H5
	// 启动连接
	abortConnectionRef.current = await createSSEConnection({
      url: CONVERSATION_CONNECTION_URL,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
        Accept: 'application/json, text/plain, */* ',
      },
      body: JSON.stringify(params),
      // signal: controller.signal,
      // openWhenHidden: true, // 页面不可见时保持连接
      onMessage: (res: ConversationChatResponse) => {
        handleChangeMessageList(params, res, currentMessageId);
        // 滚动到底部
        handleScrollBottom();
      },
      onClose: async () => {
        // 第一次发送消息后更新主题
        if (needUpdateTopicRef.current) {
          const { data: result } = await apiAgentConversationUpdate({
            id: params.conversationId,
            firstMessage: params.message,
          })
          console.log('result - 第一次发送消息后更新主题', result);
          needUpdateTopicRef.current = false;
          setConversationInfo(
            (info) =>
              ({
                ...info,
                topic: result?.data?.topic,
              } as ConversationInfo),
          );
        }
      },
      onError: () => {
        // message.error('网络超时或服务不可用，请稍后再试');
        // 将当前会话的loading状态的消息改为Error状态
        const list =
          messageListRef.current?.map((info: MessageInfo) => {
            if (info?.id === currentMessageId) {
              return { ...info, status: MessageStatusEnum.Error };
            }
            return info;
          }) || [];
        setMessageList(list);
      },
    });
    // 主动关闭连接
    // 确保 abortConnectionRef.current 是一个可调用的函数
    if (typeof abortConnectionRef.current === 'function') {
      abortConnectionRef.current();
    }
    // #endif
  };

  // 清除副作用
  const handleClearSideEffect = () => {
    chatSuggestList.value = [];
    // if (timeoutRef.value) {
    //   clearTimeout(timeoutRef.value);
    //   timeoutRef.value = null;
    // }
    // 清除滚动
    if (scrollTimeoutRef.value) {
      clearTimeout(scrollTimeoutRef.value);
      scrollTimeoutRef.value = null;
    }
    // #ifdef H5
    // 主动关闭连接
    if (abortConnectionRef.value) {
      // 确保 abortConnectionRef.current 是一个可调用的函数
      if (typeof abortConnectionRef.value === 'function') {
        abortConnectionRef.value();
      }
      abortConnectionRef.value = null;
    }
    // #endif
  };

  // 发送消息
  const onMessageSend = async (
    id: number,
    messageInfo: string,
    files: UploadFileInfo[] = [],
    infos: AgentSelectedComponentInfo[] = [],
    variableParams?: { [key: string]: string | number },
    // debug: boolean = false,
    // // 是否同步会话记录
    // isSync: boolean = true,
  ) => {
    // 清除副作用
    handleClearSideEffect();

    // 附件文件
    const attachments: AttachmentFile[] =
      files?.map((file) => ({
        fileKey: file.key || '',
        fileUrl: file.url || '',
        fileName: file.name || '',
        mimeType: file.type || '',
      })) || [];
	  
	  let chatMessageId: string = '';
	  
	  // #ifdef MP-WEIXIN
	  chatMessageId = uni.getRandomValues({
	    length: 16,
	  }).then(res => res.randomValues.toString()) as string;
	  // #endif
	  
	  // #ifdef H5
	  chatMessageId = uuidv4() as string;
	  // #endif

    // 将文件和消息加入会话中
    const chatMessage = {
      role: AssistantRoleEnum.USER,
      type: MessageModeEnum.CHAT,
      text: messageInfo,
      time: new Date().toISOString(),
      attachments,
      id: chatMessageId,
      messageType: MessageTypeEnum.USER,
    };

    // const currentMessageId = process.env.TARO_ENV === 'weapp' ? await Taro.getRandomValues({
    //   length: 16,
    // }).then(res => res.randomValues.toString()) : uuidv4();

	let currentMessageId: string = '';
    // #ifdef MP-WEIXIN
    currentMessageId = uni.getRandomValues({
      length: 16,
    }).then(res => res.randomValues.toString()) as string;
    // #endif

    // #ifdef H5
    currentMessageId = uuidv4() as string;
    // #endif
    
    // 当前助手信息
    const currentMessage = {
      role: AssistantRoleEnum.ASSISTANT,
      type: MessageModeEnum.CHAT,
      text: '',
      think: '',
      time: new Date().toISOString(),
      id: currentMessageId,
      messageType: MessageTypeEnum.ASSISTANT,
      status: MessageStatusEnum.Loading,
    } as MessageInfo;

    // 将Incomplete状态的消息改为Complete状态
    const completeMessageList =
      messageList.value?.map((item: MessageInfo) => {
        if (item.status === MessageStatusEnum.Incomplete) {
          item.status = MessageStatusEnum.Complete;
        }
        return item;
      }) || [];
    const newMessageList = [
      ...completeMessageList,
      chatMessage,
      currentMessage,
    ] as MessageInfo[];
    checkConversationActive(newMessageList);
    console.log('newMessageList', newMessageList);
    messageList.value = newMessageList;
    // 缓存消息列表
    // messageListRef.current = newMessageList;

    // 允许滚动
    allowAutoScrollRef.value = true;
    // 隐藏点击下滚按钮
    showScrollBtn.value = false;
    // 滚动
    handleScrollBottom();
    // 会话请求参数
    const params: ConversationChatParams = {
      conversationId: id,
      variableParams,
      message: messageInfo,
      attachments,
      debug: false,
      selectedComponents: infos,
    };
    // 处理会话
    handleConversation(params, currentMessageId);
  };

	onLoad(async () => {
    // 创建会话
    const { code, data } = await apiAgentConversationCreate({
      agentId: 547,
      devMode: true,
    })
    if (code === SUCCESS_CODE) {
      const id = data.id;
      // 发送消息
      onMessageSend(id, '测试发送消息');
    }
	})
</script>

<style lang="scss" scoped>
	.logo {
		height: 100px;
		width: 100px;
		margin: 100px auto 25px auto;
	}
</style>
