import { NodesToken as MarkdownToken } from '@/uni_modules/kux-marked'
import { MessageInfo, ProcessingInfo } from '@/types/interfaces/conversationInfo'
import { BindConfigWithSub } from '@/types/interfaces/common'
import { MessageStatusEnum } from '@/types/enums/common'
import AgentDetailData from '@/pages/agent-detail/layers/AgentDetailData.uts'

/**
 * 工具层：提供通用的工具函数
 */
export default class AgentDetailUtils {
	/**
	 * 根据datasList内容动态确定type类型
	 */
	static determineTypeFromData(dataList: MarkdownToken[][]): string {
		if (!dataList || dataList.length === 0) return 'text'
		
		const firstToken = dataList[0]?.[0]
		if (firstToken) {
			switch (firstToken.type) {
				case 'code': return 'code'
				case 'table': return 'table'
				case 'list': return 'list'
				case 'heading': return 'heading'
				case 'blockquote': return 'quote'
				case 'hr': return 'divider'
				case 'math': return 'math'
				case 'paragraph': return 'paragraph'
				default: return 'text'
			}
		}
		return 'text'
	}

	/**
	 * 生成唯一的uniqueId
	 */
	static generateUniqueId(): string {
		const timestamp = Date.now()
		const random = Math.random().toString(36).substring(2, 15)
		return `markdown_${timestamp}_${random}`
	}

	/**
	 * 检查会话是否正在进行中
	 */
	static checkConversationActive(messages: MessageInfo[], data: AgentDetailData): void {
		const hasActiveMessage = (messages?.length &&
			messages.some(
				(message) =>
					message.status === MessageStatusEnum.Loading ||
					message.status === MessageStatusEnum.Incomplete,
			)) || false
		data.isConversationActive.value = hasActiveMessage
	}

	/**
	 * 处理变量参数
	 */
	static handleVariables(_variables: BindConfigWithSub[], data: AgentDetailData): void {
		data.variables.value = _variables
		const _requiredNameList = _variables
			?.filter((item: BindConfigWithSub) => !item.systemVariable && item.require)
			?.map((item: BindConfigWithSub) => item.name)
		data.requiredNameList.value = _requiredNameList || []
	}

	/**
	 * 处理处理中的消息列表
	 */
	static handleChatProcessingList(_processingList: ProcessingInfo[], data: AgentDetailData): void {
		const processedMap = new Map<string, ProcessingInfo>()

		_processingList.forEach((item) => {
			const key = item.executeId || ''
			const existing = processedMap.get(key)

			if (!existing) {
				processedMap.set(key, item)
			}
		})

		const newProcessingList: ProcessingInfo[] = []
		processedMap.forEach((value) => {
			newProcessingList.push(value)
		})
		data.processingList.value = newProcessingList
	}
}



const defaultDelimiters = [
  { left: '\\[', right: '\\]', display: true },
  { left: '\\(', right: '\\)', display: false },
];
// 转义括号规则 - 通用数学公式解析器
function escapedBracketRule(delimiters: any) {
  return (text: string, startPos: number = 0) => {
    const max = text.length;
    const start = startPos;

    for (const { left, right, display } of delimiters) {
      // 检查是否以左标记开始
      if (!text.slice(start).startsWith(left)) continue;

      // 跳过左标记的长度
      let pos = start + left.length;

      // 寻找匹配的右标记
      while (pos < max) {
        if (text.slice(pos).startsWith(right)) {
          break;
        }
        pos++;
      }

      // 没找到匹配的右标记，跳过，进入下个匹配
      if (pos >= max) continue;

      // 提取数学公式内容
      const content = text.slice(start + left.length, pos);
      const endPos = pos + right.length;

      return {
        formula: content,
        display,
        start,
        end: endPos,
        left,
        right,
        success: true,
      };
    }

    return {
      formula: '',
      display: false,
      start: 0,
      end: 0,
      left: '',
      right: '',
      success: false,
    };
  };
}
// 新的数学公式替换函数 - 直接替换为 $$ 分隔符
export function replaceMathBracket(text: string): string {

  // 创建只包含非美元符号分隔符的选项
  const nonDollarDelimiters = defaultDelimiters.filter(
    (delimiter) =>
      !delimiter.left.includes('$') && !delimiter.right.includes('$'),
  );

  const rule = escapedBracketRule(nonDollarDelimiters);
  let result = '';
  let pos = 0;

  while (pos < text.length) {
    const match = rule(text, pos);
    if (match.success) {
      // 添加匹配前的文本
      result += text.slice(pos, match.start);
      // 替换为 $$ 分隔符
      const delimiter = match.display ? '$$' : '$';
      result += `${delimiter}${match.formula}${delimiter}`;
      pos = match.end;
    } else {
      // 没有匹配，添加当前字符
      result += text[pos];
      pos++;
    }
  }

  return result;
}