<template>
  <view class="voice-recorder-container">
    <!-- 录音按钮 -->
    <view 
      class="voice-button"
      :class="[
        `voice-button--${currentState}`,
        { 'voice-button--pressed': isPressing }
      ]"
      @touchstart="handleTouchStart"
      @touchend="handleTouchEnd"
      @touchcancel="handleTouchCancel"
      @longpress="handleLongPress"
    >
      <!-- 按钮图标 -->
      <view class="voice-icon">
        <uni-icons 
          v-if="currentState === 'default'"
          type="mic" 
          size="24" 
          color="#666"
        />
        <uni-icons 
          v-else-if="currentState === 'recording'"
          type="mic-filled" 
          size="24" 
          color="#fff"
        />
        <uni-icons 
          v-else-if="currentState === 'uploading'"
          type="reload" 
          size="24" 
          color="#fff"
        />
        <uni-icons 
          v-else-if="currentState === 'success'"
          type="checkmarkempty" 
          size="24" 
          color="#fff"
        />
        <uni-icons 
          v-else-if="currentState === 'error'"
          type="closeempty" 
          size="24" 
          color="#fff"
        />
      </view>
      
      <!-- 波形动画 -->
      <view v-if="showWaveform && currentState === 'recording'" class="waveform">
        <view 
          v-for="(bar, index) in waveformBars" 
          :key="index"
          class="waveform-bar"
          :style="{ height: `${bar.height}px`, animationDelay: `${bar.delay}ms` }"
        />
      </view>
    </view>
    
    <!-- 录音时长显示 -->
    <view v-if="currentState === 'recording'" class="recording-duration">
      {{ formatDuration(recordDuration) }}
    </view>
    
    <!-- 状态提示文字 -->
    <view class="voice-tips">
      <text v-if="currentState === 'default'">{{ buttonText }}</text>
      <text v-else-if="currentState === 'recording'">松开结束</text>
      <text v-else-if="currentState === 'uploading'">正在处理...</text>
      <text v-else-if="currentState === 'success'">转换成功</text>
      <text v-else-if="currentState === 'error'">{{ errorMessage }}</text>
    </view>
    
    <!-- 转换结果显示 -->
    <view v-if="transcriptResult && currentState === 'success'" class="transcript-result">
      <text>{{ transcriptResult }}</text>
    </view>
  </view>
</template>

<script lang="uts" setup>
import { 
  createVoiceRecorderManager, 
  type RecorderConfig,
  type AudioFile as ManagerAudioFile,
  type RecordingError,
  type WaveformBar,
  ErrorHandler
} from '@/utils/voiceRecorderManager'
import { 
  createAudioUploader, 
  type AudioFile as UploaderAudioFile,
  type TranscriptResult as UploaderTranscriptResult,
  type UploadProgress
} from '@/utils/audioUploader'

// 组件Props类型定义
interface VoiceRecorderProps {
  // 录音配置
  duration?: number        // 最大录音时长 (ms)
  format?: string         // 音频格式
  sampleRate?: number     // 采样率
  
  // UI配置
  buttonText?: string     // 按钮文字
  buttonSize?: string     // 按钮尺寸
  showWaveform?: boolean  // 显示波形动画
  
  // 音频上传配置
  useRealApi?: boolean    // 是否使用真实API接口
  apiUrl?: string         // 真实API接口地址
  language?: string       // 语音识别语言
  
  // 事件回调
  onRecordStart?: () => void
  onRecordStop?: (result: string) => void
  onError?: (error: any) => void
  onUploadProgress?: (progress: number) => void  // 上传进度回调
}

// 录音状态类型
type RecordState = 'default' | 'recording' | 'uploading' | 'success' | 'error'

// 转换结果接口
interface TranscriptResult {
  success: boolean
  text: string
  confidence: number
  duration: number
  error?: string
}

const props = withDefaults(defineProps<VoiceRecorderProps>(), {
  duration: 60000,
  format: 'mp3',
  sampleRate: 44100,
  buttonText: '长按录音',
  buttonSize: '80rpx',
  showWaveform: true,
  useRealApi: false,
  apiUrl: '',
  language: 'zh-CN'
})

// 响应式状态
const currentState = ref<RecordState>('default')
const isPressing = ref<boolean>(false)
const recordDuration = ref<number>(0)
const transcriptResult = ref<string>('')
const errorMessage = ref<string>('')
const waveformBars = ref<WaveformBar[]>([])

// 录音管理器
let voiceRecorderManager: any = null

// 音频上传服务
let audioUploadService: any = null

// 初始化录音管理器
onMounted(() => {
  initializeVoiceRecorderManager()
  initializeAudioUploadService()
})

// 初始化语音录音管理器
const initializeVoiceRecorderManager = () => {
  // 创建录音配置
  const recorderConfig: RecorderConfig = {
    duration: props.duration,
    sampleRate: props.sampleRate,
    numberOfChannels: 1,
    encodeBitRate: 192000,
    format: props.format
  }
  
  // 创建录音管理器实例
  voiceRecorderManager = createVoiceRecorderManager(recorderConfig)
  
  // 设置事件监听
  setupVoiceRecorderEvents()
  
  console.log('语音录音管理器初始化完成')
}

// 初始化音频上传服务
const initializeAudioUploadService = () => {
  if (props.useRealApi) {
    // 使用真实API
    if (props.apiUrl) {
      // 创建audioUploader实例，配置真实API
      audioUploadService = createAudioUploader({
        apiUrl: props.apiUrl,
        language: props.language,
        timeout: 30000
      })
      console.log('使用真实API服务:', props.apiUrl)
    } else {
      console.warn('启用了真实API但未配置API地址，将使用模拟服务')
      audioUploadService = createAudioUploader()
      console.log('使用模拟API服务')
    }
  } else {
    // 使用模拟服务
    audioUploadService = createAudioUploader()
    console.log('使用模拟API服务')
  }
}

// 设置语音录音管理器事件监听
const setupVoiceRecorderEvents = () => {
  if (!voiceRecorderManager) return
  
  // 录音开始事件
  voiceRecorderManager.onStart(() => {
    console.log('录音开始')
    currentState.value = 'recording'
    isPressing.value = true
    props.onRecordStart?.()
    
    // 触发震动反馈
    uni.vibrateShort()
  })
  
  // 录音停止事件
  voiceRecorderManager.onStop(async (audioFile: ManagerAudioFile) => {
    console.log('录音停止', audioFile)
    
    // 立即显示上传中状态，给用户明确反馈
    currentState.value = 'uploading'
    
    try {
      // 使用音频上传服务转换音频
      const result = await uploadAndConvertWithService(audioFile)
      if (result.success) {
        transcriptResult.value = result.text
        currentState.value = 'success'
        props.onRecordStop?.(result.text)
        
        // 2秒后重置状态
        setTimeout(() => {
          resetState()
        }, 2000)
      } else {
        throw new Error(result.error || '转换失败')
      }
    } catch (error: any) {
      console.error('语音转换失败:', error)
      errorMessage.value = error.message || '转换失败'
      currentState.value = 'error'
      props.onError?.(error)
      
      // 3秒后重置状态
      setTimeout(() => {
        resetState()
      }, 3000)
    }
  })
  
  // 录音错误事件
  voiceRecorderManager.onError((error: RecordingError) => {
    console.error('录音错误', error)
    errorMessage.value = error.message || '录音失败'
    currentState.value = 'error'
    isPressing.value = false
    props.onError?.(error)
    
    // 3秒后重置状态
    setTimeout(() => {
      resetState()
    }, 3000)
  })
  
  // 录音时长更新事件
  voiceRecorderManager.onDurationUpdate((duration: number) => {
    recordDuration.value = duration
  })
  
  // 波形更新事件
  voiceRecorderManager.onWaveformUpdate((bars: WaveformBar[]) => {
    waveformBars.value = bars
  })
  
  // 触摸开始事件
  voiceRecorderManager.onTouchStart(() => {
    console.log('触摸开始')
  })
  
  // 触摸结束事件
  voiceRecorderManager.onTouchEnd(() => {
    console.log('触摸结束')
    isPressing.value = false
  })
  
  // 长按事件
  voiceRecorderManager.onLongPress(() => {
    console.log('长按触发')
  })
}

// 触摸开始事件处理
const handleTouchStart = (e: any) => {
  if (voiceRecorderManager) {
    voiceRecorderManager.handleTouchStart(e)
  }
}

// 触摸结束事件处理
const handleTouchEnd = (e: any) => {
  if (voiceRecorderManager) {
    voiceRecorderManager.handleTouchEnd(e)
  }
}

// 触摸取消事件处理
const handleTouchCancel = (e: any) => {
  if (voiceRecorderManager) {
    voiceRecorderManager.handleTouchCancel(e)
  }
}

// 长按事件处理
const handleLongPress = (e: any) => {
  if (voiceRecorderManager) {
    voiceRecorderManager.handleLongPress(e)
  }
}

// 格式化录音时长
const formatDuration = (duration: number): string => {
  return voiceRecorderManager ? voiceRecorderManager.formatDuration(duration) : '0.0s'
}

// 使用audioUploader转换音频
const uploadAndConvertWithService = async (audioFile: ManagerAudioFile): Promise<TranscriptResult> => {
  if (!audioUploadService) {
    throw new Error('音频上传服务未初始化')
  }

  try {
    // 转换音频文件格式
    const uploaderAudioFile: UploaderAudioFile = {
      tempFilePath: audioFile.tempFilePath,
      duration: audioFile.duration,
      fileSize: audioFile.fileSize,
      format: audioFile.format
    }

    // 调用audioUploader的上传方法
    const result = await audioUploadService.uploadAudio(
      uploaderAudioFile,
      (progress: UploadProgress) => {
        // 上传进度回调
        console.log('上传进度:', progress.percent + '%')
        props.onUploadProgress?.(progress.percent)
      }
    )

    // 转换结果格式
    return {
      success: result.success,
      text: result.text,
      confidence: result.confidence,
      duration: result.duration,
      error: result.error
    }
  } catch (error: any) {
    console.error('音频转换服务调用失败:', error)
    throw error
  }
}

// 重置状态
const resetState = () => {
  currentState.value = 'default'
  isPressing.value = false
  recordDuration.value = 0
  transcriptResult.value = ''
  errorMessage.value = ''
  waveformBars.value = []
}

// 组件卸载时清理资源
onUnmounted(() => {
  if (voiceRecorderManager) {
    voiceRecorderManager.destroy()
  }
})
</script>

<style lang="scss" scoped>
.voice-recorder-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16rpx;
}

.voice-button {
  position: relative;
  width: 120rpx;
  height: 120rpx;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  user-select: none;
  
  // 默认状态
  &--default {
    background-color: #f5f5f5;
    border: 2rpx solid #ddd;
    
    &:active, &.voice-button--pressed {
      transform: scale(1.1);
      background-color: #ff4d4f;
      border-color: #ff4d4f;
      
      .voice-icon {
        color: #fff !important;
      }
    }
  }
  
  // 录音中状态
  &--recording {
    background-color: #ff4d4f;
    border-color: #ff4d4f;
    animation: recording-pulse 1s infinite;
  }
  
  // 上传中状态
  &--uploading {
    background-color: #1890ff;
    border-color: #1890ff;
    
    .voice-icon {
      animation: loading-spin 1s linear infinite;
    }
  }
  
  // 成功状态
  &--success {
    background-color: #52c41a;
    border-color: #52c41a;
  }
  
  // 错误状态
  &--error {
    background-color: #ff4d4f;
    border-color: #ff4d4f;
  }
}

.voice-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
}

.waveform {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4rpx;
  z-index: 1;
}

.waveform-bar {
  width: 6rpx;
  background-color: rgba(255, 255, 255, 0.8);
  border-radius: 3rpx;
  animation: waveform-bounce 0.6s ease-in-out infinite alternate;
}

.recording-duration {
  font-size: 28rpx;
  color: #ff4d4f;
  font-weight: 500;
}

.voice-tips {
  font-size: 24rpx;
  color: #666;
  text-align: center;
}

.transcript-result {
  max-width: 500rpx;
  padding: 16rpx;
  background-color: #f6ffed;
  border: 1rpx solid #b7eb8f;
  border-radius: 12rpx;
  
  text {
    font-size: 28rpx;
    color: #389e0d;
  }
}

// 动画定义
@keyframes recording-pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 77, 79, 0.7);
  }
  70% {
    box-shadow: 0 0 0 20rpx rgba(255, 77, 79, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(255, 77, 79, 0);
  }
}

@keyframes loading-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes waveform-bounce {
  from {
    transform: scaleY(0.5);
  }
  to {
    transform: scaleY(1.5);
  }
}
</style>