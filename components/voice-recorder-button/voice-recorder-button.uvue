<template>
  <view class="voice-recorder-container" :class="[{ 'full-recording': currentState === 'recording' }]">
    <!-- 录音按钮 -->
    <view 
      ref="buttonRef"
      class="voice-button"
      :class="[
        `voice-button--${currentState}`,
        { 'voice-button--pressed': isPressing },
        { 'voice-button--cancelled': isCancelled && currentState === 'recording' }
      ]"
      @touchstart.prevent="handleTouchStart"
      @touchmove.prevent="handleTouchMove"
      @touchend.prevent="handleTouchEnd"
      @touchcancel.prevent="handleTouchCancel"
    >
      <!-- 波形动画 -->
      <view v-if="showWaveform && currentState === 'recording'" class="waveform">
        <view 
          v-for="(bar, index) in waveformBars" 
          :key="index"
          class="waveform-bar"
          :style="{ height: `${bar.height}px`, animationDelay: `${bar.delay}ms` }"
        />
      </view>
      
      <!-- 状态提示文字 -->
      <view class="voice-tips">
        <text v-if="currentState === 'default'">{{ buttonText }}</text>
        <!-- <text v-else-if="currentState === 'recording'">
          {{ isCancelled ? '松手取消' : '松手发送，上移取消' }}
        </text>
        <text v-else-if="currentState === 'uploading'">正在处理...</text>
        <text v-else-if="currentState === 'success'">转换成功</text>
        <text v-else-if="currentState === 'error'">{{ errorMessage }}</text> -->
      </view>
    </view>
    
    <!-- 转换结果显示 -->
    <!-- <view v-if="transcriptResult && currentState === 'success'" class="transcript-result">
      <text>{{ transcriptResult }}</text>
    </view> -->
  </view>
</template>

<script lang="uts" setup>
import jzRecorder from '@/uni_modules/jz-h5-recorder-manager'
import { 
  createAudioUploader, 
  type AudioFile as UploaderAudioFile,
  type TranscriptResult as UploaderTranscriptResult,
  type UploadProgress
} from '@/servers/audioUploader'
import { MicrophonePermissionHelper, type PermissionState } from '@/utils/permissionHelper'

// 组件Props类型定义
interface VoiceRecorderProps {
  // 录音配置
  duration?: number        // 最大录音时长 (ms)
  format?: string         // 音频格式
  sampleRate?: number     // 采样率
  
  // UI配置
  buttonText?: string     // 按钮文字
  buttonSize?: string     // 按钮尺寸
  showWaveform?: boolean  // 显示波形动画
  
  // 音频上传配置
  useRealApi?: boolean    // 是否使用真实API接口
  apiUrl?: string         // 真实API接口地址
  language?: string       // 语音识别语言
}

// 录音状态类型
type RecordState = 'default' | 'recording' | 'uploading' | 'success' | 'error'

// 音频文件接口
interface AudioFile {
  tempFilePath: string
  duration: number
  fileSize: number
  format?: string
}

// 转换结果接口
interface TranscriptResult {
  success: boolean
  text: string
  confidence: number
  duration: number
  error?: string
}

const props = withDefaults(defineProps<VoiceRecorderProps>(), {
  duration: 60000,
  format: 'mp3',
  sampleRate: 44100,
  buttonText: '按住说话',
  buttonSize: '60rpx',
  showWaveform: true,
  useRealApi: false,
  apiUrl: '',
  language: 'zh-CN'
})

const emit = defineEmits<{
  // 事件回调
  onRecordStart?: () => void,
  onRecordStop?: (result: string) => void,
  onError?: (error: any) => void,
  onUploadProgress?: (progress: number) => void  // 上传进度回调
  onCancelChange?: (isCancelled: boolean) => void  // New emit for cancel state
  onRecordCancel?: () => void  // New emit for cancellation
  onRecordEnd?: () => void  // New emit for touch end
}>()

// 响应式状态
const currentState = ref<RecordState>('default')
const isPressing = ref<boolean>(false)
const recordDuration = ref<number>(0)
const transcriptResult = ref<string>('')
const errorMessage = ref<string>('')
const isCancelled = ref<boolean>(false)
const buttonRect = reactive({
  left: 0,
  top: 0,
  width: 0,
  height: 0,
  right: 0,
  bottom: 0
})

// 录音管理器
let recorderManager: any = null
let durationTimer: any = null

// 音频上传服务
let audioUploadService: any = null // 使用audioUploader

// 波形动画数据
const waveformBars = ref([])

// Add watch for isCancelled to emit changes
watch(isCancelled, (newVal) => {
  emit('onCancelChange', newVal)
})

watch(currentState.value, (newVal) => {
  console.log('currentState', newVal)
})

// 初始化波形动画数据
const initWaveform = () => {
  // Dynamically generate waveform bars based on 80% of width
  const targetWidth = 640 * 0.8 // rpx
  const barWidth = 6 // rpx
  const gap = 4 // rpx
  const numBars = Math.max(3, Math.floor((targetWidth + gap) / (barWidth + gap))) // At least 3 bars
  
  waveformBars.value = Array.from({ length: numBars }, (_, index) => ({
    height: Math.random() * 20 + 5, // Initial random height 5-25
    delay: index * 100
  }))
}

// 初始化录音管理器
onMounted(() => {
  recorderManager = jzRecorder.getRecorderManager()
  setupRecorderEvents()
  
  // 初始化音频上传服务
  initializeAudioUploadService()
  // 初始化波形动画数据
  initWaveform()

  nextTick(() => {
    const query = uni.createSelectorQuery().in(this as any)
    query.select('.voice-button').boundingClientRect((data: any) => {
      if (data) {
        buttonRect.left = data.left
        buttonRect.top = data.top
        buttonRect.width = data.width
        buttonRect.height = data.height
        buttonRect.right = data.right
        buttonRect.bottom = data.bottom
      }
    }).exec()
  })
})

// 初始化音频上传服务
const initializeAudioUploadService = () => {
  if (props.useRealApi) {
    // 使用真实API
    if (props.apiUrl) {
      // 创建audioUploader实例，配置真实API
      audioUploadService = createAudioUploader({
        apiUrl: props.apiUrl,
        language: props.language,
        timeout: 30000
      })
    } else {
      audioUploadService = createAudioUploader()
    }
  } else {
    // 使用模拟服务
    audioUploadService = createAudioUploader()
  }
}

// 重置状态
const resetState = () => {
  currentState.value = 'default'
  isPressing.value = false
  recordDuration.value = 0
  transcriptResult.value = ''
  errorMessage.value = ''
  isCancelled.value = false
}

const handleRecordStart = () => {
  currentState.value = 'recording'
  startDurationTimer()
  emit('onRecordStart')
}

const handleRecordError = (err: any) => {
  errorMessage.value = err.errMsg || '录音失败'
  currentState.value = 'error'
  stopDurationTimer()
  emit('onError', err)
  
  // 3秒后重置状态
  setTimeout(() => {
    resetState()
  }, 3000)
}

const handleRecordStop = async (res: AudioFile) => {
  stopDurationTimer()
  
  if (res.duration < 1000) {
    uni.showToast({
      title: '录音时间太短',
      icon: 'none',
      duration: 1500
    })
    resetState()
    emit('onRecordCancel')
    return
  }
  
  // 立即显示上传中状态，给用户明确反馈
  currentState.value = 'uploading'
  
  try {
    // 使用音频上传服务转换音频
    const result = await uploadAndConvertWithService(res)
    if (result.success) {
      transcriptResult.value = result.text
      currentState.value = 'success'
      emit('onRecordStop', result.text)
      
      // 2秒后重置状态
      setTimeout(() => {
        resetState()
      }, 2000)
    } else {
      throw new Error(result.error || '转换失败')
    }
  } catch (error: any) {
    handleRecordError(error)
  }
}

// 设置录音事件监听
const setupRecorderEvents = async() => {
  if (!recorderManager) return
  
  // 录音开始
  recorderManager.onStart(handleRecordStart)
  // 录音错误
  recorderManager.onError(handleRecordError)
  // 录音停止
  recorderManager.onStop(handleRecordStop)
}

// 开始录音时长计时
const startDurationTimer = () => {
  recordDuration.value = 0
  durationTimer = setInterval(() => {
    recordDuration.value += 100
    updateWaveform()
  }, 100)
}

// 停止录音时长计时
const stopDurationTimer = () => {
  if (durationTimer) {
    clearInterval(durationTimer)
    durationTimer = null
  }
}

// 更新波形动画
const updateWaveform = () => {
  waveformBars.value = waveformBars.value.map(bar => ({
    ...bar,
    height: Math.random() * 20 + 5
  }))
}

// 格式化录音时长
const formatDuration = (duration: number): string => {
  const seconds = Math.floor(duration / 1000)
  const milliseconds = Math.floor((duration % 1000) / 100)
  return `${seconds}.${milliseconds}s`
}

const CANCEL_THRESHOLD = 100 // px

const handleTouchStart = () => {
  isPressing.value = true
  isCancelled.value = false
  startRecording()
}

const handleTouchMove = () => {
  if (currentState.value !== 'recording' || !e.touches || e.touches.length === 0) return
  
  const touch = e.touches[0]
  const deltaY = buttonRect.top - touch.pageY
  isCancelled.value = deltaY > CANCEL_THRESHOLD
}

const handleTouchEnd = () => {
  isPressing.value = false
  if (currentState.value !== 'recording') return
  
  if (isCancelled.value) {
    cancelRecording()
  } else {
    stopRecording()
  }
  emit('onRecordEnd')
}

const handleTouchCancel = () => {
  isPressing.value = false
  if (currentState.value !== 'recording') return
  cancelRecording()
  emit('onRecordEnd')
}

const cancelRecording = () => {
  if (recorderManager) {
    recorderManager.stop()
  }
  uni.showToast({
    title: '录音已取消',
    icon: 'none',
    duration: 1500
  })
  resetState()
  emit('onRecordCancel')
}

// 开始录音
const startRecording = async () => {
  if (currentState.value !== 'default') return

  // #ifdef WEB
  // 确保麦克风权限可用
  const hasPermission = await MicrophonePermissionHelper.ensure(true)
  if (!hasPermission) {
    return
  }
  // #endif

  // 开始录音
  if (recorderManager) {
    try {
      recorderManager.start({
        duration: props.duration,
        sampleRate: props.sampleRate,
        numberOfChannels: 1,
        encodeBitRate: 192000,
        format: props.format
      })
    } catch (error: any) {
      console.error('启动录音失败:', error)
      errorMessage.value = '启动录音失败'
      currentState.value = 'error'
      emit('onError', error)
    }
  }
}

// 停止录音
const stopRecording = () => {
  if (currentState.value !== 'recording') return
  
  if (recorderManager) {
    try {
      recorderManager.stop()
    } catch (error: any) {
      console.error('停止录音失败:', error)
      errorMessage.value = '停止录音失败'
      currentState.value = 'error'
      emit('onError', error)
    }
  }
}

// 使用audioUploader转换音频
const uploadAndConvertWithService = async (audioFile: AudioFile): Promise<TranscriptResult> => {
  if (!audioUploadService) {
    throw new Error('音频上传服务未初始化')
  }

  try {
    // 转换音频文件格式
    const uploaderAudioFile: UploaderAudioFile = {
      tempFilePath: audioFile.tempFilePath,
      duration: audioFile.duration,
      fileSize: audioFile.fileSize,
      format: audioFile.format
    }

    // 调用audioUploader的上传方法
    const result = await audioUploadService.uploadAudio(
      uploaderAudioFile,
      (progress: UploadProgress) => {
        // 上传进度回调
        console.log('上传进度:', progress.percent + '%')
        props.onUploadProgress?.(progress.percent)
      }
    )

    // 转换结果格式
    return {
      success: result.success,
      text: result.text,
      confidence: result.confidence,
      duration: result.duration,
      error: result.error
    }
  } catch (error: any) {
    console.error('音频转换服务调用失败:', error)
    throw error
  }
}

// 组件卸载时清理资源
onUnmounted(() => {
  stopDurationTimer()
  if (recorderManager) {
    // 清理事件监听器
    recorderManager.offStart(handleRecordStart)
    recorderManager.offStop(handleRecordStop)
  }
})
</script>

<style lang="scss" scoped>
  .voice-recorder-container {
    flex: 1;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 8rpx;
    height: 70rpx;
    border-radius: 24rpx;
    transition: background-color 0.3s ease;

    &.full-recording {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10; // Ensure it covers other elements
      background-color: rgba(0,0,0,0.1); // Optional overlay
    }

    .voice-button {
      position: relative;
      width: 100%; // Make it full width to occupy more space
      height: 80rpx; // Increase height for better touch area
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: row;
      transition: all 0.2s ease;
      user-select: none;
      
      // 默认状态
      &--default {
        background-color: transparent; // No background
        border: none; // Remove border
      }

      // &--pressed {
      //   transform: scale(1.1);
      //   background-color: #5147FF;
      //   border-color: #5147FF;
      //   height: 112rpx;
      //   width: 100%;
      // }
      
      // 录音中状态
      &--recording {
        background-color: #5147FF;
        border-color: #5147FF;
        animation: recording-pulse 1s infinite;
        height: 112rpx;
        width: 100%;
      }
      
      // 上传中状态
      &--uploading {
        background-color: #1890ff;
        border-color: #1890ff;
      }
      
      // 成功状态
      &--success {
        background-color: #52c41a;
        border-color: #52c41a;
      }
      
      // 错误状态
      // &--error {
      //   background-color: #ff4d4f;
      //   border-color: #ff4d4f;
      //   color: #fff;
      // }

      &--cancelled {
        background-color: #999999;
        border-color: #999999;
        animation: none;
      }
    }

    .waveform {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 4rpx;
      z-index: 1; // Behind text
      width: 100%; // Adjust width to fit inside button
    }

    .waveform-bar {
      width: 6rpx;
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 3rpx;
      animation: waveform-bounce 0.6s ease-in-out infinite alternate;
    }

    .voice-tips {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 28rpx;
      font-weight: 500;
      white-space: nowrap;
      z-index: 2;

      &:active {
        background-color: transparent;
      }
    }

    .voice-button--default .voice-tips text {
      color: #15171F;
    }

    .voice-button--recording .voice-tips text,
    .voice-button--cancelled .voice-tips text {
      color: #FFFFFF;
    }

    .voice-button--uploading .voice-tips text {
      color: #FFFFFF;
    }

    .voice-button--success .voice-tips text {
      color: #FFFFFF;
    }

    .voice-button--error .voice-tips text {
      color: #FFFFFF;
    }

    // 动画定义
    @keyframes recording-pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(255, 77, 79, 0.7);
      }
      70% {
        box-shadow: 0 0 0 20rpx rgba(255, 77, 79, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(255, 77, 79, 0);
      }
    }

    @keyframes waveform-bounce {
      from {
        transform: scaleY(0.5);
      }
      to {
        transform: scaleY(1.5);
      }
    }
  }
</style>