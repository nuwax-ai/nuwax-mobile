# 流式 Markdown 渲染接入指南

## 概述

本指南详细介绍如何在 uni-app x 项目中集成流式 Markdown 渲染功能，实现类似 ChatGPT 的打字机效果。基于 `ParseMarkdown.uts` 解析器，适用于聊天应用、AI 对话、实时文档协作等场景。

## 快速开始

### 1. 基本集成

#### 创建解析器实例

```typescript
import ParseMarkdown from '@/uni_modules/uni-ai-x/sdk/parseMarkdown.uts'
import { MarkdownToken } from '@/types/markdown'

// 创建解析器，设置回调函数
const parser = new ParseMarkdown((tokens: MarkdownToken[]) => {
  // 实时接收解析结果
  console.log('解析更新:', tokens)
  updateUI(tokens)
})

// 开始解析流式内容
let streamContent = ''
onStreamChunk((chunk: string) => {
  streamContent += chunk
  parser.runTask(streamContent)
})
```

#### 解析结果处理

根据项目的**流式解析与Markdown解析处理规范**，解析器采用回调函数机制：

```typescript
// 解析结果数据结构
interface MarkdownToken {
  type: string          // 'heading' | 'code' | 'paragraph' | 'list' | 'blockquote'
  text?: string         // 文本内容
  raw?: string          // 原始markdown文本
  lang?: string         // 代码块语言
  isClose?: boolean     // 是否完整闭合
  uniqueId?: string     // 唯一标识符
  codeTokens?: IToken[][] // 代码高亮tokens
}
```

### 2. 聊天页面集成

#### 完整聊天组件示例

```vue
<template>
  <view class="chat-page">
    <scroll-view 
      class="message-list" 
      scroll-y 
      :scroll-top="scrollTop"
      :scroll-with-animation="true"
    >
      <view 
        v-for="message in messages" 
        :key="message.id" 
        class="message-item"
        :class="message.role"
      >
        <!-- 用户消息 -->
        <view v-if="message.role === 'user'" class="user-message">
          <text>{{ message.content }}</text>
        </view>
        
        <!-- AI消息 - 流式渲染 -->
        <view v-else class="ai-message">
          <markdown-renderer 
            :tokens="message.tokens" 
            :streaming="message.streaming"
          />
        </view>
      </view>
    </scroll-view>
    
    <!-- 输入区域 -->
    <view class="input-container">
      <input 
        v-model="inputText" 
        placeholder="请输入消息..."
        @confirm="sendMessage"
        :disabled="isStreaming"
      />
      <button @click="sendMessage" :disabled="isStreaming">
        {{ isStreaming ? '发送中...' : '发送' }}
      </button>
    </view>
  </view>
</template>

<script setup lang="ts">
import { ref, nextTick } from 'vue'
import { fetchEventSource } from '@microsoft/fetch-event-source'
import ParseMarkdown from '@/uni_modules/uni-ai-x/sdk/parseMarkdown.uts'

// 响应式数据
const messages = ref<ChatMessage[]>([])
const inputText = ref('')
const scrollTop = ref(0)
const isStreaming = ref(false)

// 消息接口
interface ChatMessage {
  id: string
  role: 'user' | 'assistant'
  content: string
  tokens?: MarkdownToken[]
  streaming?: boolean
}

// 发送消息
const sendMessage = async () => {
  if (!inputText.value.trim() || isStreaming.value) return
  
  // 添加用户消息
  const userMessage: ChatMessage = {
    id: generateId(),
    role: 'user',
    content: inputText.value
  }
  messages.value.push(userMessage)
  
  // 准备AI回复
  const query = inputText.value
  inputText.value = ''
  
  const aiMessage: ChatMessage = {
    id: generateId(),
    role: 'assistant',
    content: '',
    tokens: [],
    streaming: true
  }
  messages.value.push(aiMessage)
  
  // 开始流式响应
  await handleStreamResponse(query, aiMessage)
}

// 处理流式响应
const handleStreamResponse = async (query: string, aiMessage: ChatMessage) => {
  isStreaming.value = true
  
  // 创建解析器实例
  const parser = new ParseMarkdown((tokens: MarkdownToken[]) => {
    aiMessage.tokens = tokens
    scrollToBottom()
  })
  
  try {
    await fetchEventSource('/api/chat/stream', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ message: query }),
      
      onmessage(event) {
        try {
          const data = JSON.parse(event.data)
          if (data.content) {
            aiMessage.content += data.content
            parser.runTask(aiMessage.content)
          }
          
          if (data.done) {
            aiMessage.streaming = false
          }
        } catch (e) {
          console.warn('解析SSE消息失败:', e)
        }
      },
      
      onerror(error) {
        console.error('SSE连接错误:', error)
        aiMessage.streaming = false
        throw error
      },
      
      onclose() {
        aiMessage.streaming = false
      }
    })
  } catch (error) {
    console.error('流式请求失败:', error)
    aiMessage.content = '抱歉，请求失败了，请重试。'
    aiMessage.streaming = false
  } finally {
    isStreaming.value = false
  }
}

// 滚动到底部
const scrollToBottom = () => {
  nextTick(() => {
    scrollTop.value = 99999
  })
}

// 生成唯一ID
const generateId = (): string => {
  return Date.now().toString() + Math.random().toString(36).substr(2, 9)
}
</script>

<style scoped>
.chat-page {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #f5f5f5;
}

.message-list {
  flex: 1;
  padding: 32rpx;
}

.message-item {
  margin-bottom: 32rpx;
}

.user-message {
  background: #007AFF;
  color: white;
  padding: 24rpx 32rpx;
  border-radius: 32rpx;
  margin-left: 120rpx;
  word-wrap: break-word;
}

.ai-message {
  background: white;
  padding: 24rpx 32rpx;
  border-radius: 32rpx;
  margin-right: 120rpx;
  box-shadow: 0 4rpx 12rpx rgba(0,0,0,0.1);
}

.input-container {
  display: flex;
  padding: 32rpx;
  background: white;
  border-top: 2rpx solid #e5e5e5;
}

.input-container input {
  flex: 1;
  padding: 24rpx 32rpx;
  border: 2rpx solid #e5e5e5;
  border-radius: 48rpx;
  margin-right: 24rpx;
  font-size: 28rpx;
}

.input-container button {
  padding: 24rpx 48rpx;
  background: #007AFF;
  color: white;
  border: none;
  border-radius: 48rpx;
  font-size: 28rpx;
}

.input-container button:disabled {
  background: #ccc;
}
</style>
```

### 3. Markdown 渲染组件

```vue
<!-- components/markdown-renderer/markdown-renderer.uvue -->
<template>
  <view class="markdown-renderer">
    <view v-for="(token, index) in tokens" :key="token.uniqueId || index" class="token-wrapper">
      <!-- 标题渲染 -->
      <text 
        v-if="token.type === 'heading'" 
        :class="`heading heading-${token.depth || 1}`"
      >
        {{ token.text }}
      </text>
      
      <!-- 段落渲染 -->
      <text v-else-if="token.type === 'paragraph'" class="paragraph">
        {{ token.text }}
      </text>
      
      <!-- 代码块渲染 -->
      <view v-else-if="token.type === 'code'" class="code-block">
        <view class="code-header">
          <text class="code-lang">{{ token.lang || 'text' }}</text>
          <text class="copy-btn" @click="copyCode(token.text)">复制</text>
        </view>
        <scroll-view class="code-content" scroll-x>
          <!-- 高亮代码 -->
          <view v-if="token.codeTokens && token.codeTokens.length > 0" class="highlighted-code">
            <view 
              v-for="(lineTokens, lineIndex) in token.codeTokens" 
              :key="lineIndex" 
              class="code-line"
            >
              <text class="line-number">{{ lineIndex + 1 }}</text>
              <text 
                v-for="(codeToken, tokenIndex) in lineTokens" 
                :key="tokenIndex"
                :class="`token ${getTokenClass(codeToken.type)}`"
              >
                {{ codeToken.text }}
              </text>
            </view>
          </view>
          <!-- 普通代码 -->
          <text v-else class="plain-code">{{ token.text }}</text>
        </scroll-view>
      </view>
      
      <!-- 列表渲染 -->
      <view v-else-if="token.type === 'list'" class="list-container">
        <view v-for="(item, itemIndex) in token.items" :key="itemIndex" class="list-item">
          <text class="list-marker">•</text>
          <text class="list-text">{{ item.text }}</text>
        </view>
      </view>
      
      <!-- 引用块渲染 -->
      <view v-else-if="token.type === 'blockquote'" class="blockquote">
        <text>{{ token.text }}</text>
      </view>
      
      <!-- 分割线 -->
      <view v-else-if="token.type === 'hr'" class="hr-line"></view>
      
      <!-- 默认文本 -->
      <text v-else class="default-text">{{ token.text || token.raw }}</text>
    </view>
    
    <!-- 打字机光标 -->
    <view v-if="streaming" class="typing-cursor">
      <text class="cursor-blink">|</text>
    </view>
  </view>
</template>

<script setup lang="ts">
import { defineProps } from 'vue'

// Props定义
const props = defineProps<{
  tokens: MarkdownToken[]
  streaming?: boolean
}>()

// 代码高亮样式映射
const getTokenClass = (tokenType: string): string => {
  const classMap: Record<string, string> = {
    'keyword': 'token-keyword',
    'string': 'token-string', 
    'comment': 'token-comment',
    'number': 'token-number',
    'function': 'token-function',
    'operator': 'token-operator',
    'punctuation': 'token-punctuation',
    'variable': 'token-variable'
  }
  return classMap[tokenType] || 'token-default'
}

// 复制代码功能
const copyCode = (code: string) => {
  uni.setClipboardData({
    data: code,
    success: () => {
      uni.showToast({
        title: '已复制到剪贴板',
        icon: 'success'
      })
    }
  })
}
</script>

<style scoped>
.markdown-renderer {
  line-height: 1.6;
  font-size: 28rpx;
}

.token-wrapper {
  margin-bottom: 24rpx;
}

/* 标题样式 */
.heading {
  font-weight: bold;
  color: #1a1a1a;
  margin-bottom: 16rpx;
}

.heading-1 { font-size: 48rpx; }
.heading-2 { font-size: 40rpx; }
.heading-3 { font-size: 36rpx; }
.heading-4 { font-size: 32rpx; }
.heading-5 { font-size: 30rpx; }
.heading-6 { font-size: 28rpx; }

/* 段落样式 */
.paragraph {
  color: #333;
  line-height: 1.7;
  word-wrap: break-word;
}

/* 代码块样式 */
.code-block {
  background: #1e1e1e;
  border-radius: 16rpx;
  margin: 24rpx 0;
  overflow: hidden;
}

.code-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #2d2d2d;
  padding: 20rpx 32rpx;
  border-bottom: 2rpx solid #404040;
}

.code-lang {
  color: #9cdcfe;
  font-size: 24rpx;
  font-weight: 500;
}

.copy-btn {
  color: #569cd6;
  font-size: 24rpx;
  padding: 8rpx 16rpx;
  background: rgba(86, 156, 214, 0.1);
  border-radius: 8rpx;
}

.code-content {
  padding: 32rpx;
  background: #1e1e1e;
  max-height: 800rpx;
}

.highlighted-code {
  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
}

.code-line {
  display: flex;
  margin-bottom: 6rpx;
  min-height: 40rpx;
  align-items: center;
}

.line-number {
  color: #6e7681;
  font-size: 24rpx;
  width: 60rpx;
  text-align: right;
  margin-right: 24rpx;
  user-select: none;
}

.plain-code {
  color: #d4d4d4;
  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
  white-space: pre-wrap;
  word-break: break-all;
}

/* 代码高亮tokens */
.token-keyword { color: #569cd6; font-weight: 500; }
.token-string { color: #ce9178; }
.token-comment { color: #6a9955; font-style: italic; }
.token-number { color: #b5cea8; }
.token-function { color: #dcdcaa; }
.token-operator { color: #d4d4d4; }
.token-punctuation { color: #cccccc; }
.token-variable { color: #9cdcfe; }
.token-default { color: #d4d4d4; }

/* 列表样式 */
.list-container {
  padding-left: 32rpx;
}

.list-item {
  display: flex;
  margin-bottom: 12rpx;
  align-items: flex-start;
}

.list-marker {
  color: #007AFF;
  font-weight: bold;
  margin-right: 16rpx;
  margin-top: 4rpx;
}

.list-text {
  flex: 1;
  color: #333;
  line-height: 1.6;
}

/* 引用样式 */
.blockquote {
  border-left: 8rpx solid #007AFF;
  background: rgba(0, 122, 255, 0.05);
  padding: 24rpx 32rpx;
  margin: 24rpx 0;
  border-radius: 0 16rpx 16rpx 0;
}

.blockquote text {
  color: #555;
  font-style: italic;
  line-height: 1.6;
}

/* 分割线 */
.hr-line {
  height: 2rpx;
  background: linear-gradient(90deg, transparent, #e1e4e8, transparent);
  margin: 48rpx 0;
}

/* 默认文本 */
.default-text {
  color: #333;
  line-height: 1.6;
}

/* 打字机光标 */
.typing-cursor {
  display: inline-block;
  margin-left: 8rpx;
}

.cursor-blink {
  color: #007AFF;
  font-weight: bold;
  animation: blink 1.2s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}
</style>
```

## 高级功能

### 1. SSE 连接封装

```typescript
// utils/sseClient.ts
import { fetchEventSource } from '@microsoft/fetch-event-source'

export interface SSEOptions {
  url: string
  data?: any
  onMessage: (data: any) => void
  onError?: (error: Error) => void
  onComplete?: () => void
  headers?: Record<string, string>
}

export const createSSEConnection = async (options: SSEOptions): Promise<void> => {
  const { url, data, onMessage, onError, onComplete, headers = {} } = options
  
  try {
    await fetchEventSource(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'text/event-stream',
        ...headers
      },
      body: data ? JSON.stringify(data) : undefined,
      
      onmessage(event) {
        try {
          const parsedData = JSON.parse(event.data)
          onMessage(parsedData)
        } catch (e) {
          console.warn('SSE消息解析失败:', e)
        }
      },
      
      onerror(error) {
        console.error('SSE连接错误:', error)
        onError?.(error as Error)
        throw error
      },
      
      onclose() {
        console.log('SSE连接关闭')
        onComplete?.()
      }
    })
  } catch (error) {
    onError?.(error as Error)
    throw error
  }
}
```

### 2. 流式内容管理器

```typescript
// composables/useStreamingMarkdown.ts
import { ref, reactive } from 'vue'
import ParseMarkdown from '@/uni_modules/uni-ai-x/sdk/parseMarkdown.uts'

export const useStreamingMarkdown = () => {
  const tokens = ref<MarkdownToken[]>([])
  const isStreaming = ref(false)
  const content = ref('')
  
  let parser: ParseMarkdown | null = null
  
  // 初始化解析器
  const initParser = () => {
    parser = new ParseMarkdown((updatedTokens: MarkdownToken[]) => {
      tokens.value = updatedTokens
    })
  }
  
  // 开始流式解析
  const startStream = () => {
    if (!parser) initParser()
    isStreaming.value = true
    content.value = ''
    tokens.value = []
  }
  
  // 添加流式内容
  const appendContent = (chunk: string) => {
    content.value += chunk
    if (parser) {
      parser.runTask(content.value)
    }
  }
  
  // 结束流式解析
  const endStream = () => {
    isStreaming.value = false
  }
  
  // 重置状态
  const reset = () => {
    tokens.value = []
    content.value = ''
    isStreaming.value = false
    parser = null
  }
  
  return {
    tokens: readonly(tokens),
    isStreaming: readonly(isStreaming),
    content: readonly(content),
    startStream,
    appendContent,
    endStream,
    reset
  }
}
```

### 3. 使用组合式API简化开发

```vue
<script setup lang="ts">
import { useStreamingMarkdown } from '@/composables/useStreamingMarkdown'
import { createSSEConnection } from '@/utils/sseClient'

const { tokens, isStreaming, startStream, appendContent, endStream, reset } = useStreamingMarkdown()

const sendMessage = async (message: string) => {
  startStream()
  
  try {
    await createSSEConnection({
      url: '/api/chat/stream',
      data: { message },
      onMessage: (data) => {
        if (data.content) {
          appendContent(data.content)
        }
        if (data.done) {
          endStream()
        }
      },
      onError: (error) => {
        console.error('流式请求失败:', error)
        endStream()
      }
    })
  } catch (error) {
    endStream()
  }
}
</script>
```

## 性能优化

### 1. 虚拟滚动优化

```vue
<!-- 对于长对话列表 -->
<recycle-list 
  class="message-list"
  :list-data="messages"
  :template-key="'message'"
>
  <template v-slot:message="{ item }">
    <message-item :message="item" />
  </template>
</recycle-list>
```

### 2. 防抖优化

```typescript
// 防止过于频繁的解析更新
import { debounce } from 'lodash-es'

const debouncedUpdate = debounce((tokens: MarkdownToken[]) => {
  updateTokens(tokens)
}, 100)
```

### 3. 内存管理

```typescript
// 清理历史消息
const MAX_MESSAGES = 50

const cleanupMessages = () => {
  if (messages.value.length > MAX_MESSAGES) {
    messages.value = messages.value.slice(-MAX_MESSAGES)
  }
}
```

## 常见问题

### Q1: 代码高亮不显示？
**解决方案**:
1. 确认 `uni-highlight` 模块已正确安装
2. 检查语法文件路径是否正确
3. 验证代码块语言标识是否支持

### Q2: 流式渲染卡顿？
**解决方案**:
1. 调整解析器延迟时间（默认300ms）
2. 使用防抖函数减少更新频率
3. 开启虚拟滚动优化长列表

### Q3: 内存占用过高？
**解决方案**:
1. 定期清理历史消息
2. 使用对象池复用token对象
3. 避免深层对象嵌套

### Q4: SSE连接频繁断开？
**解决方案**:
1. 实现自动重连机制
2. 添加心跳检测
3. 优化网络错误处理

## 总结

通过本指南，您可以快速在 uni-app x 项目中集成流式 Markdown 渲染功能。关键要点：

1. **使用ParseMarkdown解析器**：基于回调函数机制实时处理流式数据
2. **遵循项目规范**：采用async/await风格，符合uni-app x框架要求
3. **优化用户体验**：实现打字机效果和代码高亮
4. **注意性能优化**：防抖处理、内存管理、虚拟滚动

这套方案特别适合AI对话、实时协作、在线文档等需要流式文本渲染的场景，提供了完整的开发到部署解决方案。