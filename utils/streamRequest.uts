import { StreamRequestConfig, StreamChunk } from '@/types/interfaces/chat'

// 流式请求工具类
export class StreamRequest {
  private requestTask: RequestTask | null = null
  private isAborted: boolean = false

  // 发起流式请求
  async request(config: StreamRequestConfig): Promise<void> {
    this.isAborted = false
    
    try {
      // #ifdef H5
      await this.requestH5(config)
      // #endif
      
      // #ifdef MP-WEIXIN
      await this.requestWeapp(config)
      // #endif
      
      // #ifdef APP-PLUS
      await this.requestApp(config)
      // #endif
      
    } catch (error) {
      if (!this.isAborted) {
        config.onError?.(error)
      }
    }
  }

  // H5环境下的流式请求
  private async requestH5(config: StreamRequestConfig): Promise<void> {
    // #ifdef H5
    const response = await fetch(config.url, {
      method: config.method,
      headers: config.headers as any,
      body: config.body ? JSON.stringify(config.body) : undefined
    })

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const reader = response.body?.getReader()
    if (!reader) {
      throw new Error('No response body')
    }

    const decoder = new TextDecoder()
    let buffer = ''

    while (true) {
      if (this.isAborted) break

      const { done, value } = await reader.read()
      if (done) break

      buffer += decoder.decode(value, { stream: true })
      const lines = buffer.split('\n')
      buffer = lines.pop() || ''

      for (const line of lines) {
        if (line.trim() === '') continue
        
        if (line.startsWith('data:')) {
          const data = line.slice(5)

          try {
            const parseData = JSON.parse(data)
            if (parseData.completed) {
              config.onComplete?.()
              return
            }
          } catch (e) {
            console.error('Parse chunk error:', e)
          }
          
          try {
            const chunk: StreamChunk = {
              type: 'content',
              data: data
            }
            config.onChunk?.(chunk)
          } catch (e) {
            console.error('Parse chunk error:', e)
          }
        }
      }
    }
    // #endif
  }

  // 微信小程序环境下的流式请求
  private async requestWeapp(config: StreamRequestConfig): Promise<void> {
    // #ifdef MP-WEIXIN
    return new Promise((resolve, reject) => {
      this.requestTask = uni.request({
        url: config.url,
        method: config.method,
        header: config.headers as any,
        data: config.body,
        success: (res) => {
          if (res.statusCode === 200) {
            // 处理流式响应
            this.handleStreamResponse(res.data as string, config)
            resolve()
          } else {
            reject(new Error(`HTTP error! status: ${res.statusCode}`))
          }
        },
        fail: (err) => {
          if (!this.isAborted) {
            reject(err)
          }
        }
      })
    })
    // #endif
  }

  // App环境下的流式请求
  private async requestApp(config: StreamRequestConfig): Promise<void> {
    // #ifdef APP-PLUS
    return new Promise((resolve, reject) => {
      this.requestTask = uni.request({
        url: config.url,
        method: config.method,
        header: config.headers as any,
        data: config.body,
        success: (res) => {
          if (res.statusCode === 200) {
            // 处理流式响应
            this.handleStreamResponse(res.data as string, config)
            resolve()
          } else {
            reject(new Error(`HTTP error! status: ${res.statusCode}`))
          }
        },
        fail: (err) => {
          if (!this.isAborted) {
            reject(err)
          }
        }
      })
    })
    // #endif
  }

  // 处理流式响应数据
  private handleStreamResponse(data: string, config: StreamRequestConfig): void {
    const lines = data.split('\n')
    
    for (const line of lines) {
      if (line.trim() === '') continue
      
      if (line.startsWith('data:')) {
        const content = line.slice(5)
        if (content === '[DONE]') {
          config.onComplete?.()
          return
        }
				try {
				  const parseData = JSON.parse(data)
				  if (parseData.completed) {
				    config.onComplete?.()
				    return
				  }
				} catch (e) {
				  console.error('Parse chunk error:', e)
				}
        
        try {
          const chunk: StreamChunk = {
            type: 'content',
            data: content
          }
          config.onChunk?.(chunk)
        } catch (e) {
          console.error('Parse chunk error:', e)
        }
      }
    }
  }

  // 中止请求
  abort(): void {
    this.isAborted = true
    if (this.requestTask) {
      this.requestTask.abort()
      this.requestTask = null
    }
  }
}

// 创建流式请求实例
export const streamRequest = new StreamRequest()
