import type { FileNode } from '@/types/interfaces/agent'

/**
 * 文件相关常量
 */
export const FILE_CONSTANTS = {
  // 支持预览的文件扩展名白名单
  SUPPORTED_EXTENSIONS: [
    // 图片文件
    'jpg',
    'jpeg',
    'png',
    'gif',
    'bmp',
    'webp',
    'svg',
    'ico',
    'tiff',
    // 代码文件
    'ts',
    'tsx',
    'js',
    'jsx',
    'mjs',
    'cjs',
    'css',
    'less',
    'scss',
    'sass',
    'html',
    'htm',
    'vue',
    'json',
    'jsonc',
    'yaml',
    'yml',
    'xml',
    'toml',
    'ini',
    'py',
    'java',
    'c',
    'cpp',
    'cs',
    'php',
    'rb',
    'go',
    'rs',
    'swift',
    'kt',
    'scala',
    'sh',
    'bash',
    'zsh',
    'fish',
    'ps1',
    'bat',
    'sql',
    'dockerfile',
    'makefile',
    // 文本文件
    'txt',
    'md',
    'markdown',
    'log',
    'csv',
    'tsv',
    'rtf',
  ],
  // 忽略的文件模式
  IGNORED_FILE_PATTERNS: [
    /^\./, // 以 . 开头的隐藏文件
    /^\.DS_Store$/,
    /^Thumbs\.db$/,
    /\.tmp$/,
    /\.bak$/,
  ],
  DEFAULT_FILE_LANGUAGE: 'Plain Text',
  FALLBACK_SIZE: 0,
  TREE_ROOT_LEVEL: 0,
  INDENT_SIZE: 16,
  REQUEST_ID_PREFIX: 'req_',
  SESSION_ID_PREFIX: 'session_',
};

/**
 * 将扁平的文件列表转换为树形结构
 */
export const transformFlatListToTree = (files: any[]): FileNode[] => {
  const root: FileNode[] = [];
  const map = new Map<string, FileNode>();

  // 过滤掉系统文件
  const filteredFiles = files.filter((file) => {
    const fileName = file.name.split('/').pop();
    return !FILE_CONSTANTS.IGNORED_FILE_PATTERNS.some((pattern) =>
      pattern.test(fileName || ''),
    );
  });

  // 创建所有文件节点和必要的文件夹节点
  filteredFiles.forEach((file) => {
    const pathParts = file.name.split('/').filter(Boolean);
    const fileName = pathParts[pathParts.length - 1];
    const isFile = fileName.includes('.');

    const node: FileNode = {
      id: file.name,
      name: fileName,
      type: isFile ? 'file' : 'folder',
      path: file.name,
      children: [],
      binary: file.binary || false,
      size:
        file.size || file.sizeExceeded
          ? FILE_CONSTANTS.FALLBACK_SIZE
          : file.contents?.length || FILE_CONSTANTS.FALLBACK_SIZE,
      status: file.status || null,
      fullPath: file.name,
      parentPath: pathParts.slice(0, -1).join('/') || null,
      content: file.contents || '',
      lastModified: Date.now(),
      fileProxyUrl: file?.fileProxyUrl || '',
    };

    map.set(file.name, node);

    // 如果文件在子目录中，确保创建所有必要的父文件夹节点
    if (pathParts.length > 1) {
      for (let i = pathParts.length - 2; i >= 0; i--) {
        const parentPath = pathParts.slice(0, i + 1).join('/');
        const parentName = pathParts[i];

        if (!map.has(parentPath)) {
          const parentNode: FileNode = {
            id: parentPath,
            name: parentName,
            type: 'folder',
            path: parentPath,
            children: [],
            parentPath: i > 0 ? pathParts.slice(0, i).join('/') : null,
            lastModified: Date.now(),
          };
          map.set(parentPath, parentNode);
        }
      }
    }
  });

  // 构建层次结构
  map.forEach((node) => {
    if (node.parentPath && map.has(node.parentPath)) {
      const parentNode = map.get(node.parentPath)!;
      if (
        !parentNode.children?.find((child: FileNode) => child.id === node.id)
      ) {
        parentNode.children?.push(node);
      }
    } else if (!node.parentPath) {
      if (!root.find((item: FileNode) => item.id === node.id)) {
        root.push(node);
      }
    }
  });

  // 排序：文件夹在前，文件在后，同类型按名称排序
  const sortNodes = (nodes: FileNode[]): FileNode[] => {
    return nodes.sort((a, b) => {
      if (a.type !== b.type) {
        return a.type === 'folder' ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
  };

  return sortNodes(root).map((node) => ({
    ...node,
    children: node.children ? sortNodes(node.children) : undefined,
  }));
};


  /**
   * 从响应头中解析文件名
   * @param contentDisposition Content-Disposition 响应头
   * @param defaultName 默认文件名
   */
  const parseFileName = (contentDisposition: string | undefined, defaultName: string): string => {
    if (!contentDisposition) return defaultName;
    
    // 解析 Content-Disposition 头中的文件名
    const filenameMatch = contentDisposition.match(
      /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/,
    );
    if (filenameMatch && filenameMatch[1]) {
      return filenameMatch[1].replace(/['"]/g, '');
    }
    return defaultName;
  };

  /**
   * H5 环境：导出整个项目压缩包
   * @param blob Blob 对象
   * @param headers 响应头
   * @param defaultName 默认文件名称
   */
  // #ifdef H5 || WEB
  export const exportWholeProjectZipH5 = async (blob: Blob, headers: any, defaultName: string) => {
    // 从响应头中获取文件名
    const contentDisposition = headers?.['content-disposition'];
    const filename = parseFileName(contentDisposition, defaultName);

    // 创建下载链接
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;

    // 触发下载
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // 清理URL对象
    window.URL.revokeObjectURL(url);
  };
  // #endif

  /**
   * 小程序环境：下载文件
   * @param downloadUrl 下载地址
   * @param filename 文件名称
   */
  // #ifdef MP-WEIXIN || MP-ALIPAY || MP-BAIDU || MP-TOUTIAO || MP-QQ
  export const downloadFileInMiniProgram = async (downloadUrl: string, filename: string) => {
    return new Promise<void>((resolve, reject) => {
      uni.showLoading({ title: '下载中...' });
      uni.downloadFile({
        url: downloadUrl,
        success: (res) => {
          if (res.statusCode === 200) {
            uni.saveFile({
              tempFilePath: res.tempFilePath,
              success: (saveRes) => {
                uni.hideLoading();
                uni.showToast({
                  title: '文件已保存',
                  icon: 'success',
                });
                resolve();
              },
              fail: (err) => {
                uni.hideLoading();
                console.error('保存文件失败:', err);
                uni.showToast({
                  title: '保存文件失败',
                  icon: 'none',
                });
                reject(err);
              },
            });
          } else {
            uni.hideLoading();
            uni.showToast({
              title: '下载失败',
              icon: 'none',
            });
            reject(new Error(`下载失败: ${res.statusCode}`));
          }
        },
        fail: (err) => {
          uni.hideLoading();
          console.error('下载文件失败:', err);
          uni.showToast({
            title: '下载失败',
            icon: 'none',
          });
          reject(err);
        },
      });
    });
  };
  // #endif