import { nextTick } from 'vue'
import { NodesToken as MarkdownToken } from '@/uni_modules/kux-marked'
import { MessageInfo, ConversationChatParams, ConversationChatResponse, ConversationChatSuggestParams, ProcessingInfo, MessageQuestionExtInfo, AttachmentFile, ConversationCreateParams } from '@/types/interfaces/conversationInfo'
import type { AgentSelectedComponentInfo, AgentConversationUpdateParams } from '@/types/interfaces/agent'
import { UploadFileInfo } from '@/types/interfaces/common'
import { ConversationInfo } from '@/types/interfaces/conversationInfo'
import { RequestResponse } from '@/types/interfaces/request'
import { MessageModeEnum, ConversationEventTypeEnum, MessageTypeEnum, AssistantRoleEnum } from '@/types/enums/agent'
import { MessageStatusEnum } from '@/types/enums/common'
import { OpenCloseEnum } from '@/types/enums/space'
import { SUCCESS_CODE } from '@/constants/codes.constants'
import { chatService } from '@/utils/chatService'
import { apiAgentConversationCreate, apiAgentConversation, apiAgentConversationChatSuggest, apiAgentConversationUpdate, apiAgentConversationChatStop } from '@/servers/conversation'
import { apiPublishedAgentInfo, apiCollectAgent, apiUnCollectAgent } from '@/servers/agentDev'
import { v4 as uuidv4 } from 'uuid'
import ParseMarkdown from '@/uni_modules/uni-ai-x/sdk/parseMarkdown.uts'
import treeToListSdk from '@/uni_modules/uni-ai-x/sdk/treeToList.uts'
import { markdownElItem } from '@/uni_modules/uni-ai-x/types.uts'
import AgentDetailData from '@/pages/agent-detail/layers/AgentDetailData.uts'
import AgentDetailUtils from '@/pages/agent-detail/layers/AgentDetailUtils.uts'
import { getCustomBlock } from '@/pages/agent-detail/layers/MarkdownContainer.uts'
import { replaceMathBracket } from '@/utils/markdown.uts'

/**
 * 服务层：负责业务逻辑和API调用
 */
export default class AgentDetailService {
	private data: AgentDetailData
	constructor(private data: AgentDetailData) {
		this.data = data
	}
	resetParseMarkdown(): void {
		this.data.parseMarkdownInstance = null;
		this.initParseMarkdown();
		// console.log('resetParseMarkdown')
	}
	/**
	 * 初始化ParseMarkdown实例
	 */
	initParseMarkdown(): void {
		if (!this.data.parseMarkdownInstance) {
			this.data.parseMarkdownInstance = new ParseMarkdown((markdownTokenList: MarkdownToken[]) => {
				const markdownElList = (markdownTokenList as any[]).map((token: any) => ({
					uniqueId: token.uniqueId || `token_${Date.now()}_${Math.random()}`,
					type: token.type || 'text',
					datasList: treeToListSdk.markTreeToList(token)
				}))
				
				// 更新最新AI消息的markdownElList
				if (this.data.messageList.value.length > 0) {
					const lastMsg = this.data.messageList.value[this.data.messageList.value.length - 1]
					if (lastMsg.messageType === MessageTypeEnum.ASSISTANT) {
						lastMsg.markdownElList = markdownElList
						this.data.messageList.value = [...this.data.messageList.value]
					}
				}
			})
		}
	}

	/**
	 * 将文本转换为markdown元素列表
	 */
	const handleMarkdownElList = (text: string, id: string): markdownElItem[] => {
		if (!text || text.trim().length === 0) {
			return []
		}

		// 循环markdownElements，生成markdownElList
		const markdownElList: markdownElItem[] = []

		const markdownElements: MarkdownToken[] = ParseMarkdown.parseMarkdownToTokens(text)
		for (const element of markdownElements) {
			const datasList: MarkdownToken[][] = treeToListSdk.markTreeToList(element)
			markdownElList.push({
				uniqueId: element.uniqueId || AgentDetailUtils.generateUniqueId(),
				id: id,
				body: element.raw,
				type: element.type,
				datasList,
			})
		}

		return markdownElList;
	}

	/**
	 * 处理查询会话
	 */
	async handleQueryConversation(result: RequestResponse<ConversationInfo>): Promise<void> {
		this.data.isLoadingConversation.value = true
		const { data: responseData } = result
		
		this.data.conversationInfo.value = responseData as unknown as ConversationInfo
		// 是否开启问题建议,可用值:Open,Close
		this.data.isSuggest.value = responseData?.agent?.openSuggest === OpenCloseEnum.Open
		// 可用组件列表
		this.data.manualComponents.value = responseData?.agent?.manualComponents || []
		
		const _variables = responseData?.agent?.variables || []
		AgentDetailUtils.handleVariables(_variables, this.data)
		this.data.userFillVariables.value = responseData?.variables as any
		
		const _messageList = responseData?.messageList || []
		const len = _messageList?.length || 0
		
		if (len) {
			// 为没有markdownElList的消息生成markdownElList
			const processedMessageList = _messageList.map((message: MessageInfo) => {
				if (!message.markdownElList && message.text) {
					const text = replaceMathBracket(message.text)
					const id = message.id || AgentDetailUtils.generateUniqueId()
					const markdownElList = this.handleMarkdownElList(text, id)
					return { ...message, text, id, markdownElList }
				}
				return message
			})
			
			this.data.messageList.value = processedMessageList
			AgentDetailUtils.checkConversationActive(processedMessageList, this.data)
			
			// 处理问题建议
			const lastMessage = processedMessageList[len - 1]
			if (lastMessage.type === MessageModeEnum.QUESTION && lastMessage.ext?.length) {
				const suggestList = lastMessage.ext.map((item) => item.content) || []
				this.data.chatSuggestList.value = suggestList
			} else if (len === 1) {
				this.data.chatSuggestList.value = responseData?.agent?.openingGuidQuestions || []
			}
		} else {
			this.data.chatSuggestList.value = responseData?.agent?.openingGuidQuestions || []
		}
	}

	runMarkdownTask(text: string): void {
		this.data.parseMarkdownInstance.runTask(text)
		// const markdownElList = this.handleMarkdownElList(text);
		// debugger
		// const markdownElList = (markdownTokenList as any[]).map((token: any) => ({
		// 	uniqueId: token.uniqueId || `token_${Date.now()}_${Math.random()}`,
		// 	type: token.type || 'text',
		// 	datasList: treeToListSdk.markTreeToList(token)
		// }))
		
		// // 更新最新AI消息的markdownElList
		// if (this.data.messageList.value.length > 0) {
		// 	const lastMsg = this.data.messageList.value[this.data.messageList.value.length - 1]
		// 	if (lastMsg.messageType === MessageTypeEnum.ASSISTANT) {
		// 		lastMsg.markdownElList = markdownElList
		// 		this.data.messageList.value = [...this.data.messageList.value]
		// 	}
		// }
	}

	/**
	 * 修改消息列表
	 */
	async handleChangeMessageList(
		res: ConversationChatResponse,
		currentMessageId: string,
	): Promise<void> {
		const { data: responseData, eventType } = res
		this.data.currentConversationRequestId.value = res.requestId
		
		// 调试日志：追踪流式过程
		// console.log(`[Stream] Event: ${eventType}, MessageId: ${currentMessageId}, Text: ${responseData?.text?.substring(0, 50)}...`)
		
		if (!this.data.messageList.value?.length) return
		
		const list = [...this.data.messageList.value]
		const index = list.findIndex((item) => item.id === currentMessageId)
		let arraySpliceAction = 1
		
		const currentMessage = list.find((item) => item.id === currentMessageId) as MessageInfo
		if (!currentMessage) return
		
		// 检查是否是新的对话开始（第一个消息块）
		const isNewConversation = !currentMessage.text || currentMessage.text.length === 0
		
		// 确保流式过程中消息始终可见
		if (currentMessage.status === MessageStatusEnum.Loading) {
			currentMessage.status = MessageStatusEnum.Incomplete
			// console.log(`[Stream] Message ${currentMessageId} status changed from Loading to Incomplete`)
		}
		
		let newMessage: MessageInfo | null = null
			// markdown元素列表，占位使用，真正数据更新时在uni-ai-x-msg中更新
		const tempMarkdownElList: markdownElItem[] = [{
			uniqueId: currentMessageId,
			type: 'text',
			datasList: []
		}]
		// 处理不同的事件类型
		if (eventType === ConversationEventTypeEnum.PROCESSING) {
			const processingResult = responseData.result || {}
			responseData.executeId = processingResult.executeId

			const accumulatedText = getCustomBlock(currentMessage.text || '', responseData)
			this.runMarkdownTask(accumulatedText, tempMarkdownElList)

			newMessage = {
				...currentMessage,
				text: accumulatedText,
				status: MessageStatusEnum.Loading,
				markdownElList: tempMarkdownElList,
				processingList: [...(currentMessage?.processingList || []), responseData] as ProcessingInfo[],
			}
			AgentDetailUtils.handleChatProcessingList([...(currentMessage?.processingList || []), { ...responseData }] as ProcessingInfo[], this.data)
		}
		
		if (eventType === ConversationEventTypeEnum.MESSAGE) {
			const { text, type, ext, id, finished } = responseData
			// 如果会话结束，则设置会话状态为不活跃
			if (finished) {
				this.data.isConversationActive.value = false
			}
			
			if (type === MessageModeEnum.THINK) {
				newMessage = {
					...currentMessage,
					think: `${currentMessage.think}${text}`,
					status: MessageStatusEnum.Incomplete,
				}
			} else if (type === MessageModeEnum.QUESTION) {
				// 问题内容累积 - 新对话时从头开始，否则累积
				const accumulatedText = replaceMathBracket(isNewConversation ? text : `${currentMessage.text}${text}`)
				this.runMarkdownTask(text, tempMarkdownElList)
				newMessage = {
					...currentMessage,
					text: accumulatedText,
					markdownElList: tempMarkdownElList,
					status: finished ? MessageStatusEnum.Complete : MessageStatusEnum.Incomplete,
				}
				
				if (ext?.length) {
					this.data.chatSuggestList.value = ext.map((extItem: MessageQuestionExtInfo) => extItem.content) || []
				}
			} else {
				// 工作流过程输出
				if ((!this.data.messageIdRef.value || this.data.messageIdRef.value !== id) && finished) {
					// 新对话时从头开始，否则累积
					const accumulatedText = replaceMathBracket(isNewConversation ? text : `${currentMessage.text}${text}`)
					this.runMarkdownTask(accumulatedText, tempMarkdownElList)
					newMessage = {
						...currentMessage,
						id,
						text: accumulatedText,
						markdownElList: tempMarkdownElList,
						status: MessageStatusEnum.Complete,
					}
					arraySpliceAction = 0
				} else {
					this.data.messageIdRef.value = id
					// 新对话时从头开始，否则累积
					const accumulatedText = replaceMathBracket(isNewConversation ? text : `${currentMessage.text}${text}`)
					
					this.runMarkdownTask(accumulatedText, tempMarkdownElList)
					newMessage = {
						...currentMessage,
						text: accumulatedText,
						markdownElList: tempMarkdownElList,
						status: MessageStatusEnum.Incomplete,
					}
				}
			}
		}
		
		if (eventType === ConversationEventTypeEnum.FINAL_RESULT) {
			newMessage = {
				...currentMessage,
				status: MessageStatusEnum.Complete,
				finalResult: responseData,
				requestId: res.requestId,
			}
			this.data.requestId.value = res.requestId
		}
		
		if (eventType === ConversationEventTypeEnum.ERROR) {
			newMessage = {
				...currentMessage,
				status: MessageStatusEnum.Error,
			}
			this.data.isConversationActive.value = false
		}

		// 更新消息列表
		if (newMessage) {
			list.splice(index, arraySpliceAction, newMessage as MessageInfo)
		}

		// 确保消息列表更新是同步的
		// AgentDetailUtils.checkConversationActive(list, this.data)
		this.data.messageList.value = [...list]
		
		// 调试日志：状态更新
		// if (newMessage) {
		// 	console.log(`[Stream] Message ${currentMessageId} updated: status=${newMessage.status}, textLength=${newMessage.text?.length || 0}`)
		// }
		
		// 使用优化更新方法，只更新需要更新的组件
		if (newMessage && newMessage.messageType === MessageTypeEnum.ASSISTANT) {
			await nextTick()
			// 这里需要调用组件管理器的更新方法
			// 通过uni事件总线更新
			uni.$emit('updateMessageComponent', {
				messageId: currentMessageId,
				data: {body: replaceMathBracket(newMessage.text), ...newMessage}
			})
		}
	}

	/**
	 * 会话处理
	 */
	async handleConversation(
		params: ConversationChatParams,
		currentMessageId: string,
	): Promise<void> {
		try {
			await chatService.sendMessage(
				params,
				// 处理流式数据
				(chunk: string) => {
					try {
						const result = JSON.parse(chunk)
						this.handleChangeMessageList(result, currentMessageId)
					} catch (error) {
						console.error('解析SSE数据失败:', error, '原始数据:', chunk)
					}
				},
				// 完成回调
				() => {
					if (this.data.isSuggest.value) {
						const responseData = apiAgentConversationChatSuggest(params as ConversationChatSuggestParams)
						this.data.chatSuggestList.value = responseData as unknown as string[]
					}
        	// 第一次发送消息后更新主题
					if(this.data.needUpdateTopicRef.value){
						this.handleUpdateTopic(params.conversationId, params.message)
					}
				},
				// 错误回调
				(error: any) => {
					console.error('Chat error:', error)
				}
			)
		} catch (error) {
			console.error('Chat error:', error)
		}
	}

	// 停止会话
	async handleStopConversation(): Promise<void> {
		this.data.isStoppingConversation.value = true
		// 会话消息请求ID
		const requestId = this.data.currentConversationRequestId.value
		const { code, data: responseData, message } = await apiAgentConversationChatStop(requestId)
		this.data.isStoppingConversation.value = false
		if (code === SUCCESS_CODE) {
			this.data.isConversationActive.value = false
		} else {
			uni.showToast({
				title: message,
				icon: 'none',
				type: 'error'
			})
		}
	}

	/**
	 * 发送消息
	 */
	async handleSendMessage(data: {
		messageInfo?: string,
    files?: UploadFileInfo[],
    selectedComponents?: AgentSelectedComponentInfo[],
    variableParams?: { [key: string]: string | number }
	}): Promise<void> {
		const { messageInfo, files, selectedComponents, variableParams } = data
		// 安全检查：确保this.data存在
		if (!this.data) {
			return
		}

		const attachments: AttachmentFile[] = files?.map((file) => ({
			fileKey: file.key || '',
			fileUrl: file.url || '',
			fileName: file.name || '',
			mimeType: file.type || '',
			fileSize: file.size || 0,
		})) || []
		
		// 参数验证
		if ((!messageInfo || !messageInfo.trim()) && attachments.length === 0) {
			return
		}
		
		if (!this.data.conversationId.value) {
			console.error('handleSendMessage: conversationId is not set')
			return
		}
		
		let chatMessageId: string = ''
		let currentMessageId: string = ''
		
		// #ifdef MP-WEIXIN
		chatMessageId = uni.getRandomValues({ length: 16 }).then(res => res.randomValues.toString()) as string
		currentMessageId = uni.getRandomValues({ length: 16 }).then(res => res.randomValues.toString()) as string
		// #endif
		
		// #ifdef H5
		chatMessageId = uuidv4() as string
		currentMessageId = uuidv4() as string
		// #endif

		// 构造消息
		const chatMessage = {
			role: AssistantRoleEnum.USER,
			type: MessageModeEnum.CHAT,
			text: messageInfo,
			time: new Date().toISOString(),
			attachments,
			id: chatMessageId,
			messageType: MessageTypeEnum.USER,
		}

		// 当前助手信息
		const currentMessage = {
			role: AssistantRoleEnum.ASSISTANT,
			type: MessageModeEnum.CHAT,
			text: '',
			think: '',
			time: new Date().toISOString(),
			id: currentMessageId,
			messageType: MessageTypeEnum.ASSISTANT,
			status: MessageStatusEnum.Loading,
			markdownElList: [],
		} as MessageInfo

		// 将Incomplete状态的消息改为Complete状态，并清理旧的消息状态
		const completeMessageList = this.data.messageList.value?.map((item: MessageInfo) => {
			if (item.status === MessageStatusEnum.Incomplete) {
				item.status = MessageStatusEnum.Complete
			}
			return item
		}) || []
		
		// 清理旧的消息状态，确保新对话开始时状态是干净的
		this.data.messageIdRef.value = ''
		this.data.currentConversationRequestId.value = ''
		
		// 清理 ParseMarkdown 实例状态，确保新对话开始时是干净的状态
		this.resetParseMarkdown();
		
		// 更新消息列表
		const newMessageList = [...completeMessageList, chatMessage, currentMessage] as MessageInfo[]
		// AgentDetailUtils.checkConversationActive(newMessageList, this.data)
		this.data.isConversationActive.value = true
		this.data.messageList.value = newMessageList
		
		// 发送消息
		const params: ConversationChatParams = {
			conversationId: this.data.conversationId.value,
			variableParams,
			message: messageInfo,
			attachments,
			debug: false,
			selectedComponents,
		}
		this.handleConversation(params, currentMessageId)
	}

	// 根据用户消息更新会话主题
	const handleUpdateTopic = async (conversationId: string, messageInfo: string): Promise<void> => {
		const params: AgentConversationUpdateParams = {
			id: conversationId,
			firstMessage: messageInfo,
		}
		
		const {code, data: responseData, message} = await apiAgentConversationUpdate(params)
		if (code === SUCCESS_CODE) {
			this.data.needUpdateTopicRef.value = false
			// 更新会话主题
			this.data.conversationInfo.value = {
				...this.data.conversationInfo.value,
				topic: responseData?.topic,
			}
		} else {
			uni.showToast({
				title: message,
				icon: 'none',
				type: 'error'
			})
		}
	}

	/**
	 * 创建新会话
	 */
	async createNewConversation(): Promise<void> {
		if (!this.data.agentId.value) {
			uni.showToast({
				title: '智能体id不存在',
				icon: 'none',
				type: 'error'
			})
			return
		}
		
		this.data.messageList.value = []
		// 创建新会话后，需要更新会话主题
		this.data.needUpdateTopicRef.value = true
		
		const conversationParams: ConversationCreateParams = {
			agentId: this.data.agentId.value,
			devMode: false, // 开发模式, 只有智能体编排页才会设置为true	
		}
		
		const { code, data: responseData, message } = await apiAgentConversationCreate(conversationParams)
		if (code === SUCCESS_CODE && responseData && responseData.id) {
			this.data.conversationId.value = responseData.id

			// #ifdef WEB || H5
			// 修改rul参数且不刷新页面
			const url = new URL(location.href);
			url.hash = `/pages/agent-detail/agent-detail?id=${this.data.agentId.value}&conversationId=${responseData.id}`; // 修改参数
			history.replaceState(null, '', url.toString()); // 替换当前历史记录
			// #endif

			// #ifdef MP-WEIXIN
			uni.reLaunch({
				url: `/pages/agent-detail/agent-detail?id=${this.data.agentId.value}&conversationId=${responseData.id}`
			})
			// #endif
		} else {
			uni.showToast({
				title: message,
				icon: 'none',
				type: 'error'
			})
		}
	}

	/**
	 * 获取基本信息
	 * @param withConversationId 是否初始化会话id，默认false
	 * @param messageInfo 消息信息，默认''
	 * @param files 文件信息，默认[]
	 */
	async getPublishedAgentInfo(withConversationId: boolean = false, params: {
		messageInfo?: string,
		files?: UploadFileInfo[],
		selectedComponents?: AgentSelectedComponentInfo[]
	}): Promise<void> {
		const { code, data: responseData, message } = await apiPublishedAgentInfo(this.data.agentId.value, withConversationId)
		if (code === SUCCESS_CODE) {
			this.data.agentInfo.value = responseData
			if(withConversationId){
				const { messageInfo, files } = params
				this.data.conversationId.value = responseData.conversationId
				// 如果存在消息或文件，则发送消息
				if (messageInfo && messageInfo.trim() || files?.length > 0) {
					// 初始化会话时，发送消息
					this.handleSendMessage(params)
				}
			}
		} else {
			uni.showToast({
				title: message,
				icon: 'none',
				type: 'error'
			})
		}
	}

	/**
	 * 收藏/取消收藏
	 */
	async handleCollect(): Promise<void> {
		if (!this.data.agentInfo.value) return
		
		if (this.data.agentInfo.value.collect) {
			const { code } = await apiUnCollectAgent(this.data.agentInfo.value.agentId)
			if (code === SUCCESS_CODE) {
				uni.showToast({
					title: '已取消收藏',
					icon: 'success',
					duration: 2000
				})
				this.data.agentInfo.value.collect = false
			}
		} else {
			const { code } = await apiCollectAgent(this.data.agentInfo.value.agentId)
			if (code === SUCCESS_CODE) {
				uni.showToast({
					title: '已添加到收藏',
					icon: 'success',
					duration: 2000
				})
				this.data.agentInfo.value.collect = true
			}
		}
	}
}
