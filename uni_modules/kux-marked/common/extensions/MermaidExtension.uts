import { TokenizerExtension, MermaidToken } from '../../utssdk/ExtensionTokens.interface';
import { NodesToken } from '../../utssdk/Tokens.interface';
import { I_Lexer } from '../../utssdk/Lexer.interface';

/**
 * Mermaid图表扩展实现
 * 支持各种类型的Mermaid图表解析
 */

/**
 * 检测Mermaid图表类型
 * @param content Mermaid图表内容
 * @returns 图表类型
 */
function detectMermaidType(content: string): string {
	const firstLine = content.split('\n')[0].trim().toLowerCase();
	
	if (firstLine.startsWith('graph') || firstLine.startsWith('flowchart')) {
		return 'flowchart';
	}
	if (firstLine.startsWith('sequencediagram')) {
		return 'sequence';
	}
	if (firstLine.startsWith('classdiagram')) {
		return 'class';
	}
	if (firstLine.startsWith('gantt')) {
		return 'gantt';
	}
	if (firstLine.startsWith('pie')) {
		return 'pie';
	}
	if (firstLine.startsWith('gitgraph')) {
		return 'gitgraph';
	}
	if (firstLine.startsWith('erdiagram')) {
		return 'er';
	}
	if (firstLine.startsWith('journey')) {
		return 'journey';
	}
	if (firstLine.startsWith('statediagram')) {
		return 'state';
	}
	if (firstLine.startsWith('requirementdiagram')) {
		return 'requirement';
	}
	if (firstLine.startsWith('c4context') || firstLine.startsWith('c4container') || firstLine.startsWith('c4component')) {
		return 'c4';
	}
	if (firstLine.startsWith('mindmap')) {
		return 'mindmap';
	}
	if (firstLine.startsWith('timeline')) {
		return 'timeline';
	}
	
	return 'unknown';
}

/**
 * 验证Mermaid图表语法
 * @param content Mermaid图表内容
 * @returns 是否为有效的Mermaid语法
 */
function validateMermaidSyntax(content: string): boolean {
	if (!content || content.trim().length === 0) {
		return false;
	}
	
	const lines = content.split('\n').filter(line => line.trim().length > 0);
	if (lines.length === 0) {
		return false;
	}
	
	const firstLine = lines[0].trim().toLowerCase();
	
	// 检查是否包含已知的Mermaid图表类型
	const knownTypes = [
		'graph', 'flowchart', 'sequencediagram', 'classdiagram', 
		'gantt', 'pie', 'gitgraph', 'erdiagram', 'journey', 
		'statediagram', 'requirementdiagram', 'c4context', 
		'c4container', 'c4component', 'mindmap', 'timeline'
	];
	
	return knownTypes.some(type => firstLine.startsWith(type));
}

/**
 * Mermaid图表扩展
 */
export const mermaidExtension: TokenizerExtension = {
	name: 'mermaid',
	level: 'block',
	priority: 80,
	tokenizer: (lexer: I_Lexer, src: string, tokens: NodesToken[]): NodesToken | null => {
		// 匹配 ```mermaid 代码块
		const mermaidMatch = /^```mermaid\n([\s\S]*?)\n```(?:\n|$)/.exec(src);
		if (mermaidMatch && mermaidMatch.length > 1) {
			const content = mermaidMatch[1].trim();
			
			// 验证Mermaid语法
			if (!validateMermaidSyntax(content)) {
				return null;
			}
			
			return {
				type: 'mermaid',
				raw: mermaidMatch[0],
				text: content,
				lang: 'mermaid',
				diagramType: detectMermaidType(content),
				tokens: [] as NodesToken[]
			} as MermaidToken;
		}
		
		// 也支持带有空格的语法
		const mermaidSpaceMatch = /^``` mermaid\n([\s\S]*?)\n```(?:\n|$)/.exec(src);
		if (mermaidSpaceMatch && mermaidSpaceMatch.length > 1) {
			const content = mermaidSpaceMatch[1].trim();
			
			// 验证Mermaid语法
			if (!validateMermaidSyntax(content)) {
				return null;
			}
			
			return {
				type: 'mermaid',
				raw: mermaidSpaceMatch[0],
				text: content,
				lang: 'mermaid',
				diagramType: detectMermaidType(content),
				tokens: [] as NodesToken[]
			} as MermaidToken;
		}
		
		return null;
	}
};

/**
 * 获取Mermaid扩展
 * @returns Mermaid扩展
 */
export function getMermaidExtension(): TokenizerExtension {
	return mermaidExtension;
}

/**
 * 检测文本是否包含Mermaid图表
 * @param text 要检测的文本
 * @returns 是否包含Mermaid图表
 */
export function hasMermaidDiagram(text: string): boolean {
	const mermaidPattern = /```\s*mermaid\n[\s\S]*?\n```/i;
	return mermaidPattern.test(text);
}

/**
 * 提取文本中的所有Mermaid图表
 * @param text 源文本
 * @returns Mermaid图表数组
 */
export function extractMermaidDiagrams(text: string): Array<{ content: string; type: string; raw: string }> {
	const diagrams: Array<{ content: string; type: string; raw: string }> = [];
	
	// 匹配所有Mermaid代码块
	const mermaidMatches = text.match(/```\s*mermaid\n([\s\S]*?)\n```/gi);
	if (mermaidMatches) {
		mermaidMatches.forEach(match => {
			const contentMatch = /```\s*mermaid\n([\s\S]*?)\n```/i.exec(match);
			if (contentMatch && contentMatch.length > 1) {
				const content = contentMatch[1].trim();
				if (validateMermaidSyntax(content)) {
					diagrams.push({
						content,
						type: detectMermaidType(content),
						raw: match
					});
				}
			}
		});
	}
	
	return diagrams;
}

/**
 * 获取支持的Mermaid图表类型列表
 * @returns 支持的图表类型数组
 */
export function getSupportedMermaidTypes(): Array<{ type: string; name: string; description: string }> {
	return [
		{ type: 'flowchart', name: '流程图', description: '用于显示流程和决策流程' },
		{ type: 'sequence', name: '时序图', description: '显示参与者之间的交互顺序' },
		{ type: 'class', name: '类图', description: '显示类之间的关系' },
		{ type: 'gantt', name: '甘特图', description: '项目计划和进度管理' },
		{ type: 'pie', name: '饼图', description: '显示数据的比例分布' },
		{ type: 'gitgraph', name: 'Git图', description: '显示Git分支和提交历史' },
		{ type: 'er', name: '实体关系图', description: '数据库设计和实体关系' },
		{ type: 'journey', name: '用户旅程图', description: '用户体验和交互流程' },
		{ type: 'state', name: '状态图', description: '系统状态和状态转换' },
		{ type: 'requirement', name: '需求图', description: '需求分析和依赖关系' },
		{ type: 'c4', name: 'C4图', description: '软件架构图' },
		{ type: 'mindmap', name: '思维导图', description: '概念和想法的可视化' },
		{ type: 'timeline', name: '时间线', description: '事件的时间顺序' }
	];
}