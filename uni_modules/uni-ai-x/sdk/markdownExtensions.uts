/**
 * Markdown 扩展功能集合
 * 支持数学公式、Mermaid图表、自定义区块等扩展
 * 已重构：集成统一的 marked-katex 数学公式解析
 */

import { TokenizerExtension, NodesToken, TokenizerThis } from '@/uni_modules/kux-marked';
import { MathToken, isMathToken, isMathTokenClosed, handleStreamingMath } from './marked-katex.uts';

// 重新导出数学公式相关类型和函数
// export { MathToken, isMathToken, isMathTokenClosed, handleStreamingMath };

// Mermaid 图表 Token 类型定义
export interface MermaidToken extends NodesToken {
  type: 'mermaid';
  raw: string;
  text: string;
  chartType?: string;
  code: string;
}

// 自定义区块 Token 类型定义
export interface CustomBlockToken extends NodesToken {
  type: 'customBlock';
  raw: string;
  text: string;
  blockType: string;
  content: string;
  attributes?: Record<string, string>;
}

/**
 * 数学公式扩展 - 行内公式
 * 参考 Tokenizer.uts 的实现方式
 */
export const mathInlineExtension: TokenizerExtension = {
  name: 'mathInline',
  level: 'inline',
  tokenizer: function(lexerThis: TokenizerThis, src: string, tokens: NodesToken[]): NodesToken | null {
    // 检查是否在代码区域内
    if (tokens && tokens.length > 0) {
      const lastToken = tokens[tokens.length - 1]
      if (lastToken && (lastToken.type === 'codespan' || lastToken.type === 'code')) {
        return null
      }
    }

    // 处理转义的 \$ → $
    const escapeMatch = /^\\\$/.exec(src)
    if (escapeMatch) {
      return {
        type: 'text',
        raw: escapeMatch[0],
        text: '$',
        tokens: [] as NodesToken[]
      } as NodesToken
    }

    // 行内公式：$...$，避免 $100 误判
    const inlineDollarMatch = /^\$([^\$\n]+?)\$/.exec(src)
    if (inlineDollarMatch) {
      const beforeChar = src.length > 0 ? src[0 - 1] || ' ' : ' '
      const afterChar = src[inlineDollarMatch[0].length] || ' '
      
      // 前后不能是数字或字母，避免 $100 这样的金额被误判
      if (!/[0-9A-Za-z]/.test(beforeChar) && !/[0-9A-Za-z]/.test(afterChar)) {
        return {
          type: 'math',
          raw: inlineDollarMatch[0],
          text: inlineDollarMatch[1].trim(),
          display: false,
          mathType: 'inline',
          tokens: [] as NodesToken[],
          uniqueId: '',
          isClose: true
        } as MathToken
      }
    }

    // LaTeX 行内公式：\(...\)
    const inlineParenMatch = /^\\\(((?:\\.|[^\)])+?)\\\)/.exec(src)
    if (inlineParenMatch) {
      return {
        type: 'math',
        raw: inlineParenMatch[0],
        text: inlineParenMatch[1].trim(),
        display: false,
        mathType: 'inline',
        tokens: [] as NodesToken[],
        uniqueId: '',
        isClose: true
      } as MathToken
    }

    // 流式解析：未闭合的行内公式 $...
    const openInlineDollarMatch = /^\$([^\$\n]*?)$/.exec(src)
    if (openInlineDollarMatch && !src.includes('$', 1)) {
      const beforeChar = src.length > 0 ? src[0 - 1] || ' ' : ' '
      if (!/[0-9A-Za-z]/.test(beforeChar)) {
        return {
          type: 'math',
          raw: openInlineDollarMatch[0],
          text: openInlineDollarMatch[1].trim(),
          display: false,
          mathType: 'inline',
          tokens: [] as NodesToken[],
          uniqueId: '',
          isClose: false
        } as MathToken
      }
    }

    // 流式解析：未闭合的 LaTeX 行内公式 \(...
    const openInlineParenMatch = /^\\\(([^)]*?)$/.exec(src)
    if (openInlineParenMatch && !src.includes('\\)')) {
      return {
        type: 'math',
        raw: openInlineParenMatch[0],
        text: openInlineParenMatch[1].trim(),
        display: false,
        mathType: 'inline',
        tokens: [] as NodesToken[],
        uniqueId: '',
        isClose: false
      } as MathToken
    }

    return null
  }
};

/**
 * 数学公式扩展 - 块级公式
 * 参考 Tokenizer.uts 的实现方式
 */
export const mathBlockExtension: TokenizerExtension = {
  name: 'mathBlock',
  level: 'block',
  tokenizer: function(lexerThis: TokenizerThis, src: string, tokens: NodesToken[]): NodesToken | null {
    // 块级公式：$$...$$
    const blockDollarMatch = /^\$\$([\s\S]+?)\$\$/.exec(src)
    if (blockDollarMatch) {
      return {
        type: 'math',
        raw: blockDollarMatch[0],
        text: blockDollarMatch[1].trim(),
        display: true,
        mathType: 'block',
        tokens: [] as NodesToken[],
        uniqueId: '',
        isClose: true
      } as MathToken
    }

    // LaTeX 块级公式：\[...\]
    const blockParenMatch = /^\\\[((?:\\.|[^\]])+?)\\\]/.exec(src)
    if (blockParenMatch) {
      return {
        type: 'math',
        raw: blockParenMatch[0],
        text: blockParenMatch[1].trim(),
        display: true,
        mathType: 'block',
        tokens: [] as NodesToken[],
        uniqueId: '',
        isClose: true
      } as MathToken
    }

    // 流式解析：未闭合的块级公式 $$...
    const openBlockDollarMatch = /^\$\$([\s\S]*?)$/.exec(src)
    if (openBlockDollarMatch && !src.includes('$$', 2)) {
      return {
        type: 'math',
        raw: openBlockDollarMatch[0],
        text: openBlockDollarMatch[1].trim(),
        display: true,
        mathType: 'block',
        tokens: [] as NodesToken[],
        uniqueId: '',
        isClose: false
      } as MathToken
    }

    // 流式解析：未闭合的 LaTeX 块级公式 \[...
    const openBlockParenMatch = /^\\\[([\s\S]*?)$/.exec(src)
    if (openBlockParenMatch && !src.includes('\\]')) {
      return {
        type: 'math',
        raw: openBlockParenMatch[0],
        text: openBlockParenMatch[1].trim(),
        display: true,
        mathType: 'block',
        tokens: [] as NodesToken[],
        uniqueId: '',
        isClose: false
      } as MathToken
    }

    return null
  }
};

/**
 * Mermaid 图表扩展
 * 支持 ```mermaid...``` 语法
 */
export const mermaidExtension: TokenizerExtension = {
  name: 'mermaid',
  level: 'block',
  tokenizer: function(lexerThis: TokenizerThis, src: string, tokens: NodesToken[]): NodesToken | null {
    // 匹配 Mermaid 代码块
    const mermaidMatch = src.match(/^```mermaid\n([\s\S]+?)\n```/);
    if (mermaidMatch) {
      const code = mermaidMatch[1].trim();
      // 识别图表类型
      let chartType = 'graph';
      if (code.includes('sequenceDiagram')) {
        chartType = 'sequence';
      } else if (code.includes('gantt')) {
        chartType = 'gantt';
      } else if (code.includes('pie')) {
        chartType = 'pie';
      } else if (code.includes('flowchart')) {
        chartType = 'flowchart';
      }
      
      return {
        type: 'mermaid',
        raw: mermaidMatch[0],
        text: code,
        chartType: chartType,
        code: code,
        tokens: [],
        uniqueId: '', // 将在 parseMarkdown 中设置
        isClose: true
      } as MermaidToken;
    }
    
    // 支持未闭合的 Mermaid 代码块（流式解析）
    const openMermaidMatch = src.match(/^```mermaid\n([\s\S]*)$/);
    if (openMermaidMatch && !src.includes('```', 11)) {
      const code = openMermaidMatch[1].trim();
      let chartType = 'graph';
      if (code.includes('sequenceDiagram')) {
        chartType = 'sequence';
      } else if (code.includes('gantt')) {
        chartType = 'gantt';
      } else if (code.includes('pie')) {
        chartType = 'pie';
      } else if (code.includes('flowchart')) {
        chartType = 'flowchart';
      }
      
      return {
        type: 'mermaid',
        raw: openMermaidMatch[0],
        text: code,
        chartType: chartType,
        code: code,
        tokens: [],
        uniqueId: '', // 将在 parseMarkdown 中设置
        isClose: false // 未闭合
      } as MermaidToken;
    }
    
    return null;
  }
};

/**
 * 自定义区块扩展
 * 支持 :::type...:::  语法
 */
export const customBlockExtension: TokenizerExtension = {
  name: 'customBlock',
  level: 'block',
  tokenizer: function(lexerThis: TokenizerThis, src: string, tokens: NodesToken[]): NodesToken | null {
    // 匹配自定义区块 :::type [attributes]\n content \n:::
    const customBlockMatch = src.match(/^:::(\w+)(\s+[^\n]*)?\n([\s\S]+?)\n:::/);
    if (customBlockMatch) {
      const blockType = customBlockMatch[1];
      const attributesStr = customBlockMatch[2]?.trim() || '';
      const content = customBlockMatch[3].trim();
      
      // 解析属性
      const attributes: Record<string, string> = {};
      if (attributesStr) {
        const attrMatches = attributesStr.matchAll(/(\w+)=["']?([^"'\s]+)["']?/g);
        for (const match of attrMatches) {
          attributes[match[1]] = match[2];
        }
      }
      
      return {
        type: 'customBlock',
        raw: customBlockMatch[0],
        text: content,
        blockType: blockType,
        content: content,
        attributes: attributes,
        tokens: [],
        uniqueId: '', // 将在 parseMarkdown 中设置
        isClose: true
      } as CustomBlockToken;
    }
    
    // 支持未闭合的自定义区块（流式解析）
    const openCustomBlockMatch = src.match(/^:::(\w+)(\s+[^\n]*)?\n([\s\S]*)$/);
    if (openCustomBlockMatch && !src.includes(':::', 3)) {
      const blockType = openCustomBlockMatch[1];
      const attributesStr = openCustomBlockMatch[2]?.trim() || '';
      const content = openCustomBlockMatch[3].trim();
      
      // 解析属性
      const attributes: Record<string, string> = {};
      if (attributesStr) {
        const attrMatches = attributesStr.matchAll(/(\w+)=["']?([^"'\s]+)["']?/g);
        for (const match of attrMatches) {
          attributes[match[1]] = match[2];
        }
      }
      
      return {
        type: 'customBlock',
        raw: openCustomBlockMatch[0],
        text: content,
        blockType: blockType,
        content: content,
        attributes: attributes,
        tokens: [],
        uniqueId: '', // 将在 parseMarkdown 中设置
        isClose: false // 未闭合
      } as CustomBlockToken;
    }
    
    return null;
  }
};

/**
 * 扩展验证函数
 * 验证 Token 是否闭合
 */
export function isExtensionTokenClosed(token: NodesToken, markdownText: string): boolean {
  switch (token.type) {
    case 'math':
      const mathToken = token as MathToken;
      // 使用统一的数学公式闭合检查
      return isMathTokenClosed(mathToken, markdownText);
      
    case 'mermaid':
      // Mermaid 需要闭合的 ```
      return markdownText.includes('```mermaid') && markdownText.indexOf('```', 11) !== -1;
      
    case 'customBlock':
      const customToken = token as CustomBlockToken;
      // 自定义区块需要闭合的 :::
      return markdownText.includes(`:::${customToken.blockType}`) && markdownText.indexOf(':::', 3) !== -1;
      
    default:
      return false;
  }
}

/**
 * 扩展类型检查函数
 */
export function isExtensionToken(token: NodesToken): boolean {
  return ['math', 'mermaid', 'customBlock'].includes(token.type);
}

/**
 * 获取所有扩展
 */
export function getAllExtensions() {
  return {
    block: [mathBlockExtension.tokenizer, mermaidExtension.tokenizer, customBlockExtension.tokenizer],
    inline: [mathInlineExtension.tokenizer]
  };
}
