<template>
	<view class="agent-detail-container">
		<!-- 导航栏 -->
		<custom-nav-bar :title="agentName" show-back :icon="agentInfo?.icon">
			<template v-slot:right>
				<view class="right-buttons">
					<uni-icons class="iconfont icon-More" size="50rpx" @tap="handleMorePopup"></uni-icons>
					<uni-icons class="iconfont icon-message-add" size="50rpx" @tap="createNewConversation"></uni-icons>
				</view> 
			</template>
		</custom-nav-bar>
		<view class="chat-container">
			<!-- 聊天内容 -->
			<view class="scroll-view-box">
				<scroll-view 
					direction="vertical"
					class="msg-list" 
					:scroll-into-view="scrollIntoView"
					id="msg-list"
					:scroll-with-animation="scrollWithAnimation"
					@scroll="onScroll"
					@touchstart="scrollTouch = true"
					@touchend="scrollTouch = false"
				>
					<template v-for="item in messageList" :key="item.id">
						<uni-ai-x-msg 
							v-if="item.messageType === MessageTypeEnum.ASSISTANT" 
							:msg="convertMessageInfoToMsgItem(item)" 
							@longpress="onlongTapMsg(convertMessageInfoToMsgItem(item))" 
							@changeThinkContent="changeThinkContent" 
							:id="'msg-item-' + item.id"
							:ref="(el) => setMessageRef(el, item.id)"
						></uni-ai-x-msg>
						<text v-else class="user-msg" @longpress="onlongTapMsg(convertMessageInfoToMsgItem(item))">{{item.text}}</text>
					</template>
					<!-- 内容 -->
					<view class="content" v-if="messageList?.length == 0">
						<!-- 头部区域 -->
						<view class="title-section">
							<text class="subtitle">{{agentInfo?.description}}</text>
						</view>
						<!-- 功能按钮区域 -->
						<button-wrapper :buttons="agentInfo?.openingGuidQuestions || []" @button-click="handleButtonClick" />
					</view>
					<!-- 最后一项，用于快速滚动到最底部 -->
					<view style="height: 35px;" id="last-msg"></view>
				</scroll-view>
				<!-- <add-chat-btn :style="{visibility: scrollInBottom && state != 'processing' ? 'visible' : 'hidden'}" class="add-chat-btn" /> -->
				<!-- 滚动到最底部 -->
				<view :style="{visibility: scrollInBottom || scrolling ? 'hidden' : 'visible'}" class="scroll-to-bottom" @click="scrollToLastMsg(true)">
					<uni-icons type="down" size="20" color="#555"></uni-icons>
				</view>
			</view>
			<!-- 输入框 -->
			<chat-input-phone
				:manual-components="agentInfo?.manualComponents || []"
				@onSendMessage="handleSendMessage"
			/>
		</view>
		<more-popup ref="refMorePopup" :agent-info="agentInfo" @collect="handleCollect"/>
	</view>
</template>

<script setup lang="uts">
	import { apiPublishedAgentInfo,apiCollectAgent,apiUnCollectAgent } from '@/servers/agentDev'
	import type {
		AgentDetailDto,
		AgentBaseInfo,
	} from '@/types/interfaces/agent';
	import MorePopup from '@/pages/agent-detail/components/more-popup/more-popup.uvue'
	import uniAiXMsg from '@/uni_modules/uni-ai-x/components/uni-ai-x-msg/uni-ai-x-msg.uvue'

	import { chatService } from '@/utils/chatService'
  // 导入SSE数据处理器
  import { createSSEProcessor, SSEChunk } from '@/utils/sseDataProcessor'
  // 导入Markdown解析器
  import ParseMarkdown from '@/uni_modules/uni-ai-x/sdk/parseMarkdown.uts'
  // 导入Markdown相关类型和解析器
  import { useMarked, NodesToken as MarkdownToken } from '@/uni_modules/kux-marked'
  // 导入treeToList工具
  import treeToListSdk from '@/uni_modules/uni-ai-x/sdk/treeToList.uts'
  // 导入会话相关API和类型
  import { apiAgentConversationCreate } from '@/servers/conversation.uts'
  import { ConversationCreateParams } from '@/types/interfaces/conversationInfo.uts'
  import ChatInputPhone from '@/components/chat-input-phone/chat-input-phone.uvue'
  import { AgentManualComponentInfo, AgentSelectedComponentInfo } from '@/types/interfaces/agent.uts'
	import { BindConfigWithSub, UploadFileInfo } from '@/types/interfaces/common'
	import { MessageStatusEnum, ProcessingEnum } from '@/types/enums/common'
	import { OpenCloseEnum } from '@/types/enums/space'
	import { RequestResponse } from '@/types/interfaces/request'
	import { MessageModeEnum, ConversationEventTypeEnum, AssistantRoleEnum, MessageTypeEnum } from '@/types/enums/agent'
	import { ConversationInfo, MessageInfo, ConversationChatParams, ConversationChatSuggestParams, ConversationChatResponse, ProcessingInfo, MessageQuestionExtInfo, AttachmentFile } from '@/types/interfaces/conversationInfo'
	import { TempChatCompletionsParams } from '@/types/interfaces/tempChat'
	import { apiAgentConversationChatSuggest } from '@/servers/conversation'
	import { ACCESS_TOKEN } from '@/constants/home.constants'
	import { SUCCESS_CODE } from '@/constants/codes.constants'
	import { v4 as uuidv4 } from 'uuid'
	import { MarkdownElement } from '@/types/interfaces/chat'
	import { apiAgentConversation } from '@/servers/conversation.uts'

	// 导入需要的类型
	import {MsgItem, markdownElItem} from '@/uni_modules/uni-ai-x/sdk/'

	  // 初始化useMarked实例（备用方案）
  const marked = useMarked()

	// 会话id
	const conversationId = ref<number | null>(null)
	// 智能体id
	const agentId = ref<number | null>(null)
	// 智能体名称
	const agentName = ref<string>('')
	// 智能体信息
	const agentInfo = ref<AgentDetailDto | null>(null)
	// 更多弹窗
	const refMorePopup = ref<any>(null)

	// 消息列表现在直接使用messageList进行渲染

	// 根据datasList内容动态确定type类型
	const determineTypeFromData = (dataList: MarkdownToken[][]): string => {
		if (!dataList || dataList.length === 0) return 'text';
		
		// 检查第一个token的类型
		const firstToken = dataList[0]?.[0];
		if (firstToken) {
			// 根据token类型返回对应的type
			switch (firstToken.type) {
				case 'code':
					return 'code';
				case 'table':
					return 'table';
				case 'list':
					return 'list';
				case 'heading':
					return 'heading';
				case 'blockquote':
					return 'quote';
				case 'hr':
					return 'divider';
				default:
					return 'text';
			}
		}
		return 'text';
	};

	// 生成唯一的uniqueId
	const generateUniqueId = (): string => {
		const timestamp = Date.now();
		const random = Math.random().toString(36).substring(2, 15);
		return `markdown_${timestamp}_${random}`;
	};

	// 使用uni-ai-x的ParseMarkdown类进行解析
	let parseMarkdownInstance: ParseMarkdown | null = null

	const keyboardHeight = ref<number>(0)
	const scrollIntoView = ref<string>('')
	const scrollInBottom = ref<boolean>(true)
	const scrollWithAnimation = ref<boolean>(false)
	const scrollTouch = ref<boolean>(false)
	const scrolling = ref<boolean>(false)
	let autoToLastMsg = false
	let scrollingT = 0
	let mouseScroll = false
	let needSetLockAutoToLastMsg = true

	// 会话信息
	const conversationInfo = ref<ConversationInfo | null>(null)
  // 会话消息ID
  const currentConversationRequestId = ref<string>('')
  // 是否用户问题建议
  const isSuggest = ref<boolean>(false)
  // 会话信息
  const messageList = ref<MessageInfo[]>([])
  // 会话问题建议
  const chatSuggestList = ref<string[]>([])
  // 会话请求ID
  const requestId = ref<string>('')
  // 会话消息ID
  const messageIdRef = ref<string>('')
  // 是否需要更新主题
  const needUpdateTopicRef = ref<boolean>(true)
  // 是否正在加载会话
  const isLoadingConversation = ref<boolean>(false)
  // 会话是否正在进行中（有消息正在处理）
  const isConversationActive = ref<boolean>(false)
  // 是否显示点击下滚按钮
  // const showScrollBtn = ref<boolean>(false)
  // 可手动选择的组件列表
  const manualComponents = ref<AgentManualComponentInfo[]>([])
  // 变量参数
  const variables = ref<BindConfigWithSub[]>([])
  // 用户填写的变量参数
  const userFillVariables = ref<{ [key: string]: string | number }>(null)
  // 必填变量参数name列表
  const requiredNameList = ref<string[]>([])
  // 处理中的消息列表
  const processingList = ref<ProcessingInfo[]>([])
  // SSE数据处理器
  let sseProcessor: any = null
	// 最后接收的SSE数据，用于调试
	const lastSSEData = ref<string>('')
  
  // 初始化ParseMarkdown实例
  const initParseMarkdown = () => {
    if (!parseMarkdownInstance) {
      parseMarkdownInstance = new ParseMarkdown((markdownTokenList: MarkdownToken[]) => {
        // 将MarkdownToken转换为markdownElItem
        const markdownElList = (markdownTokenList as any[]).map((token: any) => {
          return {
            uniqueId: token.uniqueId || `token_${Date.now()}_${Math.random()}`,
            type: token.type || 'text',
            datasList: treeToListSdk.markTreeToList(token)
          }
        });
        
        // 更新最新AI消息的markdownElList
        if (messageList.value.length > 0) {
          const lastMsg = messageList.value[messageList.value.length - 1];
          if (lastMsg.messageType === MessageTypeEnum.ASSISTANT) {
            lastMsg.markdownElList = markdownElList;
            // 强制触发响应式更新
            messageList.value = [...messageList.value];
          }
        }
      });
    }
  };

	onLoad(async (params) => {
		// 智能体id
		agentId.value = Number(params.id) || ''
		agentName.value = params.name || ''
		// 消息信息
		const messageInfo = params.messageInfo ? decodeURIComponent(params.messageInfo) : ''
		// 文件信息
		const files = params.files ? JSON.parse(decodeURIComponent(params.files)) : []

		initParseMarkdown()
    // 如果会话id存在，则初始化ParseMarkdown，查询历史会话信息
		if (params.conversationId) {
			const id = Number(params.conversationId)
			// 会话id
			conversationId.value = id
			// 查询历史会话信息
			const res = await apiAgentConversation(id)
			if(res.code === SUCCESS_CODE){
				handleQueryConversation(res)
			}
			// 查询智能体详情信息
			getPublishedAgentInfo()
		} else {
			// 查询智能体详情信息，并初始化会话id
			getPublishedAgentInfo(true, messageInfo, files)
		}
	})

	// 使用uni-ai-x解析器的函数
	const parseMarkdownToElList = (text: string, msgId: string): any[] => {
    if (!text || text.trim().length === 0) {
      return [];
    }
    
    // 确保ParseMarkdown实例已初始化
    if (!parseMarkdownInstance) {
      initParseMarkdown();
    }
    
    // 使用ParseMarkdown解析
    parseMarkdownInstance!.runTask(text);
    
    // 返回空数组，因为结果会通过回调异步更新
    return [];
  };

	// 创建新会话
	const createNewConversation= async () => {
		if(!agentId.value){
			uni.showToast({
				title: '智能体id不存在',
				icon: 'none',
				type: 'error'
			})
			return;
		}
		messageList.value = [];
		// 创建会话
		const conversationParams: ConversationCreateParams = {
			agentId: agentId.value,
			devMode: true
		};
		
		const { code, data, message } = await apiAgentConversationCreate(conversationParams);
		
		if (code === SUCCESS_CODE && data && data.id) {
			conversationId.value = data.id;
		} else {
			uni.showToast({
				title: message,
				icon: 'none',
				type: 'error'
			})
		}
	}

	// 处理变量参数
	const handleVariables = (_variables: BindConfigWithSub[]) => {
    variables.value = _variables;
    // 必填参数name列表
    const _requiredNameList = _variables
      ?.filter(
        (item: BindConfigWithSub) => !item.systemVariable && item.require,
      )
      ?.map((item: BindConfigWithSub) => item.name);
    requiredNameList.value = _requiredNameList || [];
  };

	// 检查会话是否正在进行中（有消息正在处理）
	const checkConversationActive = (messages: MessageInfo[]) => {
    const hasActiveMessage =
      (messages?.length &&
        messages.some(
          (message) =>
            message.status === MessageStatusEnum.Loading ||
            message.status === MessageStatusEnum.Incomplete,
        )) ||
      false;
    isConversationActive.value = hasActiveMessage;
  };

  // 处理查询会话
  const handleQueryConversation = (result: RequestResponse<ConversationInfo>) => {
    isLoadingConversation.value = true;
    const { data } = result;
    conversationInfo.value = data as unknown as ConversationInfo;
    // 是否开启用户问题建议
    isSuggest.value = data?.agent?.openSuggest === OpenCloseEnum.Open;
    // 可手动选择的组件列表
    manualComponents.value = data?.agent?.manualComponents || [];
    // 变量参数
    const _variables = data?.agent?.variables || [];
    // 处理变量参数
    handleVariables(_variables);
    // 用户填写的变量参数
    userFillVariables.value = data?.variables as any;
    // 消息列表
    const _messageList = data?.messageList || [];
    const len = _messageList?.length || 0;
    if (len) {
      // 为没有markdownElList的消息生成markdownElList
      const processedMessageList = _messageList.map((message: MessageInfo) => {
        if (!message.markdownElList && message.text) {
          			const markdownElements: MarkdownToken[] = (marked.lexer(message.text, null) as TokensList).tokens as MarkdownToken[];
			const datasList: MarkdownToken[][] = treeToListSdk.markTreeToList(markdownElements[0]);
          
          const markdownElList: markdownElItem[] = [{
            uniqueId: generateUniqueId(),
            type: determineTypeFromData(datasList),
            datasList,
          }];
          return {
            ...message,
            markdownElList
          };
        }
        return message;
      });
      messageList.value = processedMessageList;
      // 检查会话状态
      checkConversationActive(processedMessageList);
      // 最后一条消息为"问答"时，获取问题建议
      const lastMessage = processedMessageList[len - 1];
      if (
        lastMessage.type === MessageModeEnum.QUESTION &&
        lastMessage.ext?.length
      ) {
        // 问题建议列表
        const suggestList = lastMessage.ext.map((item) => item.content) || [];
        chatSuggestList.value = suggestList;
      }
      // 如果消息列表大于1时，说明已开始会话，就不显示预置问题，反之显示
      else if (len === 1) {
        // 如果存在预置问题，显示预置问题
        chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
      }
    }
    // 不存在会话消息时，才显示开场白预置问题
    else {
      chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
    }

    // 使用 setTimeout 确保在 DOM 完全渲染后再滚动
    // setTimeout(() => {
    //   // 滚动到底部
    //   messageViewScrollToBottom();
    // }, 800);
  };

	const handleChatProcessingList = (_processingList: ProcessingInfo[]) => {
    //先清空
    // processingList.value = [];

    // 去重逻辑：保留一条，如果status状态不是 EXECUTING，如果成功或者失败都有就仅保留成功
    const processedMap = new Map<string, ProcessingInfo>();

    _processingList.forEach((item) => {
      const key = item.executeId || '';
      const existing = processedMap.get(key);

      if (!existing) {
        // 如果不存在，直接添加
        processedMap.set(key, item);
      } else {
        // 如果已存在，根据状态优先级决定保留哪一个
        // const shouldReplace = shouldReplaceProcessingItem(existing, item);
        // if (shouldReplace) {
        //   processedMap.set(key, item);
        // }
      }
    });

    const newProcessingList: ProcessingInfo[] = []
    processedMap.forEach((value) => {
      newProcessingList.push(value)
    })
    processingList.value = newProcessingList;
  };

  // 修改消息列表
  const handleChangeMessageList = async (
    res: ConversationChatResponse,
    // 自定义随机id
    currentMessageId: string,
  ) => {
    const { data, eventType } = res;
    currentConversationRequestId.value = res.requestId;
    if (!messageList.value?.length) {
      return [];
    }
    // timeoutRef.current = setTimeout(() => {
        // 深拷贝消息列表
        const list = [...messageList.value];
        const index = list.findIndex((item) => item.id === currentMessageId);
        // 数组splice方法的第二个参数表示删除的数量，这里我们只需要删除一个元素，所以设置为1， 如果为0，则表示不删除元素。
        let arraySpliceAction = 1;
        // 当前消息
        const currentMessage = list.find(
          (item) => item.id === currentMessageId,
        ) as MessageInfo;
        // 消息不存在时
        if (!currentMessage) {
          // return messageList.value;
					return;
        }

        let newMessage: MessageInfo | null = null;

        // 更新UI状态...
        if (eventType === ConversationEventTypeEnum.PROCESSING) {
          const processingResult = data.result || {};
          data.executeId = processingResult.executeId;
          newMessage = {
            ...currentMessage,
            // todo: 需要处理markdown
            // text: getCustomBlock(currentMessage.text || '', data),
						text: currentMessage.text || '',
            status: MessageStatusEnum.Loading,
            processingList: [
              ...(currentMessage?.processingList || []),
              data,
            ] as ProcessingInfo[],
          };

          handleChatProcessingList([
            ...(currentMessage?.processingList || []),
            { ...data },
          ] as ProcessingInfo[]);
        }
        // MESSAGE事件
        if (eventType === ConversationEventTypeEnum.MESSAGE) {
          const { text, type, ext, id, finished } = data;
          // 思考think
          if (type === MessageModeEnum.THINK) {
            newMessage = {
              ...currentMessage,
              think: `${currentMessage.think}${text}`,
              status: MessageStatusEnum.Incomplete,
            };
          }
          // 问答
          else if (type === MessageModeEnum.QUESTION) {
            // 先累加文本，然后重新解析完整的markdown
            const accumulatedText = `${currentMessage.text}${text}`;
            console.log('问答类型 - 累加后的完整文本:', accumulatedText);
            
            // 使用ParseMarkdown实例处理流式数据
            if (parseMarkdownInstance) {
              parseMarkdownInstance.runTask(accumulatedText);
              // 结果会通过回调函数异步更新，这里先使用临时数据
              const tempMarkdownElList: markdownElItem[] = [{
                uniqueId: generateUniqueId(),
                type: 'text',
                datasList: []
              }];
              newMessage = {
                ...currentMessage,
                text: accumulatedText,
                markdownElList: tempMarkdownElList,
                status: finished ? null : MessageStatusEnum.Incomplete,
              };
                          } else {
                // 备用方案：直接使用marked.lexer
                const markdownElements: MarkdownToken[] = (marked.lexer(accumulatedText, null) as TokensList).tokens as MarkdownToken[];
                const datasList: MarkdownToken[][] = treeToListSdk.markTreeToList(markdownElements[0]);
                const newMarkdownElList: markdownElItem[] = [{
                  uniqueId: generateUniqueId(),
                  type: determineTypeFromData(datasList),
                  datasList,
                }];
                newMessage = {
                  ...currentMessage,
                  text: accumulatedText,
                  markdownElList: newMarkdownElList,
                  status: finished ? null : MessageStatusEnum.Incomplete,
                };
              }
            if (ext?.length) {
              // 问题建议
              chatSuggestList.value = (
                ext.map((extItem: MessageQuestionExtInfo) => extItem.content) ||
                  [] as string[]
              );
            }
          } else {
            // 工作流过程输出
            if (
              (!messageIdRef.value || messageIdRef.value !== id) &&
              finished
            ) {
              // 先累加文本，然后重新解析完整的markdown
              const accumulatedText = `${currentMessage.text}${text}`;
              console.log('工作流输出 - 累加后的完整文本:', accumulatedText);
              
              // 使用ParseMarkdown实例处理流式数据
              if (parseMarkdownInstance) {
                parseMarkdownInstance.runTask(accumulatedText);
                // 结果会通过回调函数异步更新，这里先使用临时数据
                const tempMarkdownElList: markdownElItem[] = [{
                  uniqueId: generateUniqueId(),
                  type: 'text',
                  datasList: []
                }];
                newMessage = {
                  ...currentMessage,
                  id,
                  text: accumulatedText,
                  markdownElList: tempMarkdownElList,
                  status: null, // 隐藏运行状态
                };
              } else {
                // 备用方案：直接使用marked.lexer
                const markdownElements: MarkdownToken[] = (marked.lexer(accumulatedText, null) as TokensList).tokens as MarkdownToken[];
                const datasList: MarkdownToken[][] = treeToListSdk.markTreeToList(markdownElements[0]);
                const newMarkdownElList: markdownElItem[] = [{
                  uniqueId: generateUniqueId(),
                  type: determineTypeFromData(datasList),
                  datasList,
                }];
                newMessage = {
                  ...currentMessage,
                  id,
                  text: accumulatedText,
                  markdownElList: newMarkdownElList,
                  status: null, // 隐藏运行状态
                };
              }
              // 插入新的消息
              arraySpliceAction = 0;
            } else {
              messageIdRef.value = id;
              // 先累加文本，然后重新解析完整的markdown
              const accumulatedText = `${currentMessage.text}${text}`;
              console.log('工作流进行中 - 累加后的完整文本:', accumulatedText);
              
              // 使用ParseMarkdown实例处理流式数据
              if (parseMarkdownInstance) {
                parseMarkdownInstance.runTask(accumulatedText);
                // 结果会通过回调函数异步更新，这里先使用临时数据
                const tempMarkdownElList: markdownElItem[] = [{
                  uniqueId: generateUniqueId(),
                  type: 'text',
                  datasList: []
                }];
                newMessage = {
                  ...currentMessage,
                  text: accumulatedText,
                  markdownElList: tempMarkdownElList,
                  status: MessageStatusEnum.Incomplete,
                };
              } else {
                // 备用方案：直接使用marked.lexer
                const markdownElements: MarkdownToken[] = (marked.lexer(accumulatedText, null) as TokensList).tokens as MarkdownToken[];
                const datasList: MarkdownToken[][] = treeToListSdk.markTreeToList(markdownElements[0]);
                const newMarkdownElList: markdownElItem[] = [{
                  uniqueId: generateUniqueId(),
                  type: determineTypeFromData(datasList),
                  datasList,
                }];
                newMessage = {
                  ...currentMessage,
                  text: accumulatedText,
                  markdownElList: newMarkdownElList,
                  status: MessageStatusEnum.Incomplete,
                };
              }
            }
          }
        }
        // FINAL_RESULT事件
        if (eventType === ConversationEventTypeEnum.FINAL_RESULT) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Complete,
            finalResult: data,
            requestId: res.requestId,
          };

          // 调试结果
          requestId.value = res.requestId;
        }
        // ERROR事件
        if (eventType === ConversationEventTypeEnum.ERROR) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Error,
          };
        }

        // 会话事件兼容处理，防止消息为空时，页面渲染报length错误
        if (newMessage) {
          list.splice(index, arraySpliceAction, newMessage as MessageInfo);
        }

        // 检查会话状态
        checkConversationActive(list);

        messageList.value = list;
				console.log(list, '================list666666')
        
        // 使用优化更新方法，只更新需要更新的组件
        if (newMessage && newMessage.messageType === MessageTypeEnum.ASSISTANT) {
          await nextTick();
          // 尝试直接更新组件
          await updateMessageComponent(currentMessageId, {
            markdownElList: newMessage.markdownElList,
            text: newMessage.text,
            status: newMessage.status
          });
        }
    // }, 200);
  };

  // 会话处理
  const handleConversation = async (
    params: ConversationChatParams,
    currentMessageId: string,
    // 是否同步会话记录
    // isSync: boolean = true,
  ) => {
    try {
      // 初始化SSE处理器
      // if (!sseProcessor) {
      //   sseProcessor = createSSEProcessor('chat-' + params.conversationId)
      // }

      await chatService.sendMessage(
        params,
        // 处理流式数据
        (chunk: string) => {
          try {
            // 解析SSE数据
            const result = JSON.parse(chunk)
            
            // // 更新最后接收的SSE数据用于调试
            // lastSSEData.value = JSON.stringify(result, null, 2)
            
            // // 使用SSE处理器处理数据
            // if (sseProcessor && result.eventType === 'MESSAGE') {
            //   const updatedMessages = sseProcessor.processChunk(result)
              
            //   // 滚动到底部
            //   scrollToLastMsg(false)
            // }
            
            // 同时保持原有的处理逻辑
            handleChangeMessageList(result, currentMessageId)
          } catch (error) {
            console.error('解析SSE数据失败:', error, '原始数据:', chunk)
          }
        },
        // 完成回调
        () => {
          // 是否开启问题建议,可用值:Open,Close
          if (isSuggest.value) {
            // runChatSuggest(params as ConversationChatSuggestParams);
            const data = apiAgentConversationChatSuggest(params as ConversationChatSuggestParams);
            // setChatSuggestList(data);
            chatSuggestList.value = data as unknown as string[];
            // handleScrollBottom();
          }
        },
        // 错误回调
        (error: any) => {
          // if (currentAIMessage.value) {
          //   chatService.setMessageError(currentAIMessage.value, error.message || '请求失败')
          // }
          // isLoading.value = false
          // currentAIMessage.value = null
          // console.error('Chat error:', error)
        }
      )
    } catch (error) {
      // isLoading.value = false
      console.error('Chat error:', error)
    }
  };

	// 清除副作用
	// const handleClearSideEffect = () => {
  //   chatSuggestList.value = [];
  // };

	// 发送消息
	const handleSendMessage = async (
    messageInfo: string,
    files: UploadFileInfo[] = [],
    infos: AgentSelectedComponentInfo[] = [],
    variableParams?: { [key: string]: string | number },
  ) => {
    // 清除副作用
    // handleClearSideEffect();
    // 附件文件
    const attachments: AttachmentFile[] =
      files?.map((file) => ({
        fileKey: file.key || '',
        fileUrl: file.url || '',
        fileName: file.name || '',
        mimeType: file.type || '',
      })) || [];
	  
	  let chatMessageId: string = '';
	  
	  // #ifdef MP-WEIXIN
	  chatMessageId = uni.getRandomValues({
	    length: 16,
	  }).then(res => res.randomValues.toString()) as string;
	  // #endif
	  
	  // #ifdef H5
	  chatMessageId = uuidv4() as string;
	  // #endif

    // 将文件和消息加入会话中
    const chatMessage = {
      role: AssistantRoleEnum.USER,
      type: MessageModeEnum.CHAT,
      text: messageInfo,
      time: new Date().toISOString(),
      attachments,
      id: chatMessageId,
      messageType: MessageTypeEnum.USER,
    };

		let currentMessageId: string = '';
			// #ifdef MP-WEIXIN
			currentMessageId = uni.getRandomValues({
				length: 16,
			}).then(res => res.randomValues.toString()) as string;
			// #endif

			// #ifdef H5
			currentMessageId = uuidv4() as string;
			// #endif
			
			// 当前助手信息
			const currentMessage = {
				role: AssistantRoleEnum.ASSISTANT,
				type: MessageModeEnum.CHAT,
				text: '',
				think: '',
				time: new Date().toISOString(),
				id: currentMessageId,
				messageType: MessageTypeEnum.ASSISTANT,
				status: MessageStatusEnum.Loading,
				markdownElList: [],
			} as MessageInfo;

			// 将Incomplete状态的消息改为Complete状态
			const completeMessageList =
				messageList.value?.map((item: MessageInfo) => {
					if (item.status === MessageStatusEnum.Incomplete) {
						item.status = MessageStatusEnum.Complete;
					}
					return item;
				}) || [];
			// 构造消息列表
			const newMessageList = [
				...completeMessageList,
				chatMessage,
				currentMessage,
			] as MessageInfo[];
			// 检查会话状态
			checkConversationActive(newMessageList);
			// 缓存消息列表
			messageList.value = newMessageList;
    
			// 滚动到底部
			scrollToLastMsg(false);
			// 会话请求参数
			const params: ConversationChatParams = {
				conversationId: conversationId.value,
				variableParams,
				message: messageInfo,
				attachments,
				debug: false,
				selectedComponents: infos,
			};
			// 处理会话
			handleConversation(params, currentMessageId);
  };

	const state = computed<string>(() => {
		return 'none'
	})

	const chatInputContent = ref<string>('')
	
	// 不再需要lastMsg计算属性，直接使用messageList
	
	const chatActiveId = computed<string>(() => {
		return conversationId.value?.toString() || ''
	})
	
	const chatTitle = computed<string>(() => {
		return agentName.value || '新对话'
	})
	function scrollToLastMsg(userClick: boolean){
		autoToLastMsg = true
		scrollIntoView.value = ""
		scrollWithAnimation.value = userClick
		nextTick(() => {
			scrollIntoView.value = "last-msg"
			scrollInBottom.value = true
		})
	}
	
	const setIsInScrollBottom = () => {
		nextTick(() => {
			const scrollList = uni.getElementById('msg-list')
			const diff: number = scrollList!.scrollHeight - scrollList!.scrollTop - scrollList!.offsetHeight
			scrollInBottom.value = diff < 30
			if (scrollTouch.value || mouseScroll) {
				autoToLastMsg = !(diff > 3)
			}
		})
	}
	
	// 滚动状态监听，用于控制渲染
	watch(scrollInBottom, () => {
		// 可以在这里添加渲染控制逻辑
	}, { immediate: true })
	
	watch(scrolling, () => {
		// 可以在这里添加渲染控制逻辑
	}, { immediate: true })
	
	watch(chatActiveId, () => {
		scrollToLastMsg(false)
		nextTick(() => {
			// 标记最后一条消息为已渲染
			if (messageList.value.length > 0) {
				const lastMessage = messageList.value[messageList.value.length - 1];
				// 这里可以添加渲染标记逻辑
			}
		})
	}, { deep: true, immediate: true })
	
	const lockAutoToLastMsg = () => {
		if (!needSetLockAutoToLastMsg) return
		// 获取最后一条消息的ID
		const lastMessageId = messageList.value.length > 0 ? messageList.value[messageList.value.length - 1].id?.toString() : null;
		const lastMsgEl: UniElement | null = lastMessageId ? uni.getElementById('msg-item-' + lastMessageId) : null;
		const scrollList: UniElement | null = uni.getElementById('msg-list')
		if (lastMsgEl == null || scrollList == null) return 
		if (messageList.value.length < 3 || scrollList.offsetHeight < lastMsgEl.offsetHeight) {
			autoToLastMsg = false
			needSetLockAutoToLastMsg = false
		}
	}
	
	// 监听messageList的变化
	watch(messageList, async () => {
		setIsInScrollBottom()
		lockAutoToLastMsg()
		if (!scrollTouch.value && autoToLastMsg) {
			await nextTick()
			scrollToLastMsg(false)
		}
	}, { deep: true })

	const changeThinkContent = (hideThinkContent: boolean) => {
		setIsInScrollBottom()
	}
	
	// 管理消息组件的ref引用
	const messageRefs = ref<{ [key: string]: any }>({})
	
	const setMessageRef = (el: any, messageId: string) => {
		if (el) {
			messageRefs.value[messageId] = el;
			console.log(`消息组件 ${messageId} 已挂载，ref:`, el);
		}
	};
	
	const removeMessageRef = (messageId: string) => {
		if (messageRefs.value[messageId]) {
			delete messageRefs.value[messageId];
			console.log(`消息组件 ${messageId} 已卸载`);
		}
	};
	
	// 优化更新特定消息组件的方法
	const updateMessageComponent = async (messageId: string, newData: any) => {
		const messageRef = messageRefs.value[messageId];
		if (messageRef) {
			console.log(`正在更新消息组件 ${messageId}:`, newData);
			console.log('组件实例:', messageRef);
			console.log('组件方法:', Object.getOwnPropertyNames(messageRef));
			
			try {
				// 调用组件的更新方法（如果存在）
				if (typeof messageRef.updateMessage === 'function') {
					console.log('调用组件的updateMessage方法');
					await messageRef.updateMessage(newData);
					console.log('组件updateMessage方法调用成功');
				} else {
					console.log('组件没有updateMessage方法，使用备用方案');
					// 如果没有updateMessage方法，强制触发组件更新
					await nextTick();
					// 通过改变key来触发组件更新（但只针对特定组件）
					const message = messageList.value.find(msg => msg.id === messageId);
					if (message) {
						// 添加一个更新标记，触发响应式更新
						message.lastUpdateTime = Date.now();
						// 强制触发响应式更新
						messageList.value = [...messageList.value];
						console.log('使用备用方案更新完成');
					}
				}
			} catch (error) {
				console.error(`更新消息组件 ${messageId} 失败:`, error);
				// 如果updateMessage调用失败，也使用备用方案
				try {
					await nextTick();
					const message = messageList.value.find(msg => msg.id === messageId);
					if (message) {
						message.lastUpdateTime = Date.now();
						messageList.value = [...messageList.value];
						console.log('使用备用方案更新完成（错误恢复）');
					}
				} catch (backupError) {
					console.error('备用方案也失败了:', backupError);
				}
			}
		} else {
			console.warn(`消息组件 ${messageId} 的ref不存在`);
			console.log('当前所有refs:', messageRefs.value);
		}
	};
	
	// 将MessageInfo转换为MsgItem格式
	const convertMessageInfoToMsgItem = (messageInfo: MessageInfo): MsgItem => {
		// 添加调试信息，查看markdownElList的状态
		console.log('convertMessageInfoToMsgItem - messageInfo:', {
			id: messageInfo.id,
			text: messageInfo.text,
			markdownElList: messageInfo.markdownElList,
			messageType: messageInfo.messageType
		});
		
		// 如果markdownElList为空但有text内容，尝试重新解析
		let finalMarkdownElList = messageInfo.markdownElList || [];
		if (!finalMarkdownElList.length && messageInfo.text && messageInfo.messageType === MessageTypeEnum.ASSISTANT) {
			console.log('重新解析markdown内容:', messageInfo.text);
			try {
				// 使用ParseMarkdown实例重新解析完整的文本
				if (parseMarkdownInstance) {
					parseMarkdownInstance.runTask(messageInfo.text);
					// 从实例中获取解析结果
					const markdownElements = parseMarkdownInstance.markdownTokenList;
					if (markdownElements && markdownElements.length > 0) {
						const datasList: MarkdownToken[][] = treeToListSdk.markTreeToList(markdownElements[0]);
						finalMarkdownElList = [{
							uniqueId: generateUniqueId(),
							type: determineTypeFromData(datasList),
							datasList,
						}];
					}
				} else {
					// 备用方案：直接使用marked.lexer
					const markdownElements: MarkdownToken[] = (marked.lexer(messageInfo.text, null) as TokensList).tokens as MarkdownToken[];
					if (markdownElements && markdownElements.length > 0) {
						const datasList: MarkdownToken[][] = treeToListSdk.markTreeToList(markdownElements[0]);
						finalMarkdownElList = [{
							uniqueId: generateUniqueId(),
							type: determineTypeFromData(datasList),
							datasList,
						}];
					}
				}
				
				console.log('重新解析后的markdownElList:', finalMarkdownElList);
			} catch (error) {
				console.error('重新解析markdown失败:', error);
			}
		}
		console.log('convertMessageInfoToMsgItem - finalMarkdownElList', finalMarkdownElList);
		
		return {
			_id: messageInfo.id?.toString() || '',
			from_uid: messageInfo.messageType === MessageTypeEnum.ASSISTANT ? 'uni-ai' : 'user',
			thinkContent: messageInfo.text || messageInfo.think || '',
			body: messageInfo.text || messageInfo.think || '',
			create_time: new Date(messageInfo.time || Date.now()).getTime(),
			state: messageInfo.status === MessageStatusEnum.Complete ? 3 : 
				   messageInfo.status === MessageStatusEnum.Loading ? 2 : 
				   messageInfo.status === MessageStatusEnum.Incomplete ? 2 : 3,
			chat_id: 'chat-' + conversationId.value,
			markdownElList: finalMarkdownElList,
			rendered: false
		} as MsgItem;
	};

	// 长按消息
	const onlongTapMsg = (item: any) => {
		// 显示操作菜单
	}
		
	// 选择消息
	const onSelectMsg = (item: any) => {
		// 选择消息逻辑
	}
		
	// 修改消息
	const onEditMsg = (item: any) => {
		// 修改消息逻辑
	}
	
	const onKeyboardheightchange = (res: UniInputKeyboardHeightChangeEvent) => {
		keyboardHeight.value = res.detail.height
	}
	
	const onScroll = (e: UniScrollEvent) => {
		setIsInScrollBottom()
		scrolling.value = true
		if (scrollingT != 0) {
			clearTimeout(scrollingT)
		}
		scrollingT = setTimeout(() => {
			scrolling.value = false
		}, 500)
	}

	// const onInputKeydown = (e: UniApp.KeyboardEvent) => {
	// 	if (e.keyCode === 13) { // Enter键
	// 		// 使用handleSendMessage发送消息
	// 		if (chatInputContent.value.trim()) {
	// 			if (conversationId.value) {
	// 				handleSendMessage(chatInputContent.value);
	// 				chatInputContent.value = '';
	// 			} else {
	// 				// 先创建会话，然后发送消息
	// 				createNewConversation().then(() => {
	// 					if (conversationId.value) {
	// 						handleSendMessage(chatInputContent.value);
	// 						chatInputContent.value = '';
	// 					}
	// 				});
	// 			}
	// 		}
	// 	}
	// };

	// 处理更多弹窗
	const handleMorePopup = () => {
		// 确保组件已经挂载
		if (refMorePopup.value) {
			// 在微信小程序中，使用 nextTick 确保DOM更新完成
			nextTick(() => {
				refMorePopup.value?.open()
			})
		} else {
			console.warn('refMorePopup is null')
		}
	}

	/**
	 * 获取基本信息
	 * @param withConversationId 是否初始化会话id，默认false
	 * @param messageInfo 消息信息，默认''
	 * @param files 文件信息，默认[]
	 */
	const getPublishedAgentInfo = async (withConversationId: boolean = false, messageInfo: string = '', files: UploadFileInfo[] = []) => {
		const { code, data, message } = await apiPublishedAgentInfo(agentId.value, withConversationId)
		console.log('getPublishedAgentInfo', code, data, message);
		if (code === SUCCESS_CODE) {
			agentInfo.value = data
			if(withConversationId){
				conversationId.value = data.conversationId
				// 如果存在消息或文件，则发送消息
				if(messageInfo || files?.length > 0){
					// 初始化会话时，发送消息
					handleSendMessage(messageInfo, files)
				}
			}
		} else {
			uni.showToast({
				title: message,
				icon: 'none',
				type: 'error'
			})
		}
	}

	// 处理功能按钮点击
	const handleButtonClick = (buttonText : string) => {
		// 这里可以添加具体的功能逻辑
		uni.showToast({
			title: `点击了${buttonText}`,
			icon: 'none'
		})
	}
	// 收藏/取消收藏
	const handleCollect = async () => {
	if (!agentInfo.value) {
		return
	}
	if(agentInfo.value.collect){
		const { code, data } =  await apiUnCollectAgent(agentInfo.value.agentId)
		if (code === SUCCESS_CODE) {
			uni.showToast({
				title: '已取消收藏',
				icon: 'success',
				duration: 2000
			})
			agentInfo.value.collect = false
		}
	}else{
		const { code, data } = await apiCollectAgent(agentInfo.value.agentId)
		if (code === SUCCESS_CODE) {
			uni.showToast({
				title: '已添加到收藏',
				icon: 'success',
				duration: 2000
			})
			agentInfo.value.collect = true
		}
	}
}
</script>

<style lang="scss" scoped>
	.agent-detail-container {
		height: 100%;
		display: flex;
		padding-top: env(safe-area-inset-top);

		.right-buttons{
			display: flex;
			flex-direction: row;
			.iconfont{
				margin: 0 15rpx;
			}
		}

		.content {
			flex: 1;
			padding: 32rpx;

			.title-section {
				margin-bottom: 40rpx;

				.subtitle {
					font-size: 32rpx;
					font-weight: 400;
					color: rgba(21, 23, 31, 1);
					line-height: 48rpx;
					overflow: hidden;
					text-overflow: ellipsis;
					display: -webkit-box;
					-webkit-line-clamp: 2;
					-webkit-box-orient: vertical;
				}
			}
		}

		.chat-container {
			flex: 1;

			.scroll-view-box {
				flex: 1;
				position: relative;
				.msg-list {
					flex: 1;
					.user-msg {
						font-size: 16px;
						margin-left: auto;
						margin-right: 10px;
						margin-bottom: 10px;
						max-width: 600rpx;
						padding: 12px;
						border-radius: 15px 15px 0 15px;
						background-color: #eff6ff;
						/* #ifdef WEB */
						// 可以滑选 用于复制
						cursor: text;
						user-select: text;
						white-space: pre-wrap;
						word-break: break-all;
						/* #endif */;
					}
				}
				.add-chat-btn {
					position: absolute;
					bottom: 5px;
					left: 50%;
					transform: translateX(-50%);
				}
				.scroll-to-bottom {
					position: absolute;
					bottom: 10px;
					right: 10px;
					width: 35px;
					height: 35px;
					justify-content: center;
					align-items: center;
					background-color: #FFF;
					border-radius: 50px;
					padding: 5px;
					box-shadow: 0 0 10px 0 rgba(0,0,0,0.3);
					// #ifdef APP-HARMONY
					border: 1px solid #efefef;
					// #endif
					z-index: 10;
				}
			}
		}
	}
</style>