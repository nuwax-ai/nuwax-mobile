/**
 * 语音录音管理器
 * 封装 jz-h5-recorder-manager 插件，提供统一的录音接口
 */

import jzRecorder from '@/uni_modules/jz-h5-recorder-manager'

// 录音配置接口
export interface RecorderConfig {
  duration?: number        // 录音时长，单位ms，最大值600000（10分钟）
  sampleRate?: number      // 采样率，有效值 8000/16000/44100
  numberOfChannels?: number // 录音通道数，有效值 1/2
  encodeBitRate?: number   // 编码码率
  format?: string          // 音频格式，有效值 aac/mp3/wav/PCM
  frameSize?: number       // 指定帧大小，单位 KB
}

// 音频文件接口
export interface AudioFile {
  tempFilePath: string     // 临时文件路径
  duration: number         // 录音时长(秒)
  fileSize: number         // 文件大小(字节)
  format?: string          // 音频格式
}

// 录音状态接口
export interface RecordState {
  isRecording: boolean     // 是否正在录音
  isPressing: boolean      // 是否正在按压
  recordDuration: number   // 录音时长
  audioFile?: AudioFile    // 音频文件
  transcriptResult?: string // 转录结果
  isUploading: boolean     // 是否正在上传
}

// 录音错误接口
export interface RecordingError {
  code: string
  message: string
  originalError?: any
}

// 触摸事件接口
export interface TouchEvent {
  preventDefault: () => void
  type: string
  timestamp: number
}

// 波形动画数据接口
export interface WaveformBar {
  height: number
  delay: number
}

/**
 * 语音录音管理器类
 */
export class VoiceRecorderManager {
  private recorderManager: any = null
  private currentConfig: RecorderConfig = {}
  private state: RecordState = {
    isRecording: false,
    isPressing: false,
    recordDuration: 0,
    isUploading: false
  }
  
  // 触摸事件管理
  private touchStartTime: number = 0
  private longPressTimer: any = null
  private durationTimer: any = null
  
  // 波形动画管理
  private waveformBars: WaveformBar[] = [
    { height: 10, delay: 0 },
    { height: 15, delay: 100 },
    { height: 8, delay: 200 },
    { height: 20, delay: 300 },
    { height: 12, delay: 400 }
  ]
  
  // 事件回调
  private callbacks = {
    onStart: [] as Array<() => void>,
    onStop: [] as Array<(audioFile: AudioFile) => void>,
    onError: [] as Array<(error: RecordingError) => void>,
    onPause: [] as Array<() => void>,
    onResume: [] as Array<() => void>,
    onDurationUpdate: [] as Array<(duration: number) => void>,
    onWaveformUpdate: [] as Array<(bars: WaveformBar[]) => void>,
    onTouchStart: [] as Array<() => void>,
    onTouchEnd: [] as Array<() => void>,
    onLongPress: [] as Array<() => void>
  }
  
  constructor(config: RecorderConfig = {}) {
    this.currentConfig = {
      duration: 60000,
      sampleRate: 44100,
      numberOfChannels: 1,
      encodeBitRate: 192000,
      format: 'mp3',
      frameSize: undefined,
      ...config
    }
    
    this.initRecorderManager()
  }
  
  /**
   * 初始化录音管理器
   */
  private initRecorderManager(): void {
    try {
      this.recorderManager = jzRecorder.getRecorderManager()
      this.setupEventListeners()
    } catch (error) {
      console.error('初始化录音管理器失败:', error)
      this.triggerError({
        code: 'INIT_FAILED',
        message: '录音管理器初始化失败',
        originalError: error
      })
    }
  }
  
  /**
   * 设置事件监听器
   */
  private setupEventListeners(): void {
    if (!this.recorderManager) return
    
    // 录音开始事件
    this.recorderManager.onStart(() => {
      this.state.isRecording = true
      this.startDurationTimer()
      this.triggerStart()
    })
    
    // 录音停止事件
    this.recorderManager.onStop((res: any) => {
      this.state.isRecording = false
      this.stopDurationTimer()
      
      const audioFile: AudioFile = {
        tempFilePath: res.tempFilePath,
        duration: res.duration || 0,
        fileSize: res.fileSize || 0,
        format: this.currentConfig.format
      }
      
      this.state.audioFile = audioFile
      this.triggerStop(audioFile)
    })
    
    // 录音错误事件
    this.recorderManager.onError((err: any) => {
      this.state.isRecording = false
      this.stopDurationTimer()
      
      let errorCode = 'UNKNOWN_ERROR'
      let errorMessage = err.errMsg || '录音失败'
      
      // 根据错误信息判断错误类型
      if (errorMessage.includes('权限')) {
        errorCode = 'PERMISSION_DENIED'
        errorMessage = '麦克风权限被拒绝，请在设置中开启权限'
      } else if (errorMessage.includes('不支持')) {
        errorCode = 'DEVICE_NOT_SUPPORTED'
        errorMessage = '当前设备不支持录音功能'
      } else if (errorMessage.includes('网络')) {
        errorCode = 'NETWORK_ERROR'
        errorMessage = '网络连接异常，请检查网络设置'
      }
      
      this.triggerError({
        code: errorCode,
        message: errorMessage,
        originalError: err
      })
    })
    
    // 录音暂停事件
    this.recorderManager.onPause(() => {
      this.triggerPause()
    })
    
    // 录音恢复事件
    this.recorderManager.onResume(() => {
      this.triggerResume()
    })
  }
  
  /**
   * 触摸开始事件处理
   */
  handleTouchStart(e: TouchEvent): void {
    e.preventDefault()
    if (this.state.isRecording || this.state.isUploading) return
    
    this.touchStartTime = Date.now()
    this.state.isPressing = true
    this.triggerTouchStart()
    
    // 设置长按定时器，500ms后开始录音
    this.longPressTimer = setTimeout(() => {
      this.startRecording()
    }, 500)
  }
  
  /**
   * 触摸结束事件处理
   */
  handleTouchEnd(e: TouchEvent): void {
    e.preventDefault()
    this.handleTouchFinish()
  }
  
  /**
   * 触摸取消事件处理
   */
  handleTouchCancel(e: TouchEvent): void {
    e.preventDefault()
    this.handleTouchFinish()
  }
  
  /**
   * 长按事件处理（备用方案）
   */
  handleLongPress(e: TouchEvent): void {
    e.preventDefault()
    if (this.state.isRecording || this.state.isUploading) return
    
    // 如果触摸开始事件没有触发，这里作为备用
    if (!this.state.isPressing) {
      this.state.isPressing = true
      this.startRecording()
    }
  }
  
  /**
   * 处理触摸结束逻辑
   */
  private handleTouchFinish(): void {
    // 清除长按定时器
    if (this.longPressTimer) {
      clearTimeout(this.longPressTimer)
      this.longPressTimer = null
    }
    
    // 如果触摸时间太短，不执行录音
    const touchDuration = Date.now() - this.touchStartTime
    if (touchDuration < 500) {
      console.log('触摸时间太短，取消录音')
      this.resetTouchState()
      return
    }
    
    // 如果正在录音，立即给用户反馈
    if (this.state.isRecording) {
      console.log('松开录音，准备停止...')
      this.state.isUploading = true
      this.stopRecording()
    } else if (!this.state.isRecording && !this.state.isUploading) {
      // 如果还没有开始录音（触摸时间不够长），直接重置
      console.log('触摸时间不够，重置状态')
      this.resetTouchState()
    }
    
    this.triggerTouchEnd()
  }
  
  /**
   * 重置触摸状态
   */
  private resetTouchState(): void {
    this.state.isPressing = false
    this.touchStartTime = 0
    if (this.longPressTimer) {
      clearTimeout(this.longPressTimer)
      this.longPressTimer = null
    }
  }
  
  /**
   * 开始录音时长计时
   */
  private startDurationTimer(): void {
    this.state.recordDuration = 0
    this.durationTimer = setInterval(() => {
      this.state.recordDuration += 100
      this.updateWaveform()
      this.triggerDurationUpdate(this.state.recordDuration)
    }, 100)
  }
  
  /**
   * 停止录音时长计时
   */
  private stopDurationTimer(): void {
    if (this.durationTimer) {
      clearInterval(this.durationTimer)
      this.durationTimer = null
    }
  }
  
  /**
   * 更新波形动画
   */
  private updateWaveform(): void {
    this.waveformBars = this.waveformBars.map(bar => ({
      ...bar,
      height: Math.random() * 20 + 5
    }))
    this.triggerWaveformUpdate(this.waveformBars)
  }
  
  /**
   * 开始录音
   */
  async startRecording(): Promise<void> {
    if (this.state.isRecording) {
      throw new Error('录音已在进行中')
    }
    
    if (!this.recorderManager) {
      throw new Error('录音管理器未初始化')
    }
    
    try {
      // 检查录音时长
      if (this.currentConfig.duration && this.currentConfig.duration < 1000) {
        throw new Error('录音时长不能少于1秒')
      }
      
      // 开始录音
      this.recorderManager.start(this.currentConfig)
      
    } catch (error: any) {
      this.triggerError({
        code: 'START_FAILED',
        message: error.message || '开始录音失败',
        originalError: error
      })
      throw error
    }
  }
  
  /**
   * 停止录音
   */
  async stopRecording(): Promise<AudioFile> {
    if (!this.state.isRecording) {
      throw new Error('当前没有正在进行的录音')
    }
    
    if (!this.recorderManager) {
      throw new Error('录音管理器未初始化')
    }
    
    return new Promise((resolve, reject) => {
      // 设置临时回调来处理停止结果
      const originalStopCallbacks = [...this.callbacks.onStop]
      
      const tempStopCallback = (audioFile: AudioFile) => {
        // 移除临时回调
        this.callbacks.onStop = originalStopCallbacks
        resolve(audioFile)
      }
      
      this.callbacks.onStop = [tempStopCallback]
      
      // 设置超时
      const timeout = setTimeout(() => {
        this.callbacks.onStop = originalStopCallbacks
        reject(new Error('录音停止超时'))
      }, 5000)
      
      try {
        this.recorderManager.stop()
        clearTimeout(timeout)
      } catch (error: any) {
        clearTimeout(timeout)
        this.callbacks.onStop = originalStopCallbacks
        reject(error)
      }
    })
  }
  
  /**
   * 暂停录音
   */
  pauseRecording(): void {
    if (!this.state.isRecording) {
      throw new Error('当前没有正在进行的录音')
    }
    
    if (this.recorderManager) {
      this.recorderManager.pause()
    }
  }
  
  /**
   * 恢复录音
   */
  resumeRecording(): void {
    if (!this.state.isRecording) {
      throw new Error('当前没有正在进行的录音')
    }
    
    if (this.recorderManager) {
      this.recorderManager.resume()
    }
  }
  
  /**
   * 获取当前状态
   */
  getState(): RecordState {
    return { ...this.state }
  }
  
  /**
   * 获取波形数据
   */
  getWaveformBars(): WaveformBar[] {
    return [...this.waveformBars]
  }
  
  /**
   * 格式化录音时长
   */
  formatDuration(duration: number): string {
    const seconds = Math.floor(duration / 1000)
    const milliseconds = Math.floor((duration % 1000) / 100)
    return `${seconds}.${milliseconds}s`
  }
  
  /**
   * 更新配置
   */
  updateConfig(config: Partial<RecorderConfig>): void {
    this.currentConfig = { ...this.currentConfig, ...config }
  }
  
  /**
   * 注册开始录音事件
   */
  onStart(callback: () => void): void {
    this.callbacks.onStart.push(callback)
  }
  
  /**
   * 注册停止录音事件
   */
  onStop(callback: (audioFile: AudioFile) => void): void {
    this.callbacks.onStop.push(callback)
  }
  
  /**
   * 注册录音错误事件
   */
  onError(callback: (error: RecordingError) => void): void {
    this.callbacks.onError.push(callback)
  }
  
  /**
   * 注册暂停录音事件
   */
  onPause(callback: () => void): void {
    this.callbacks.onPause.push(callback)
  }
  
  /**
   * 注册恢复录音事件
   */
  onResume(callback: () => void): void {
    this.callbacks.onResume.push(callback)
  }
  
  /**
   * 注册时长更新事件
   */
  onDurationUpdate(callback: (duration: number) => void): void {
    this.callbacks.onDurationUpdate.push(callback)
  }
  
  /**
   * 注册波形更新事件
   */
  onWaveformUpdate(callback: (bars: WaveformBar[]) => void): void {
    this.callbacks.onWaveformUpdate.push(callback)
  }
  
  /**
   * 注册触摸开始事件
   */
  onTouchStart(callback: () => void): void {
    this.callbacks.onTouchStart.push(callback)
  }
  
  /**
   * 注册触摸结束事件
   */
  onTouchEnd(callback: () => void): void {
    this.callbacks.onTouchEnd.push(callback)
  }
  
  /**
   * 注册长按事件
   */
  onLongPress(callback: () => void): void {
    this.callbacks.onLongPress.push(callback)
  }
  
  /**
   * 移除事件监听器
   */
  off(eventName: string, callback?: Function): void {
    if (callback) {
      const callbacks = this.callbacks[eventName as keyof typeof this.callbacks] as any[]
      const index = callbacks.indexOf(callback)
      if (index > -1) {
        callbacks.splice(index, 1)
      }
    } else {
      // 移除所有该事件的监听器
      this.callbacks[eventName as keyof typeof this.callbacks] = [] as any
    }
  }
  
  /**
   * 销毁录音管理器
   */
  destroy(): void {
    // 停止计时器
    this.stopDurationTimer()
    
    // 清除触摸定时器
    if (this.longPressTimer) {
      clearTimeout(this.longPressTimer)
      this.longPressTimer = null
    }
    
    // 如果正在录音，先停止录音
    if (this.state.isRecording && this.recorderManager) {
      this.recorderManager.stop()
    }
    
    // 清理事件监听器
    if (this.recorderManager) {
      this.recorderManager.offStart?.()
      this.recorderManager.offStop?.()
      this.recorderManager.offError?.()
      this.recorderManager.offPause?.()
      this.recorderManager.offResume?.()
    }
    
    // 清理回调
    Object.keys(this.callbacks).forEach(key => {
      this.callbacks[key as keyof typeof this.callbacks] = [] as any
    })
    
    // 重置状态
    this.state = {
      isRecording: false,
      isPressing: false,
      recordDuration: 0,
      isUploading: false
    }
    
    this.recorderManager = null
  }
  
  // 私有方法：触发开始事件
  private triggerStart(): void {
    this.callbacks.onStart.forEach(callback => {
      try {
        callback()
      } catch (error) {
        console.error('onStart callback error:', error)
      }
    })
  }
  
  // 私有方法：触发停止事件
  private triggerStop(audioFile: AudioFile): void {
    this.callbacks.onStop.forEach(callback => {
      try {
        callback(audioFile)
      } catch (error) {
        console.error('onStop callback error:', error)
      }
    })
  }
  
  // 私有方法：触发错误事件
  private triggerError(error: RecordingError): void {
    this.callbacks.onError.forEach(callback => {
      try {
        callback(error)
      } catch (error) {
        console.error('onError callback error:', error)
      }
    })
  }
  
  // 私有方法：触发暂停事件
  private triggerPause(): void {
    this.callbacks.onPause.forEach(callback => {
      try {
        callback()
      } catch (error) {
        console.error('onPause callback error:', error)
      }
    })
  }
  
  // 私有方法：触发恢复事件
  private triggerResume(): void {
    this.callbacks.onResume.forEach(callback => {
      try {
        callback()
      } catch (error) {
        console.error('onResume callback error:', error)
      }
    })
  }
  
  // 私有方法：触发时长更新事件
  private triggerDurationUpdate(duration: number): void {
    this.callbacks.onDurationUpdate.forEach(callback => {
      try {
        callback(duration)
      } catch (error) {
        console.error('onDurationUpdate callback error:', error)
      }
    })
  }
  
  // 私有方法：触发波形更新事件
  private triggerWaveformUpdate(bars: WaveformBar[]): void {
    this.callbacks.onWaveformUpdate.forEach(callback => {
      try {
        callback(bars)
      } catch (error) {
        console.error('onWaveformUpdate callback error:', error)
      }
    })
  }
  
  // 私有方法：触发触摸开始事件
  private triggerTouchStart(): void {
    this.callbacks.onTouchStart.forEach(callback => {
      try {
        callback()
      } catch (error) {
        console.error('onTouchStart callback error:', error)
      }
    })
  }
  
  // 私有方法：触发触摸结束事件
  private triggerTouchEnd(): void {
    this.callbacks.onTouchEnd.forEach(callback => {
      try {
        callback()
      } catch (error) {
        console.error('onTouchEnd callback error:', error)
      }
    })
  }
}

/**
 * 创建录音管理器实例
 */
export function createVoiceRecorderManager(config?: RecorderConfig): VoiceRecorderManager {
  return new VoiceRecorderManager(config)
}

/**
 * 错误处理器类
 */
export class ErrorHandler {
  /**
   * 处理录音错误
   */
  static async handleRecordingError(error: RecordingError): Promise<void> {
    switch (error.code) {
      case 'PERMISSION_DENIED':
        await this.showPermissionGuide()
        break
      case 'DEVICE_NOT_SUPPORTED':
        await this.showDeviceNotSupportedMessage()
        break
      case 'NETWORK_ERROR':
        await this.retryWithBackoff()
        break
      case 'DURATION_TOO_SHORT':
        await this.showDurationTooShortMessage()
        break
      case 'DURATION_TOO_LONG':
        await this.showDurationTooLongMessage()
        break
      default:
        await this.showGenericError(error.message)
    }
  }
  
  /**
   * 显示权限引导
   */
  private static async showPermissionGuide(): Promise<void> {
    uni.showModal({
      title: '需要麦克风权限',
      content: '录音功能需要访问您的麦克风，请在设置中开启权限后重试',
      confirmText: '去设置',
      cancelText: '取消',
      success: (res) => {
        if (res.confirm) {
          // 引导用户到设置页面
          // 注意：这个功能需要根据平台实现
        }
      }
    })
  }
  
  /**
   * 显示设备不支持消息
   */
  private static async showDeviceNotSupportedMessage(): Promise<void> {
    uni.showToast({
      title: '当前设备不支持录音功能',
      icon: 'none',
      duration: 3000
    })
  }
  
  /**
   * 显示录音时长过短消息
   */
  private static async showDurationTooShortMessage(): Promise<void> {
    uni.showToast({
      title: '录音时间太短，请长按录音',
      icon: 'none',
      duration: 2000
    })
  }
  
  /**
   * 显示录音时长过长消息
   */
  private static async showDurationTooLongMessage(): Promise<void> {
    uni.showToast({
      title: '录音时间过长，已自动停止',
      icon: 'none',
      duration: 2000
    })
  }
  
  /**
   * 重试机制
   */
  private static async retryWithBackoff(): Promise<void> {
    // 指数退避重试策略实现
    uni.showToast({
      title: '网络异常，请稍后重试',
      icon: 'none',
      duration: 2000
    })
  }
  
  /**
   * 显示通用错误
   */
  private static async showGenericError(message: string): Promise<void> {
    uni.showToast({
      title: message || '操作失败，请重试',
      icon: 'none',
      duration: 2000
    })
  }
}