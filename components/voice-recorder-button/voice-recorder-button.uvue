<template>
  <!-- :hover-class="currentState === 'recording' ? 'hover-class' : ''" -->
  <button class="voice-recorder-container"
    hover-class="hover-class"
    hover-start-time="50"
    @touchstart="handleTouchStart"
    @touchend="handleTouchEnd"
    @touchcancel="cancelRecording"
    @touchmove="handleTouchMove">
    <!-- 点击时隐藏按钮文字 -->
    <view v-show="!isTapped">
      <!-- 状态提示文字 -->
      <text v-if="currentState === 'default'">按住说话</text>
      <view class="icon-loading-text" v-else-if="currentState === 'uploading'">
        <image 
          class="icon-loading-image" 
          src="@/static/assets/icon_loading.svg"
          :show-menu-by-longpress="false"
          @longtap.stop.prevent
          @contextmenu.stop.prevent="true"
          mode="widthFix" />
        <text>语音识别中</text>
      </view>
    </view>
  </button>
</template>

<script lang="uts" setup>
  import jzRecorder from '@/uni_modules/jz-h5-recorder-manager'
  import { 
    createAudioUploader, 
    type AudioFile as UploaderAudioFile,
    type TranscriptResult as UploaderTranscriptResult,
    type UploadProgress
  } from '@/servers/audioUploader'
  import { MicrophonePermissionHelper, type PermissionState } from '@/utils/permissionHelper'

  // 组件Props类型定义
  interface VoiceRecorderProps {
    // 录音配置
    duration?: number        // 最大录音时长 (ms)
    format?: string         // 音频格式
    sampleRate?: number     // 采样率
    // 会话是否正在进行中（有消息正在处理）
    isConversationActive?: boolean
  }

  // 录音状态类型
  type RecordState = 'default' | 'recording' | 'uploading' | 'success' | 'error'

  // 音频文件接口
  interface AudioFile {
    tempFilePath: string
    duration: number
    fileSize: number
    format?: string
  }

  // 转换结果接口
  interface TranscriptResult {
    success: boolean
    text: string
    confidence: number
    duration: number
    error?: string
  }

  const props = withDefaults(defineProps<VoiceRecorderProps>(), {
    duration: 600000, // 10分钟
    format: 'mp3',
    sampleRate: 44100,
    isConversationActive: false  // 会话是否正在进行中
  })

  const emit = defineEmits<{
    // 事件回调
    onRecordStart?: () => void,
    onRecordStop?: (result: string) => void,
    onError?: (error: any) => void,
    onUploadProgress?: (progress: number) => void
    // onCancelChange?: (isCancelled: boolean) => void
    onRecordCancel?: () => void
    onRecordEnd?: () => void 
  }>()

  // 响应式状态
  const currentState = ref<RecordState>('default')
  const isCancelled = ref<boolean>(false)
  // 是否点击
  const isTapped = ref<boolean>(false)
  // 录音管理器
  let recorderManager: any = null
  // 音频上传服务
  let audioUploadService: any = null // 使用audioUploader

  // 重置状态
  const resetState = () => {
    currentState.value = 'default'
    isCancelled.value = false
    isTapped.value = false
  }

  // 录音错误
  const handleRecordError = (err: any) => {
    resetState()
    emit('onError', err)
  }

  // 开始录音
  const handleTouchStart = async (e) => {
    console.time('touchstart')
    e.preventDefault() // Prevent default to avoid context menu

    if (props.isConversationActive) {
      emit('onError', new Error('会话正在进行中，请先暂停现有会话'))
      return
    }
    if (currentState.value !== 'default') {
      // emit('onError', new Error('请先停止当前录音' + currentState.value))
      return
    }
    isTapped.value = true;

    // #ifdef WEB
    // 确保麦克风权限可用
    const hasPermission = await MicrophonePermissionHelper.ensure(true)
    if (!hasPermission ) {
      isTapped.value = false;
      return
    }
    // #endif

    uni.showLoading({
      title: '正在连接',
    })

    // 开始录音
    if (recorderManager) {
      try {
        recorderManager.start({
          duration: props.duration,
          sampleRate: props.sampleRate,
          numberOfChannels: 1,
          encodeBitRate: 192000,
          format: props.format
        })
      } catch (error: any) {
        console.error('第一次授权录音', 11111111)
        uni.hideLoading()
        resetState()                                                                            
        emit('onError', error)
      }
    }
  }

  // 监听录音开始
  const handleRecordStart = () => {
    console.timeEnd('touchstart')
    // 设置状态，开始录音，并触发事件
    currentState.value = 'recording'
    emit('onRecordStart')
    uni.hideLoading()
  }

  // 录音中结束
  const handleTouchEnd = () => {
    console.time('touchend')
    isTapped.value = false;
    // 如果正在上传，则不停止录音
    if (currentState.value === 'uploading') {
      return
    }
    if (isCancelled.value) {
      cancelRecording()
    } else {
      stopRecording()
    }
  }

  // 取消录音
  const cancelRecording = () => {
    if (recorderManager) {
      recorderManager.stop()
    }
    resetState()
    emit('onRecordCancel')
  }

  // 录音停止
  const handleRecordStop = async (res: AudioFile) => {
    console.timeEnd('touchend')
    console.log('handleRecordStop called with duration:', res.duration, 'at', new Date().toISOString())
    // 检查录音时长（最短0.5秒），如果录音时间太短，直接取消
    // if (res.duration < 0.5) {
    //   resetState()
    //   emit('onError', new Error('录音时长过短，至少需要0.5秒'))
    //   return
    // }
    
    // 立即显示上传中状态，给用户明确反馈
    currentState.value = 'uploading'
    
    try {
      // 使用音频上传服务转换音频
      const result = await uploadAndConvertWithService(res)
      if (result.success) {
        currentState.value = 'success'
        emit('onRecordStop', result.text)
        // 重置状态
        resetState()
      } else {
        throw new Error(result?.text || '未识别到文字')
      }
    } catch (error: any) {
      handleRecordError(error)
    }
  }

  // 停止录音
  const stopRecording = () => {
    if (recorderManager) {
      try {
        recorderManager.stop()
        emit('onRecordEnd')
      } catch (error: any) {
        currentState.value = 'error'
        emit('onError', error)
      }
    }
    // 重置状态
    resetState()
  }

  // 使用audioUploader转换音频
  const uploadAndConvertWithService = async (audioFile: AudioFile): Promise<TranscriptResult> => {
    if (!audioUploadService) {
      throw new Error('音频上传服务未初始化')
    }

    try {
      // 转换音频文件格式
      const uploaderAudioFile: UploaderAudioFile = {
        tempFilePath: audioFile.tempFilePath,
        duration: audioFile.duration,
        fileSize: audioFile.fileSize,
        format: audioFile.format
      }

      // 调用audioUploader的上传方法
      const result = await audioUploadService.uploadAudio(uploaderAudioFile)

      // 转换结果格式
      return {
        success: result.success,
        text: result.text,
      }
    } catch (error: any) {
      return {
        success: false,
        text: error.message,
      }
    }
  }

  // 设置录音事件监听
  const setupRecorderEvents = async() => {
    if (!recorderManager) return
    // 录音开始
    recorderManager.onStart(handleRecordStart)
    // 录音停止
    recorderManager.onStop(handleRecordStop)
    // 录音错误
    recorderManager.onError(handleRecordError)
  }

  // 初始化录音管理器
  onMounted(() => {
    recorderManager = jzRecorder.getRecorderManager()
    // 设置录音事件监听
    setupRecorderEvents()
    // 初始化音频上传服务
    audioUploadService = createAudioUploader()
  })

  // 组件卸载时清理资源
  onUnmounted(() => {
    if (recorderManager) {
      // 清理事件监听器
      recorderManager.offStop(handleRecordStop)
    }
  })

  // Add touchmove handler to the button
  const handleTouchMove = (e) => {
    e.preventDefault();
  }
</script>

<style lang="scss" scoped>
  .voice-recorder-container {
    flex: 1;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    height: 112rpx;
    border-radius: 24rpx;
    transition: all 0.15s ease;
    -webkit-touch-callout: none;
    color: #000;
    font-size: 32rpx;
    font-weight: 400;
    background-color: transparent;
    padding: 0; // 删除uni-button默认padding
    user-select: none;
    -webkit-user-select: none;
    touch-action: none; /* 防止系统手势干预 */

    &.hover-class {
      background-color: rgb(108, 101, 244);
      z-index: 100;

      text {
        color: #fff;
      }
    }

    .icon-loading-text {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      user-select: none;

      .icon-loading-image {
        width: 48rpx;
        height: 48rpx;
        margin-right: 10rpx;
        -webkit-touch-callout: none !important;
        -webkit-user-select: none !important;
        user-select: none !important;
      }

      text {
        color: #666;
      }
    }
  }
</style>