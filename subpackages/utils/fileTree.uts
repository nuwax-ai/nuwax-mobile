import type { FileNode } from '@/types/interfaces/agent'

/**
 * 文件相关常量
 */
export const FILE_CONSTANTS = {
  // 支持预览的文件扩展名白名单
  SUPPORTED_EXTENSIONS: [
    // 图片文件
    'jpg',
    'jpeg',
    'png',
    'gif',
    'bmp',
    'webp',
    'svg',
    'ico',
    'tiff',
    // 代码文件
    'ts',
    'tsx',
    'js',
    'jsx',
    'mjs',
    'cjs',
    'css',
    'less',
    'scss',
    'sass',
    'html',
    'htm',
    'vue',
    'json',
    'jsonc',
    'yaml',
    'yml',
    'xml',
    'toml',
    'ini',
    'py',
    'java',
    'c',
    'cpp',
    'cs',
    'php',
    'rb',
    'go',
    'rs',
    'swift',
    'kt',
    'scala',
    'sh',
    'bash',
    'zsh',
    'fish',
    'ps1',
    'bat',
    'sql',
    'dockerfile',
    'makefile',
    // 文本文件
    'txt',
    'md',
    'markdown',
    'log',
    'csv',
    'tsv',
    'rtf',
  ],
  // 忽略的文件模式
  IGNORED_FILE_PATTERNS: [
    /^\./, // 以 . 开头的隐藏文件
    /^\.DS_Store$/,
    /^Thumbs\.db$/,
    /\.tmp$/,
    /\.bak$/,
  ],
  DEFAULT_FILE_LANGUAGE: 'Plain Text',
  FALLBACK_SIZE: 0,
  TREE_ROOT_LEVEL: 0,
  INDENT_SIZE: 16,
  REQUEST_ID_PREFIX: 'req_',
  SESSION_ID_PREFIX: 'session_',
};

/**
 * 将扁平的文件列表转换为树形结构
 */
export const transformFlatListToTree = (files: any[]): FileNode[] => {
  const root: FileNode[] = [];
  const map = new Map<string, FileNode>();

  // 过滤掉系统文件
  const filteredFiles = files.filter((file) => {
    const fileName = file.name.split('/').pop();
    return !FILE_CONSTANTS.IGNORED_FILE_PATTERNS.some((pattern) =>
      pattern.test(fileName || ''),
    );
  });

  // 创建所有文件节点和必要的文件夹节点
  filteredFiles.forEach((file) => {
    const pathParts = file.name.split('/').filter(Boolean);
    const fileName = pathParts[pathParts.length - 1];
    const isFile = fileName.includes('.');

    const node: FileNode = {
      id: file.name,
      name: fileName,
      type: isFile ? 'file' : 'folder',
      path: file.name,
      children: [],
      binary: file.binary || false,
      size:
        file.size || file.sizeExceeded
          ? FILE_CONSTANTS.FALLBACK_SIZE
          : file.contents?.length || FILE_CONSTANTS.FALLBACK_SIZE,
      status: file.status || null,
      fullPath: file.name,
      parentPath: pathParts.slice(0, -1).join('/') || null,
      content: file.contents || '',
      lastModified: Date.now(),
      fileProxyUrl: file?.fileProxyUrl || '',
    };

    map.set(file.name, node);

    // 如果文件在子目录中，确保创建所有必要的父文件夹节点
    if (pathParts.length > 1) {
      for (let i = pathParts.length - 2; i >= 0; i--) {
        const parentPath = pathParts.slice(0, i + 1).join('/');
        const parentName = pathParts[i];

        if (!map.has(parentPath)) {
          const parentNode: FileNode = {
            id: parentPath,
            name: parentName,
            type: 'folder',
            path: parentPath,
            children: [],
            parentPath: i > 0 ? pathParts.slice(0, i).join('/') : null,
            lastModified: Date.now(),
          };
          map.set(parentPath, parentNode);
        }
      }
    }
  });

  // 构建层次结构
  map.forEach((node) => {
    if (node.parentPath && map.has(node.parentPath)) {
      const parentNode = map.get(node.parentPath)!;
      if (
        !parentNode.children?.find((child: FileNode) => child.id === node.id)
      ) {
        parentNode.children?.push(node);
      }
    } else if (!node.parentPath) {
      if (!root.find((item: FileNode) => item.id === node.id)) {
        root.push(node);
      }
    }
  });

  // 排序：文件夹在前，文件在后，同类型按名称排序
  const sortNodes = (nodes: FileNode[]): FileNode[] => {
    return nodes.sort((a, b) => {
      if (a.type !== b.type) {
        return a.type === 'folder' ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
  };

  return sortNodes(root).map((node) => ({
    ...node,
    children: node.children ? sortNodes(node.children) : undefined,
  }));
};
