// 数学公式语法规则定义
// 使用 delimiters 配置统一处理不同的数学公式语法
// 支持标准 LaTeX、LaTeX 风格和 GPT 风格的数学公式

// 默认配置选项
const defaultOptions = {
  delimiters: [
    // 标准 LaTeX 行内公式 $...$
    { left: '$', right: '$', display: false },
    // 标准 LaTeX 块级公式 $$...$$
    { left: '$$', right: '$$', display: true },
    // LaTeX 风格行内公式 \(...\)
    { left: '\\(', right: '\\)', display: false },
    // LaTeX 风格块级公式 \[...\]
    { left: '\\[', right: '\\]', display: true },
    // GPT 风格行内公式 (\(...\))
    { left: '\\(', right: '\\)', display: false, wrapper: '()' },
    // GPT 风格块级公式 (\[...\])
    { left: '\\[', right: '\\]', display: true, wrapper: '()' }
  ],
  // 是否允许非标准模式（无空格分隔）
  nonStandard: false,
  // 是否抛出错误
  throwOnError: false,
  // 输出格式
  output: 'html'
};

// 创建渲染器函数
function createRenderer(options, newlineAfter) {
  return (token) => {
    // console.log("createRenderer", token);
    
    // 暂时返回原始文本，后续可以集成 KaTeX 渲染
    // 注意：这里需要根据实际环境引入 KaTeX
    // const renderedContent = katex.renderToString(token.text, {
    //   throwOnError: options.throwOnError || false,
    //   output: options.output || 'html',
    //   displayMode: token.displayMode
    // });
    
    return token.text + (newlineAfter ? "\n" : "");
  };
}

// 转义括号规则处理函数
function escapedBracketRule(options) {
  return (state, silent) => {
    const max = state.posMax;
    const start = state.pos;

    for (const { left, right, display, wrapper } of options.delimiters) {
      // 检查是否以左标记开始
      if (!state.src.slice(start).startsWith(left)) continue;

      // 跳过左标记的长度
      let pos = start + left.length;

      // 寻找匹配的右标记
      while (pos < max) {
        if (state.src.slice(pos).startsWith(right)) {
          break;
        }
        pos++;
      }

      // 没找到匹配的右标记，跳过，进入下个匹配
      if (pos >= max) continue;

      // 如果不是静默模式，处理数学公式
      if (!silent) {
        const content = state.src.slice(start + left.length, pos);
        
        // 创建数学公式 token
        const token = state.push('math', '', 0);
        token.raw = state.src.slice(start, pos + right.length);
        token.text = content.trim();
        token.displayMode = display;
        token.display = display;
        token.mathType = display ? 'block' : 'inline';
        
        // 如果有包装器，记录包装信息
        if (wrapper) {
          token.wrapper = wrapper;
        }
        
        // console.log(`匹配到数学公式: ${display ? '块级' : '行内'}`, token);
      }

      // 更新位置，跳过右标记的长度
      state.pos = pos + right.length;
      return true;
    }
    
    return false;
  };
}

// 行内数学公式扩展
function inlineKatex(options, renderer) {
  const mergedOptions = { ...defaultOptions, ...options };
  
  return {
    name: "inlineKatex",
    level: "inline",
    priority: 100, // 高优先级，确保在转义字符之前处理
    
    start(lexer, src, tokens) {
      // console.log("inlineKatex.start", src, tokens);
      
      // 检查所有可能的数学公式开始标记
      for (const { left } of mergedOptions.delimiters) {
        const index = src.search(left);
        if (index !== -1) {
          // 对于非标准模式，直接返回位置
          if (mergedOptions.nonStandard) {
            // console.log(`inlineKatex.start: 找到匹配模式 ${left} 在位置 ${index}`);
            return index;
          }
          
          // 标准模式：检查前后是否有适当的分隔符
          if (index === 0 || /\s/.test(src.charAt(index - 1)) || /[?!\.,:？！。，：]/.test(src.charAt(index - 1))) {
            // console.log(`inlineKatex.start: 找到标准匹配模式 ${left} 在位置 ${index}`);
            return index;
          }
        }
      }
      
      return undefined;
    },
    
    tokenizer(lexer, src, tokens) {
      // console.log("inlineKatex.tokenizer", src);
      
      // 使用转义括号规则处理数学公式
      const state = {
        src: src,
        pos: 0,
        posMax: src.length,
        push: (type, content, level) => {
          return {
            type: type,
            content: content,
            level: level
          };
        }
      };
      
      const result = escapedBracketRule(mergedOptions)(state, false);
      if (result) {
        // 找到匹配的数学公式，返回 token
        return {
          type: "math",
          raw: state.src.slice(0, state.pos),
          text: state.src.slice(0, state.pos).replace(/^[^$]*\$+/, '').replace(/\$+[^$]*$/, ''),
          displayMode: false,
          display: false,
          mathType: 'inline',
        };
      }
      
      // console.log("inlineKatex.tokenizer: 没有匹配到任何数学公式语法");
      return null;
    },
    
    renderer,
  };
}

// 块级数学公式扩展
function blockKatex(options, renderer) {
  const mergedOptions = { ...defaultOptions, ...options };
  
  return {
    name: "blockKatex",
    level: "inline", // 改为 inline 级别，以便在段落中处理
    priority: 95, // 高优先级，确保在行内扩展之前处理
    
    start(lexer, src, tokens) {
      // console.log("blockKatex.start", src, tokens);
      
      // 检查所有可能的块级数学公式开始标记
      for (const { left, display } of mergedOptions.delimiters) {
        if (display) { // 只检查块级公式
          const index = src.search(left);
          if (index !== -1) {
            // console.log(`blockKatex.start: 找到块级匹配模式 ${left} 在位置 ${index}`);
            return index;
          }
        }
      }
      
      return undefined;
    },
    
    tokenizer(lexer, src, tokens) {
      // console.log("blockKatex.tokenizer", src);
      
      // 使用转义括号规则处理块级数学公式
      const state = {
        src: src,
        pos: 0,
        posMax: src.length,
        push: (type, content, level) => {
          return {
            type: type,
            content: content,
            level: level
          };
        }
      };
      
      // 只处理块级公式
      const blockOptions = {
        ...mergedOptions,
        delimiters: mergedOptions.delimiters.filter(d => d.display)
      };
      
      const result = escapedBracketRule(blockOptions)(state, false);
      if (result) {
        // 找到匹配的块级数学公式，返回 token
        return {
          type: "math",
          raw: state.src.slice(0, state.pos),
          text: state.src.slice(0, state.pos).replace(/^[^$]*\$+/, '').replace(/\$+[^$]*$/, ''),
          displayMode: true,
          display: true,
          mathType: 'block',
        };
      }
      
      // console.log("blockKatex.tokenizer: 没有匹配到任何块级数学公式语法");
      return null;
    },
  };
}

// 主扩展函数
export default function (options = {}) {
  const mergedOptions = { ...defaultOptions, ...options };
  
  return {
    extensions: [
      blockKatex(mergedOptions, createRenderer(mergedOptions, true)),  // 块级扩展优先
      inlineKatex(mergedOptions, createRenderer(mergedOptions, false)), // 行内扩展后处理
    ],
  };
}