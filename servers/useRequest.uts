import { CONVERSATION_CONNECTION_URL } from '../constants/common.constants';
import { ACCESS_TOKEN } from '../constants/home.constants';
import { API_BASE_URL } from '../constants/config';

import {
  EventSourceMessage,
  fetchEventSource,
} from '@microsoft/fetch-event-source';
// import * as TextEncoding from "text-encoding-shim";

// 微信小程序：request
export default function request<T = any>(options: any) {
    const { url, ...rest } = options;
    return uni.request<T>({
        header: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + uni.getStorageSync(ACCESS_TOKEN),
        },
        url: API_BASE_URL + url,
        method: options.method || 'POST',
        ...rest,
      }).then(res => res.data);
  }

// 微信小程序：sse
export const weappEventSource = ({
    data,
    onmessage,
    onerror
  }: {
    data: any;
    onmessage: (txt: string) => void;
    onerror: (e: any) => void;
  }) => {
    const token = uni.getStorageSync(ACCESS_TOKEN) ?? '';
  
    const task = uni.request({
      url: CONVERSATION_CONNECTION_URL,
      method: 'POST',
      data,
      enableChunked: true,
      header: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
        Accept: 'application/json, text/plain, */* ',
      },
    });
    task.onChunkReceived(res => {
      const uint8Array = new Uint8Array(res.data);
      // const str1 = new TextEncoding.TextDecoder("utf-8").decode(uint8Array)
      const str = new TextDecoder('utf-8').decode(uint8Array);
      const dataStr = str.split("data:").slice(1)[0];
      onmessage(dataStr);
    });
    task.catch(onerror);
    return task; // 调用方可通过 task.abort() 手动断开
  }

  export interface SSEOptions<T = any> {
    url: string;
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
    headers?: { [key: string]: string };
    body?: any;
    onMessage: (data: T, event: any) => void;
    onError?: (error: Error) => void;
    onOpen?: (response: any) => void;
    onClose?: () => void;
    abortController?: any;
  }
  
  export async function createSSEConnection<T = any>(
    options: SSEOptions<T>,
  ): Promise<any> {
    // const controller = options.abortController || new AbortController();
  
    try {
      await fetchEventSource(options.url, {
        method: options.method || 'GET',
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
        body:
          typeof options.body === 'object'
            ? JSON.stringify(options.body)
            : options.body,
        // signal: controller.signal,
        openWhenHidden: true, // 页面不可见时保持连接
  
        onopen: async (response) => {
          if (response.status >= 400) {
            throw new Error(`SSE连接失败: ${response.statusText}`);
          }
          options.onOpen?.(response);
        },
  
        onmessage: (event) => {
          try {
            const data = event.data ? JSON.parse(event.data) : null;
            options.onMessage(data, event);
          } catch (error) {
            const normalizedError =
              error instanceof Error ? error : new Error(String(error));
            options.onError?.(normalizedError);
          }
        },
  
        onclose: () => {
          options.onClose?.();
        },
  
        onerror: (error) => {
          options.onError?.(error);
          // controller.abort();
          throw error; // 停止自动重试
        },
      });
    } catch (error) {
      const normalized =
        error instanceof Error ? error : new Error(String(error));
      options.onError?.(normalized);
    }
  
    // return () => controller.abort();
  }