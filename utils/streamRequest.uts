import { StreamRequestConfig, StreamChunk } from '@/types/interfaces/chat'
import { createSSEConnection } from '@/servers/useRequest.uts'
import { utf8ArrayToString } from '@/utils/utf8.uts'

// 全局错误处理 - 捕获未处理的 AbortError
// #ifdef H5
if (typeof window !== 'undefined') {
  window.addEventListener('unhandledrejection', (event) => {
    if (event.reason && event.reason.name === 'AbortError') {
      console.log('捕获到未处理的 AbortError，已静默处理')
      event.preventDefault() // 阻止默认的错误处理
    }
  })
}
// #endif

// 流式请求工具类
export class StreamRequest {
  private requestTask: RequestTask | null = null
  private isAborted: boolean = false
  private abortController: AbortController | null = null
  private buffer: string = '' // 用于缓存不完整的数据行

  // 发起流式请求
  async request(config: StreamRequestConfig): Promise<void> {
    this.isAborted = false
    this.buffer = '' // 重置缓冲区
    
    // #ifdef H5
    // 只在 H5 环境中创建 AbortController
    this.abortController = new AbortController()
    // #endif
    
    try {
      // #ifdef H5
      await this.requestH5(config)
      // #endif
      
      // #ifdef MP-WEIXIN
      await this.requestWeapp(config)
      // #endif
      
      // #ifdef APP-PLUS
      await this.requestApp(config)
      // #endif
      
    } catch (error) {
      // 如果是用户主动中止，不触发错误回调
      // #ifdef H5
      if (error.name === 'AbortError' || this.isAborted) {
        console.log('请求已被中止')
        return
      }
      // #endif
      
      // #ifdef MP-WEIXIN || APP-PLUS
      if (this.isAborted) {
        console.log('请求已被中止')
        return
      }
      // #endif
      
      config.onError?.(error)
    }
  }

  // H5环境下的流式请求
  private async requestH5(config: StreamRequestConfig): Promise<void> {
    // #ifdef H5
    try {
      await createSSEConnection({
        url: config.url,
        method: config.method,
        headers: config.headers as any,
        body: config.body,
        abortController: this.abortController,
        onMessage: (data: any) => {
          if (this.isAborted) return
          
          try {
            // 检查是否完成
            if (data && data.completed) {
              config.onComplete?.()
              return
            }
            
            // 处理数据块
            const chunk: StreamChunk = {
              type: 'content',
              data: data ? JSON.stringify(data) : ''
            }
            config.onChunk?.(chunk)
          } catch (e) {
            console.error('Parse chunk error:', e)
          }
        },
        onError: (error: Error) => {
          // 如果是中止错误，不触发错误回调
          if (error.name === 'AbortError' || this.isAborted) {
            console.log('SSE连接已被中止')
            return
          }
          config.onError?.(error)
        },
        onOpen: (response: any) => {
          console.log('SSE连接已建立:', response)
        },
        onClose: () => {
          console.log('SSE连接已关闭')
        }
      })
    } catch (error) {
      // 捕获所有可能的错误，包括 AbortError
      if (error.message === 'Connection aborted by user' || 
          error.name === 'AbortError' || 
          this.isAborted) {
        console.log('SSE连接已被中止')
        return
      }
      // 只有真正的错误才触发错误回调
      config.onError?.(error)
      throw error // 重新抛出非中止错误
    }
    // #endif
  }

  // 微信小程序环境下的流式请求
  private async requestWeapp(config: StreamRequestConfig): Promise<void> {
    // #ifdef MP-WEIXIN
    return new Promise((resolve, reject) => {
      this.requestTask = uni.request({
        url: config.url,
        method: config.method,
        header: config.headers as any,
        data: config.body,
        enableChunked: true, // 启用分块传输
        responseType: 'arraybuffer', // 响应类型
        success: (res) => {
          if (res.statusCode === 200) {
            // 流式数据通过 onChunkReceived 接收，success 仅表示请求建立成功
            // 实际的流式数据处理在 onChunkReceived 回调中
            config.onOpen?.(res)
          } else {
            reject(new Error(`HTTP error! status: ${res.statusCode}`))
          }
        },
        fail: (err) => {
          if (!this.isAborted) {
            config.onError?.(err)
            reject(err)
          }
        }
      })
      
      // 监听分块数据接收
      this.requestTask?.onChunkReceived?.((res) => {
        if (this.isAborted) return
        
        try {
          const uint8Array = new Uint8Array(res.data as ArrayBuffer)
          // #ifdef MP-WEIXIN
          const str = utf8ArrayToString(uint8Array)
          // #endif
          // #ifndef MP-WEIXIN
          const str = new TextDecoder('utf-8').decode(uint8Array)
          // #endif
          
          // console.log('[SSE] 接收到分块数据, 长度:', str.length)
          
          // 将新数据添加到缓冲区
          this.buffer += str
          
          // 按行分割，最后一行可能不完整
          const lines = this.buffer.split('\n')
          
          // 保存最后一行（可能不完整）
          this.buffer = lines.pop() || ''
          
          // 处理完整的行
          for (const line of lines) {
            if (line.trim() === '') continue
            
            if (line.startsWith('data:')) {
              const content = line.slice(5).trim()
              
              // 跳过空内容
              if (!content) {
                console.log('[SSE] 跳过空内容行')
                continue
              }
              
              // console.log('[SSE] 处理数据行, 长度:', content.length, '前50字符:', content.substring(0, 50))
              
              // 检查是否完成
              if (content === '[DONE]') {
                console.log('[SSE] 收到完成标记 [DONE]')
                config.onComplete?.()
                resolve()
                return
              }
              
              // 检查是否看起来像 JSON (以 { 或 [ 开头)
              const looksLikeJSON = content.startsWith('{') || content.startsWith('[')
              
              if (looksLikeJSON) {
                // 尝试解析 JSON 数据
                try {
                  const data = JSON.parse(content)
                  if (data && data.completed) {
                    console.log('[SSE] 收到完成标记 completed')
                    config.onComplete?.()
                    resolve()
                    return
                  }
                  
                  // 处理数据块
                  const chunk: StreamChunk = {
                    type: 'content',
                    data: content
                  }
                  config.onChunk?.(chunk)
                } catch (e) {
                  // JSON 解析失败，说明数据可能还是不完整，暂时跳过
                  console.log('[SSE] JSON 解析失败，可能数据不完整:', e, '内容长度:', content.length)
                }
              } else {
                // 不是 JSON 格式，直接作为内容处理
                console.log('[SSE] 非 JSON 格式，直接处理')
                const chunk: StreamChunk = {
                  type: 'content',
                  data: content
                }
                config.onChunk?.(chunk)
              }
            }
          }
        } catch (error) {
          console.error('处理分块数据失败:', error)
          if (!this.isAborted) {
            config.onError?.(error)
          }
        }
      })
    })
    // #endif
  }

  // App环境下的流式请求
  private async requestApp(config: StreamRequestConfig): Promise<void> {
    // #ifdef APP-PLUS
    return new Promise((resolve, reject) => {
      this.requestTask = uni.request({
        url: config.url,
        method: config.method,
        header: config.headers as any,
        data: config.body,
        success: (res) => {
          if (res.statusCode === 200) {
            // 处理流式响应
            this.handleStreamResponse(res.data as string, config)
            resolve()
          } else {
            reject(new Error(`HTTP error! status: ${res.statusCode}`))
          }
        },
        fail: (err) => {
          if (!this.isAborted) {
            reject(err)
          }
        }
      })
    })
    // #endif
  }

  // 处理流式响应数据
  private handleStreamResponse(data: string, config: StreamRequestConfig): void {
    console.log('[SSE-APP] 处理流式响应数据, 长度:', data.length)
    const lines = data.split('\n')
    
    for (const line of lines) {
      if (line.trim() === '') continue
      
      if (line.startsWith('data:')) {
        const content = line.slice(5).trim()
        
        // 跳过空内容
        if (!content) {
          console.log('[SSE-APP] 跳过空内容行')
          continue
        }
        
        console.log('[SSE-APP] 处理数据行:', content)
        
        // 检查是否完成
        if (content === '[DONE]') {
          console.log('[SSE-APP] 收到完成标记 [DONE]')
          config.onComplete?.()
          return
        }
        
        // 检查是否看起来像 JSON (以 { 或 [ 开头)
        const looksLikeJSON = content.startsWith('{') || content.startsWith('[')
        
        if (looksLikeJSON) {
          // 尝试解析 JSON 数据
          try {
            const parseData = JSON.parse(content)
            if (parseData && parseData.completed) {
              console.log('[SSE-APP] 收到完成标记 completed')
              config.onComplete?.()
              return
            }
          } catch (e) {
            // JSON 解析失败，继续处理为普通数据
            console.log('[SSE-APP] JSON 解析失败，作为普通内容处理')
          }
        } else {
          console.log('[SSE-APP] 非 JSON 格式，直接处理')
        }
        
        // 处理数据块
        try {
          const chunk: StreamChunk = {
            type: 'content',
            data: content
          }
          config.onChunk?.(chunk)
        } catch (e) {
          console.error('[SSE-APP] 处理数据块失败:', e)
        }
      }
    }
  }

  // 中止请求
  abort(): void {
    this.isAborted = true
    this.buffer = '' // 清空缓冲区
    
    // #ifdef H5
    // 中止 H5 的 SSE 连接
    if (this.abortController) {
      this.abortController.abort()
      this.abortController = null
    }
    // #endif
    
    // #ifdef MP-WEIXIN || APP-PLUS
    // 中止小程序和 App 的请求
    if (this.requestTask) {
      this.requestTask.abort()
      this.requestTask = null
    }
    // #endif
  }
}

// 创建流式请求实例
export const streamRequest = new StreamRequest()
