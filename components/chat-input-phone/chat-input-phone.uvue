<template>
  <view class="relative w-full container" :class="className">
    <!-- æ‰‹åŠ¨é€‰æ‹©ç»„ä»¶ -->
    <manual-component-item
      :manual-components="defaultManualComponents"
      :selected-component-list="defaultSelectedComponentList"
      :on-select-component="onSelectComponent"
    />
    <!--å›¾ç‰‡åˆ—è¡¨-->
    <template v-if="files?.length">
      <chat-upload-image :files="files" @del="handleDelFile" />
    </template>
    <view class="chat-input-container">
      <view v-if="inputMethod === ChatInputMethod.Voice" class="voice-container" @touchstart="handleVoiceStart" @touchend="handleVoiceEnd" @touchcancel="handleVoiceEnd">
        <text class="voice-text">{{ isVoiceing ? 'æ¾å¼€ç»“æŸ' : 'æŒ‰ä½è¯´è¯' }}</text>
      </view>
      <!--è¾“å…¥æ¡†-->
      <textarea
        ref="inputRef"
        v-if="inputMethod === ChatInputMethod.Input"
        class="input"
        placeholder-class="input-placeholder"
        :value="messageInfo"
        @input="handleInput"
        adjust-position="false"
        @keyboardheightchange="onKeyboardheightchange"
        :auto-height="true"
        @focus="onInputFocus"
        @blur="onInputBlur"
        placeholder="è¯·è¾“å…¥æŒ‡ä»¤">
      </textarea>
      <!-- å›¾æ ‡å®¹å™¨ -->
      <view class="icon-container">
        <!-- å‘é€æŒ‰é’® -->
        <text class="icon-box" v-if="messageInfo.length">
          <uni-icons class="iconfont icon-a-Chevronup" size="48rpx" />
        </text>
        <template v-else>
          <!-- è¾“å…¥æ–¹å¼: é”®ç›˜ -->
          <text
            v-if="inputMethod === ChatInputMethod.Voice"
            @click="handleChangeInputMethod"
            class="icon-box"
          >
            <uni-icons class="iconfont icon-keyboard" size="48rpx" />
          </text>
          <!-- è¾“å…¥æ–¹å¼: è¯­éŸ³ -->
          <text v-else class="icon-box" @click="handleChangeInputMethod">
            <uni-icons class="iconfont icon-voice" size="48rpx" />
          </text>
                      <!-- è¾“å…¥æ–¹å¼: ä¸Šä¼ å›¾ç‰‡ -->
            <text class="icon-box" @click="toggleExtraContainer">
              <uni-icons class="iconfont icon-Plus" size="48rpx" />
            </text>
        </template>
      </view>
    </view>
    <!-- åŠŸèƒ½æ  -->
    <view class="extra-container" :class="{ show: showExtraContainer }">
      <view class="extra-box" @click="chooseImage('camera')">
        <view class="icon-box">
          <uni-icons class="iconfont icon-Plus" size="48rpx" />
        </view>
        <text class="text">
          æ‹ç…§
        </text>
      </view>
      <view class="extra-box" @click="chooseImage('album')">
        <view class="icon-box">
          <uni-icons class="iconfont icon-Plus" size="48rpx" />
        </view>
        <text class="text">
          ç…§ç‰‡
        </text>
      </view>
    </view>
    <!-- å¼€å¯é”®ç›˜æ—¶ï¼Œåº•éƒ¨èƒŒæ™¯é«˜åº¦ä¸ºé”®ç›˜é«˜åº¦ -->
    <view class="keyboard-cover" :style="{height: keyboardHeight + 'px'}"></view>
    <!-- æ»šåŠ¨åˆ°åº•éƒ¨æŒ‰é’® -->
    <view class="chat-action">
      <view
        class="to-bottom"
        :class="{ 'visible': defaultVisible }"
        @click="props.onScrollBottom?.()"
      >
        <uni-icons type="arrowdown" size="20" color="#e5e5e5" />
      </view>
    </view>
  </view>
</template>

<script lang="uts" setup>
  import { SUCCESS_CODE } from '@/constants/codes.constants';
  import { UploadFileInfo } from '@/types/interfaces/common.uts';
  import { UploadFileStatus } from '@/types/enums/common.uts';
  import ChatUploadImage from '@/components/chat-upload-image/chat-upload-image.uvue';
  import ManualComponentItem from './manual-component-item/manual-component-item.uvue';
  import { AgentManualComponentInfo, AgentSelectedComponentInfo } from '@/types/interfaces/agent.uts';
  import { AgentComponentTypeEnum, DefaultSelectedEnum } from '@/types/enums/agent.uts';
  import { ChatInputMethod } from '@/types/enums/chat.uts';
  import { UPLOAD_FILE_ACTION } from '@/constants/common.constants';

  const DEFAULT_IMAGE_COUNT = 9;
  
  // è¾“å…¥æ–¹å¼
  const inputMethod = ref<ChatInputMethod>(ChatInputMethod.Voice);
  // è¾“å…¥æ¡†ref
  const inputRef = ref<UniInputElement | null>(null);
  // æ˜¯å¦æ˜¯è¯­éŸ³è¾“å…¥
  const isVoiceing = ref<boolean>(false);

  const props = defineProps<{
    className?: string;
    manualComponents?: AgentManualComponentInfo[];
    selectedComponentList?: AgentSelectedComponentInfo[];
    onSelectComponent?: (infos: AgentSelectedComponentInfo) => void;
    onEnter: (message: string, files: UploadFileInfo[]) => void;
    onScrollBottom?: () => void;
    visible?: boolean;
    // æ»šåŠ¨åˆ°æœ€åä¸€ä¸ªæ¶ˆæ¯åº•éƒ¨
    onScrollToLastMsg?: (isLast: boolean) => void;
  }>();

  // è°ƒè¯•ä¿¡æ¯
  onMounted(() => {
    console.log('chat-input-phone props:', props);
    console.log('manualComponents:', props.manualComponents);
  });

  // è®¡ç®—å±æ€§ï¼šæä¾›é»˜è®¤çš„ manualComponents
  const defaultManualComponents = computed(() => {
    if (props.manualComponents && props.manualComponents.length > 0) {
      return props.manualComponents;
    }
    return [{
      id: 1,
      name: 'äº’è”ç½‘æœç´¢',
      icon: 'ğŸŒ',
      description: 'æœç´¢äº’è”ç½‘ä¿¡æ¯',
      type: AgentComponentTypeEnum.Plugin,
      defaultSelected: DefaultSelectedEnum.Yes,
    }, {
      id: 2,
      name: 'æ·±åº¦ç ”ç©¶',
      icon: 'ğŸ’¡',
      description: 'æ·±åº¦åˆ†æå’Œç ”ç©¶',
      type: AgentComponentTypeEnum.Plugin,
      defaultSelected: DefaultSelectedEnum.No,
    }, {
      id: 3,
      name: 'çŸ¥è¯†åº“',
      icon: 'ğŸ’¡',
      description: 'æ·±åº¦åˆ†æå’Œç ”ç©¶',
      type: AgentComponentTypeEnum.Plugin,
      defaultSelected: DefaultSelectedEnum.No,
    }, {
      id: 4,
      name: 'çŸ¥è¯†åº“',
      icon: 'ğŸ’¡',
      description: 'æ·±åº¦åˆ†æå’Œç ”ç©¶',
      type: AgentComponentTypeEnum.Plugin,
      defaultSelected: DefaultSelectedEnum.No,
    }, {
      id: 5,
      name: 'çŸ¥è¯†åº“',
      icon: 'ğŸ’¡',
      description: 'æ·±åº¦åˆ†æå’Œç ”ç©¶',
      type: AgentComponentTypeEnum.Plugin,
      defaultSelected: DefaultSelectedEnum.No,
    }, {
      id: 6,
      name: 'çŸ¥è¯†åº“',
      icon: 'ğŸ’¡',
      description: 'æ·±åº¦åˆ†æå’Œç ”ç©¶',
      type: AgentComponentTypeEnum.Plugin,
      defaultSelected: DefaultSelectedEnum.No,
    }, {
      id: 7,
      name: 'çŸ¥è¯†åº“',
      icon: 'ğŸ’¡',
      description: 'æ·±åº¦åˆ†æå’Œç ”ç©¶',
      type: AgentComponentTypeEnum.Plugin,
      defaultSelected: DefaultSelectedEnum.No,
    }];
  });

  // è®¡ç®—å±æ€§ï¼šæä¾›é»˜è®¤çš„ selectedComponentList
  const defaultSelectedComponentList = computed(() => {
    if (props.selectedComponentList && props.selectedComponentList.length > 0) {
      return props.selectedComponentList;
    }
    
    // å¦‚æœæ²¡æœ‰ä¼ å…¥é€‰ä¸­åˆ—è¡¨ï¼Œåˆ™æ ¹æ®é»˜è®¤é€‰ä¸­çŠ¶æ€è‡ªåŠ¨é€‰æ‹©
    const autoSelected = defaultManualComponents.value
      .filter(item => item.defaultSelected === DefaultSelectedEnum.Yes)
      .map(item => ({
        id: item.id,
        type: item.type
      }));
    
    return autoSelected;
  });

  // è®¡ç®—å±æ€§ï¼šæä¾›é»˜è®¤çš„ visible
  const defaultVisible = computed(() => {
    return props.visible ?? false;
  });

  // æ–‡æ¡£
  const files = ref<UploadFileInfo[]>([]);
  const messageInfo = ref<string>('');
  // é”®ç›˜é«˜åº¦
  const keyboardHeight = ref<number>(0)
  // æ˜¯å¦æ˜¾ç¤ºé¢å¤–åŠŸèƒ½æ 
  const showExtraContainer = ref<boolean>(false);
  // ä»¤ç‰Œ
  const token = uni.getStorageSync('ACCESS_TOKEN') ?? '';

  const onKeyboardheightchange = (res: UniInputKeyboardHeightChangeEvent) => {
		keyboardHeight.value = res.detail.height
	}

  // æ‹ç…§
  const chooseImage = (type: string) => {
    if (files.value.length >= DEFAULT_IMAGE_COUNT) {
      uni.showToast({
        position: "bottom",
        title: `å·²ç»æœ‰ ${DEFAULT_IMAGE_COUNT} å¼ å›¾ç‰‡äº†ï¼Œè¯·åˆ é™¤éƒ¨åˆ†å›¾ç‰‡ä¹‹åé‡æ–°é€‰æ‹©`
      })
      return
    }
    uni.chooseImage({
      sourceType: [type === 'camera' ? 'camera' : 'album'],
      sizeType: ['original', 'compressed'],
      count: DEFAULT_IMAGE_COUNT - files.value.length,
      success: (res) => {
        const _files = res.tempFiles.map(file => ({
          url: file.path,
          name: file.name,
          type: file.type,
          size: file.size,
          status: UploadFileStatus.uploading,
        }));
        files.value = [...files.value, ..._files] as UploadFileInfo[];
        console.log("é€‰æ‹©å›¾ç‰‡æˆåŠŸï¼Œå‡†å¤‡ä¸Šä¼ : ", files.value);

        // ä¸€æ¬¡æ€§ä¸Šä¼ æ‰€æœ‰é€‰ä¸­çš„å›¾ç‰‡
        const filePaths = res.tempFiles.map(file => file.path);
        uploadMultipleImages(filePaths);
      },
      fail: (err) => {
        console.log("err: ", JSON.stringify(err));
        uni.showToast({
          title:"choose image error.code:" + err.errCode+";message:"+err.errMsg,
          position:"bottom"
        })
      }
    })
  }

  // ä¸Šä¼ å•å¼ å›¾ç‰‡ï¼ˆè¿”å›Promiseï¼‰
  const uploadImage = (filePath: string): Promise<UploadFileInfo> => {
    return new Promise((resolve, reject) => {
      const fileName = filePath.split('/').pop() || 'image.jpg';
      // ç”Ÿæˆå”¯ä¸€ID
      const uid = Date.now().toString() + Math.random().toString(36).substr(2, 9);
      const uploadTask: UploadTask = uni.uploadFile({
        url: UPLOAD_FILE_ACTION,
        filePath: filePath,
        name: 'file',
        header: {
          'Authorization': `Bearer ${token}`
        },
        formData: {
          type: 'tmp',
        },
        success: (res) => {
          try {
            const result = JSON.parse(res.data);
            const { code, data, message } = result;
            if (code === SUCCESS_CODE) {
              const uploadedFile: UploadFileInfo = {
                key: data?.key || '',
                name: data?.fileName || fileName,
                type: data?.mimeType || 'image/jpeg',
                size: data?.size || 0,
                url: data?.url || '',
                uid,
                status: UploadFileStatus.done,
                percent: 100,
                response: result
              };
              resolve(uploadedFile);
            } else {
              reject(new Error(data.message || 'ä¸Šä¼ å¤±è´¥'));
            }
          } catch (error) {
            console.error('è§£æä¸Šä¼ å“åº”å¤±è´¥:', error);
            reject(error);
          }
        },
        fail: (error) => {
          console.error('ä¸Šä¼ å¤±è´¥:', error);
          reject(error);
        }
      });

      // ä¸Šä¼ è¿›åº¦
      uploadTask.onProgressUpdate((res: OnProgressUpdateResult) => {
        console.log("ä¸Šä¼ è¿›åº¦: ", res.progress);
        const index = files.value.findIndex(file => file.url === filePath);
        if (index !== -1) {
          files.value[index].percent = res.progress;
        }
      });
    });
  }

  // å¤šæ–‡ä»¶ä¸Šä¼ 
  const uploadMultipleImages = async (filePaths: string[]) => {
    if (filePaths.length === 0) return;

    try {
      console.log(`å¼€å§‹ä¸Šä¼  ${filePaths.length} å¼ å›¾ç‰‡...`);

      // æ˜¾ç¤ºä¸Šä¼ è¿›åº¦æç¤º
      uni.showLoading({
        title: 'ä¸Šä¼ ä¸­...',
        mask: true
      });

      // å¹¶å‘ä¸Šä¼ æ‰€æœ‰å›¾ç‰‡
      const uploadPromises = filePaths.map(filePath => uploadImage(filePath));
      const uploadedFiles = await Promise.all(uploadPromises);

      // æ›´æ–°æ–‡ä»¶çŠ¶æ€
      uploadedFiles.forEach(uploadedFile => {
        // æ‰¾åˆ°å¯¹åº”çš„æ–‡ä»¶å¹¶æ›´æ–°çŠ¶æ€
        const index = files.value.findIndex(file => file.url === uploadedFile.url);
        if (index !== -1) {
          files.value[index] = uploadedFile;
        }
      });

      // éšè—é¢å¤–åŠŸèƒ½æ 
      showExtraContainer.value = false;

      uni.hideLoading();
      uni.showToast({
        title: `ä¸Šä¼ æˆåŠŸ ${uploadedFiles.length} å¼ å›¾ç‰‡`,
        icon: 'success',
        duration: 2000
      });

      console.log('æ‰€æœ‰å›¾ç‰‡ä¸Šä¼ å®Œæˆ:', uploadedFiles);
    } catch (error) {
      console.error('æ‰¹é‡ä¸Šä¼ å¤±è´¥:', error);
      uni.hideLoading();
      uni.showToast({
        title: 'ä¸Šä¼ å¤±è´¥ï¼Œè¯·é‡è¯•',
        icon: 'none',
        duration: 2000
      });

      // æ›´æ–°å¤±è´¥çš„æ–‡ä»¶çŠ¶æ€
      files.value = files.value.map(file => {
        if (file.status === UploadFileStatus.uploading) {
          return { ...file, status: UploadFileStatus.error };
        }
        return file;
      });
    }
  }

  // è¾“å…¥æ¡†è·å–ç„¦ç‚¹
  const onInputFocus = () => {
    // éšè—é¢å¤–åŠŸèƒ½æ 
    showExtraContainer.value = false;
    // æ»šåŠ¨åˆ°æœ€åä¸€ä¸ªæ¶ˆæ¯
    props.onScrollToLastMsg?.(true);
  };

  // è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹
  const onInputBlur = () => {
    // éšè—é¢å¤–åŠŸèƒ½æ 
    showExtraContainer.value = false;
  };
  
  // åˆ‡æ¢é¢å¤–åŠŸèƒ½æ æ˜¾ç¤º/éšè—
  const toggleExtraContainer = () => {
    showExtraContainer.value = !showExtraContainer.value;
  };
	
  // åˆ‡æ¢è¾“å…¥æ–¹å¼
  const handleChangeInputMethod = () => {
    if (inputMethod.value === ChatInputMethod.Voice) {
      inputMethod.value = ChatInputMethod.Input;
      // éšè—é¢å¤–åŠŸèƒ½æ 
      showExtraContainer.value = false;
      nextTick(() => {
        inputRef.value?.focus();
      });
    } else {
      inputMethod.value = ChatInputMethod.Voice;
    }
  };

  // å‘é€æŒ‰é’®disabled
  const disabledSend = computed(() => {
    return !messageInfo.value && !files.value?.length;
  });

  // è¾“å…¥äº‹ä»¶
  const handleInput = (e: UniInputEvent) => {
    messageInfo.value = e.detail.value;
  };

  // è¯­éŸ³å¼€å§‹
  const handleVoiceStart = () => {
    isVoiceing.value = true;
    // å¼€å§‹è¯­éŸ³å½•å…¥
    startVoiceRecording();
  };

  // è¯­éŸ³ç»“æŸ
  const handleVoiceEnd = () => {
    if (isVoiceing.value) {
      isVoiceing.value = false;
      // ç»“æŸè¯­éŸ³å½•å…¥å¹¶å‘é€
      stopVoiceRecording();
    }
  };

  // å¼€å§‹è¯­éŸ³å½•å…¥
  const startVoiceRecording = () => {
    // è¿™é‡Œæ·»åŠ å¼€å§‹è¯­éŸ³å½•å…¥çš„é€»è¾‘
    console.log('å¼€å§‹è¯­éŸ³å½•å…¥');
    // ä¾‹å¦‚ï¼šè°ƒç”¨å½•éŸ³API
    // uni.startRecord();
  };

  // åœæ­¢è¯­éŸ³å½•å…¥å¹¶å‘é€
  const stopVoiceRecording = () => {
    // è¿™é‡Œæ·»åŠ åœæ­¢è¯­éŸ³å½•å…¥å¹¶å‘é€çš„é€»è¾‘
    console.log('åœæ­¢è¯­éŸ³å½•å…¥å¹¶å‘é€');
    // ä¾‹å¦‚ï¼šåœæ­¢å½•éŸ³å¹¶å‘é€
    // uni.stopRecord({
    //   success: (res) => {
    //     // å‘é€è¯­éŸ³æ¶ˆæ¯
    //     props.onEnter('è¯­éŸ³æ¶ˆæ¯', files.value);
    //   }
    // });
  };

  // ç‚¹å‡»å‘é€äº‹ä»¶
  const handleSendMessage = () => {
    if (disabledSend) {
      return;
    }
    if (messageInfo.value || files.value?.length > 0) {
      // enteräº‹ä»¶
      props.onEnter(messageInfo.value, files.value);
      // ç½®ç©º
      files.value = [];
      messageInfo.value = '';
    }
  };

  // enteräº‹ä»¶
  const handlePressEnter = (e) => {
    e.preventDefault();
    const { value } = e.target;
    // shift+enteræˆ–è€…ctrl+enteræ—¶æ¢è¡Œ
    if (
      e.nativeEvent.keyCode === 13 &&
      (e.nativeEvent.shiftKey || e.nativeEvent.ctrlKey)
    ) {
      const enterValue = `${value}\n`;
      messageInfo.value = enterValue;
    } else if (
      e.nativeEvent.keyCode === 13 &&
      (!!value.trim() || !!files.value?.length)
    ) {
      // enteräº‹ä»¶
      props.onEnter(value, files.value);
      // ç½®ç©º
      files.value = [];
      messageInfo.value = '';
    }
  };

  // ä¸Šä¼ æˆåŠŸåï¼Œä¿®æ”¹æ–‡æ¡£åˆ—è¡¨
  const handleChange = (info: any) => {
    if (info.file.status === 'uploading') {
      return;
    }
    if (info.file.status === 'done') {
      // æ¥å£ä¸Šä¼ å¤±è´¥
      if (info.file.response?.code !== SUCCESS_CODE) {
        uni.showToast({
          title: info.file.response?.message,
          icon: 'none',
        });
        return;
      }
      const data = info.file.response?.data;
      const _files = [...files];
      _files.push({
        key: data?.key || '',
        name: data?.fileName || info.file.name || '',
        type: data?.mimeType || info.file.type || '',
        size: data?.size || info.file.size || 0,
        url: data?.url || info.file.url || '',
        uid: info.file.uid,
        status: (info.file.status as UploadFileStatus) || UploadFileStatus.done,
        percent: info.file.percent,
        response: info.file.response,
      });
      files.value = _files;
    }
  };

  // åˆ é™¤æ–‡æ¡£
  const handleDelFile = (uid: string) => {
    const _files = [...files];
    _files.splice(
      _files.findIndex((item) => item.uid === uid),
      1,
    );
    files.value = _files;
  };
</script>

<style lang="scss" scoped>
.container {
  padding: 16rpx 32rpx;
  gap: 24rpx;
  background-color: #fff;
  border-radius: 16rpx 16rpx 0 0;
  /* ç¡®ä¿å®¹å™¨ä¸ä¼šè£å‰ªè¶…å‡ºè¾¹ç•Œçš„å†…å®¹ */
  overflow: visible;

  .chat-input-container {
    display: flex;
    flex-direction: row;
    align-items: flex-end;
    align-self: stretch;
    padding: 16rpx 16rpx 16rpx 32rpx;
    border-radius: 24rpx;
    box-shadow: 0 9rpx 45rpx 0 rgba(0, 0, 0, 0.06), 0 2rpx 10rpx 0 rgba(0, 0, 0, 0.03), 0 0 3rpx 0 rgba(0, 0, 0, 0.04);
    gap: 16rpx;

    .voice-container {
      flex: 1;
      height: 70rpx;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 12rpx;
      transition: background-color 0.3s ease;
      
      &:active {
        background-color: #5147FF;
        font-size: 32rpx;
        font-weight: 400;

        .voice-text {
          color: #fff;
        }
      }
      
      .voice-text {
        font-weight: 400;
        color: #15171F;
        font-size: 32rpx;
        text-align: center;
        transition: color 0.3s;
      }
    }

    .input {
      flex: 1;
      min-height: 70rpx;
      max-height: 200rpx;
      line-height: 70rpx;
      padding: 0;
      border: none;
      overflow-y: auto;
      display: flex;
      align-items: center;
    }

    .input-placeholder {
      color: rgba(21, 23, 31, 0.30);
      font-size: 32rpx;
      font-weight: 400;
    }

    .icon-container {
      display: flex;
      flex-direction: row;
      gap: 16rpx;
      flex-shrink: 0;

      .icon-box {
        width: 70rpx;
        height: 70rpx;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    }
  }

  .chat-action {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translate(-50%);

    .to-bottom {
      width: 44rpx;
      height: 44rpx;
      position: absolute;
      left: 50%;
      bottom: 24px;
      border: 1px solid #e5e5e5;
      background-color: #fff;
      border-radius: 50%;
      transform: translate(-50%);
      display: flex;
      align-items: center;
      font-size: 20px;
      justify-content: center;
      box-shadow: 0 4rpx 10rpx rgba(0, 0, 0, 25%);
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;

      &.visible {
        opacity: 1;
        visibility: visible;
      }
    }
  }

  .extra-container {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-start;
    padding: 8rpx 0;
    gap: 16rpx;
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out, opacity 0.3s ease-in-out;
    opacity: 0;

    &.show {
      max-height: 200rpx;
      padding: 8rpx 0;
      opacity: 1;
    }

    .extra-box {
      width: 164rpx;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16rpx;

      .icon-box {
        width: 112rpx;
        height: 112rpx;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 16rpx;
        border-radius: 16rpx;
        background-color: #F5F5F5;
      }

      .text {
        font-size: 28rpx;
        color: #15171F;
        font-weight: 400;
        line-height: 44rpx;
      }
    }
  }

  // é”®ç›˜å¼¹å‡ºåï¼Œå«é«˜åº•éƒ¨ã€‚é»˜è®¤å ä½å¤§å°ä¸ºåº•éƒ¨å®‰å…¨åŒºåŸŸé«˜åº¦
  .keyboard-cover {
    // Android çš„é”®ç›˜é«˜åº¦ä¸åŒ…å«å®‰å…¨åŒºåŸŸé«˜åº¦ï¼Œå…¶ä»–å¹³å°åŒ…å«
    // #ifdef APP-ANDROID
    margin-bottom: env(safe-area-inset-bottom);
    // #endif
    // #ifndef APP-ANDROID
    padding-bottom: env(safe-area-inset-bottom);
    // #endif
  }
}
</style>