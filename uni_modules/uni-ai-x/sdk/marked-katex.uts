/**
 * marked-katex.uts
 * 统一的 Markdown + KaTeX 数学公式解析工具
 * 参照 marked-katex.js 实现，支持 disableKatex 开关
 */

import { useMarked, TokensList, NodesToken as MarkdownToken } from '@/uni_modules/kux-marked';

// 数学公式 Token 类型定义
export interface MathToken extends MarkdownToken {
  type: 'math';
  raw: string;
  text: string;
  display: boolean;  // 是否为块级公式
  mathType: 'inline' | 'block';
}

/**
 * 数学公式扩展配置
 * 支持多种数学公式语法：
 * - $...$ (行内公式)
 * - $$...$$ (块级公式)  
 * - \(...\) (LaTeX 行内)
 * - \[...\] (LaTeX 块级)
 */
const mathExtension = {
  name: 'math',
  level: 'inline',
  
  /**
   * 查找数学公式的起始位置
   */
  start(src: string): number {
    return src.search(/\$|\\\(|\\\[|\\\)|\\\]/)
  },
  
  /**
   * 数学公式词法分析器
   * 处理各种数学公式语法，避免误判金额等场景
   */
  tokenizer(src: string, tokens?: MarkdownToken[]): MathToken | null {
    // 忽略代码区域内的公式语法
    if (tokens && tokens.length > 0) {
      const lastToken = tokens[tokens.length - 1]
      if (lastToken && (lastToken.type === 'codespan' || lastToken.type === 'code')) {
        return null
      }
    }

    // 处理转义的 \$ → $
    const escapeMatch = /^\\\$/.exec(src)
    if (escapeMatch) {
      return {
        type: 'text',
        raw: escapeMatch[0],
        text: '$'
      } as any
    }

    // 块级公式：$$...$$
    const blockDollarMatch = /^\$\$([\s\S]+?)\$\$/.exec(src)
    if (blockDollarMatch) {
      return {
        type: 'math',
        raw: blockDollarMatch[0],
        text: blockDollarMatch[1].trim(),
        display: true,
        mathType: 'block',
        tokens: [],
        uniqueId: '',
        isClose: true
      } as MathToken
    }

    // 行内公式：$...$，避免 $100 误判
    const inlineDollarMatch = /^\$([^\$\n]+?)\$/.exec(src)
    if (inlineDollarMatch) {
      const beforeChar = src.length > 0 ? src[0 - 1] || ' ' : ' '
      const afterChar = src[inlineDollarMatch[0].length] || ' '
      
      // 前后不能是数字或字母，避免 $100 这样的金额被误判
      if (!/[0-9A-Za-z]/.test(beforeChar) && !/[0-9A-Za-z]/.test(afterChar)) {
        return {
          type: 'math',
          raw: inlineDollarMatch[0],
          text: inlineDollarMatch[1].trim(),
          display: false,
          mathType: 'inline',
          tokens: [],
          uniqueId: '',
          isClose: true
        } as MathToken
      }
    }

    // LaTeX 块级公式：\[...\]
    const blockParenMatch = /^\\\[((?:\\.|[^\]])+?)\\\]/.exec(src)
    if (blockParenMatch) {
      return {
        type: 'math',
        raw: blockParenMatch[0],
        text: blockParenMatch[1].trim(),
        display: true,
        mathType: 'block',
        tokens: [],
        uniqueId: '',
        isClose: true
      } as MathToken
    }

    // LaTeX 行内公式：\(...\)
    const inlineParenMatch = /^\\\(((?:\\.|[^\)])+?)\\\)/.exec(src)
    if (inlineParenMatch) {
      return {
        type: 'math',
        raw: inlineParenMatch[0],
        text: inlineParenMatch[1].trim(),
        display: false,
        mathType: 'inline',
        tokens: [],
        uniqueId: '',
        isClose: true
      } as MathToken
    }

    return null
  },

  /**
   * 数学公式渲染器
   * 注意：这里返回原始的 LaTeX 代码，实际渲染在组件中处理
   */
  renderer(token: MathToken): string {
    try {
      // 在 uni-app 环境中，我们不在这里做实际渲染
      // 而是返回一个标记，让组件识别并处理
      const mathClass = token.display ? 'math-display' : 'math-inline'
      return `<span class="${mathClass}" data-math="${encodeURIComponent(token.text)}">${token.text}</span>`
    } catch (err) {
      console.error('数学公式渲染错误:', err)
      return token.text
    }
  }
}

// 全局 marked 实例，注册数学公式扩展
let markedInstance: any = null

/**
 * 获取或创建 marked 实例
 */
function getMarkedInstance(disableKatex: boolean = false) {
  if (!markedInstance || disableKatex) {
    if (disableKatex) {
      // 禁用数学公式时，使用默认的 marked 实例
      markedInstance = useMarked()
    } else {
      // 启用数学公式时，注册数学公式扩展
      markedInstance = useMarked()
      markedInstance.use({ extensions: [mathExtension] })
    }
  }
  return markedInstance
}

/**
 * 渲染 Markdown 配置选项
 */
export interface RenderMarkdownOptions {
  /**
   * 是否禁用 KaTeX 数学公式解析
   * @default false
   */
  disableKatex?: boolean;
  
  /**
   * 其他 marked 配置选项
   */
  markedOptions?: any;
}

/**
 * 渲染 Markdown 文本
 * @param md Markdown 文本
 * @param options 配置选项
 * @returns 解析后的 Token 列表
 */
export function renderMarkdown(md: string, options: RenderMarkdownOptions = {}): MarkdownToken[] {
  const { disableKatex = false, markedOptions = {} } = options
  
  try {
    const marked = getMarkedInstance(disableKatex)
    const tokenList = marked.lexer(md, markedOptions) as TokensList
    return tokenList.tokens as MarkdownToken[]
  } catch (error) {
    console.error('Markdown 解析错误:', error)
    return []
  }
}

/**
 * 检查 Token 是否为数学公式
 */
export function isMathToken(token: MarkdownToken): token is MathToken {
  return token.type === 'math'
}

/**
 * 判断数学公式是否闭合
 * 用于流式解析中的状态判断
 */
export function isMathTokenClosed(token: MathToken, markdownText: string): boolean {
  if (token.mathType === 'block') {
    if (token.raw.startsWith('$$')) {
      // $$...$$ 格式需要结束的 $$
      return markdownText.includes('$$') && markdownText.indexOf('$$', 2) !== -1
    } else if (token.raw.startsWith('\\[')) {
      // \[...\] 格式需要结束的 \]
      return markdownText.includes('\\]')
    }
  } else {
    if (token.raw.startsWith('$')) {
      // $...$ 格式需要结束的 $
      return markdownText.includes('$') && markdownText.indexOf('$', 1) !== -1
    } else if (token.raw.startsWith('\\(')) {
      // \(...\) 格式需要结束的 \)
      return markdownText.includes('\\)')
    }
  }
  return true
}

/**
 * 处理流式解析中的未闭合数学公式
 */
export function handleStreamingMath(src: string): MathToken | null {
  // 未闭合的块级公式 $$...
  const openBlockDollarMatch = /^\$\$([\s\S]*?)$/.exec(src)
  if (openBlockDollarMatch && !src.includes('$$', 2)) {
    return {
      type: 'math',
      raw: openBlockDollarMatch[0],
      text: openBlockDollarMatch[1].trim(),
      display: true,
      mathType: 'block',
      tokens: [],
      uniqueId: '',
      isClose: false
    } as MathToken
  }

  // 未闭合的 LaTeX 块级公式 \[...
  const openBlockParenMatch = /^\\\[([\s\S]*?)$/.exec(src)
  if (openBlockParenMatch && !src.includes('\\]')) {
    return {
      type: 'math',
      raw: openBlockParenMatch[0],
      text: openBlockParenMatch[1].trim(),
      display: true,
      mathType: 'block',
      tokens: [],
      uniqueId: '',
      isClose: false
    } as MathToken
  }

  // 未闭合的行内公式 $...
  const openInlineDollarMatch = /^\$([^\$\n]*?)$/.exec(src)
  if (openInlineDollarMatch && !src.includes('$', 1)) {
    const beforeChar = src.length > 0 ? src[0 - 1] || ' ' : ' '
    if (!/[0-9A-Za-z]/.test(beforeChar)) {
      return {
        type: 'math',
        raw: openInlineDollarMatch[0],
        text: openInlineDollarMatch[1].trim(),
        display: false,
        mathType: 'inline',
        tokens: [],
        uniqueId: '',
        isClose: false
      } as MathToken
    }
  }

  // 未闭合的 LaTeX 行内公式 \(...
  const openInlineParenMatch = /^\\\(([^)]*?)$/.exec(src)
  if (openInlineParenMatch && !src.includes('\\)')) {
    return {
      type: 'math',
      raw: openInlineParenMatch[0],
      text: openInlineParenMatch[1].trim(),
      display: false,
      mathType: 'inline',
      tokens: [],
      uniqueId: '',
      isClose: false
    } as MathToken
  }

  return null
}

/**
 * 用于测试的示例 Markdown 文本
 */
export const SAMPLE_MARKDOWN = `
# 数学公式测试

行内公式：$E=mc^2$  

块级公式：
$$
a^2 + b^2 = c^2
$$  

LaTeX 行内公式：\\( x+y \\)  

LaTeX 块级公式：
\\[
\\frac{1}{n} \\sum_{i=1}^n x_i
\\]  

金额展示：我有 $100 元  
转义写法：\\$100  

行内代码：\`$E=mc^2$\` 不渲染  
代码块：
\`\`\`latex
$$a^2+b^2=c^2$$
\`\`\` 不渲染
`
