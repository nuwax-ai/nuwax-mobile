import { StreamRequestConfig, StreamChunk } from '@/types/interfaces/chat'
import { createSSEConnection } from '@/servers/useRequest.uts'
import { utf8ArrayToString } from '@/utils/utf8.uts'

// 全局错误处理 - 捕获未处理的 AbortError
// #ifdef H5
if (typeof window !== 'undefined') {
  window.addEventListener('unhandledrejection', (event) => {
    if (event.reason && event.reason.name === 'AbortError') {
      console.log('捕获到未处理的 AbortError，已静默处理')
      event.preventDefault() // 阻止默认的错误处理
    }
  })
}
// #endif

// 流式请求工具类
export class StreamRequest {
  private requestTask: RequestTask | null = null
  private isAborted: boolean = false
  private abortController: AbortController | null = null
  private buffer: string = '' // 用于缓存不完整的数据行
  private messageBuffer: string = '' // 用于缓存跨行的完整消息
  private pendingBytes: Uint8Array = new Uint8Array(0) // 用于缓存不完整的 UTF-8 字节序列

  // 发起流式请求
  async request(config: StreamRequestConfig): Promise<void> {
    this.isAborted = false
    this.buffer = '' // 重置缓冲区
    this.messageBuffer = '' // 重置消息缓冲区
    this.pendingBytes = new Uint8Array(0) // 重置字节缓冲区
    
    // #ifdef H5
    // 只在 H5 环境中创建 AbortController
    this.abortController = new AbortController()
    // #endif
    
    try {
      // #ifdef H5
      await this.requestH5(config)
      // #endif
      
      // #ifdef MP-WEIXIN
      await this.requestWeapp(config)
      // #endif
      
      // #ifdef APP-PLUS
      await this.requestApp(config)
      // #endif
      
    } catch (error) {
      // 如果是用户主动中止，不触发错误回调
      // #ifdef H5
      if (error.name === 'AbortError' || this.isAborted) {
        console.log('请求已被中止')
        return
      }
      // #endif
      
      // #ifdef MP-WEIXIN || APP-PLUS
      if (this.isAborted) {
        console.log('请求已被中止')
        return
      }
      // #endif
      
      config.onError?.(error)
    }
  }

  // H5环境下的流式请求
  private async requestH5(config: StreamRequestConfig): Promise<void> {
    // #ifdef H5
    try {
      await createSSEConnection({
        url: config.url,
        method: config.method,
        headers: config.headers as any,
        body: config.body,
        abortController: this.abortController,
        onMessage: (data: any) => {
          if (this.isAborted) return
          
          try {
            // 检查是否完成
            if (data && data.completed) {
              config.onComplete?.()
              return
            }
            
            // 处理数据块
            const chunk: StreamChunk = {
              type: 'content',
              data: data ? JSON.stringify(data) : ''
            }
            config.onChunk?.(chunk)
          } catch (e) {
            console.error('Parse chunk error:', e)
          }
        },
        onError: (error: Error) => {
          // 如果是中止错误，不触发错误回调
          if (error.name === 'AbortError' || this.isAborted) {
            console.log('SSE连接已被中止')
            return
          }
          config.onError?.(error)
        },
        onOpen: (response: any) => {
          console.log('SSE连接已建立:', response)
        },
        onClose: () => {
          console.log('SSE连接已关闭')
        }
      })
    } catch (error) {
      // 捕获所有可能的错误，包括 AbortError
      if (error.message === 'Connection aborted by user' || 
          error.name === 'AbortError' || 
          this.isAborted) {
        console.log('SSE连接已被中止')
        return
      }
      // 只有真正的错误才触发错误回调
      config.onError?.(error)
      throw error // 重新抛出非中止错误
    }
    // #endif
  }

  // 处理完整的 SSE 消息
  private processSSEMessage(content: string, config: StreamRequestConfig, resolve: (value: void | PromiseLike<void>) => void): void {
    // 检查是否完成
    if (content === '[DONE]') {
      console.log('[SSE] 收到完成标记 [DONE]')
      config.onComplete?.()
      resolve()
      return
    }
    
    // 检查是否看起来像 JSON (以 { 或 [ 开头)
    const looksLikeJSON = content.startsWith('{') || content.startsWith('[')
    
    if (looksLikeJSON) {
      // 尝试解析 JSON 数据
      try {
        const data = JSON.parse(content)
        if (data && data.completed) {
          console.log('[SSE] 收到完成标记 completed')
          config.onComplete?.()
          resolve()
          return
        }
        
        // 处理数据块
        const chunk: StreamChunk = {
          type: 'content',
          data: content
        }
        config.onChunk?.(chunk)
      } catch (e) {
        console.log('[SSE] JSON 解析失败，内容:', content)
      }
    } else {
      // 不是 JSON 格式，直接作为内容处理
      const chunk: StreamChunk = {
        type: 'content',
        data: content
      }
      config.onChunk?.(chunk)
    }
  }

  // 处理 UTF-8 字节流，处理分片造成的字符截断问题
  private decodeUTF8(chunk: ArrayBuffer): string {
    const newBytes = new Uint8Array(chunk)
    let combined = newBytes
    
    if (this.pendingBytes.length > 0) {
      combined = new Uint8Array(this.pendingBytes.length + newBytes.length)
      combined.set(this.pendingBytes)
      combined.set(newBytes, this.pendingBytes.length)
      this.pendingBytes = new Uint8Array(0)
    }
    
    if (combined.length === 0) return ''
    
    // 寻找最后一个安全的字节边界
    let safeEnd = combined.length
    let i = combined.length - 1
    let backtrack = 0
    
    // 向前回溯，检查末尾是否被截断
    // UTF-8 最大字符长度为 4 字节
    while (backtrack < 4 && i >= 0) {
      const b = combined[i]
      
      // ASCII (0xxxxxxx) - 字符结束，且是单字节，安全
      if ((b & 0x80) === 0) {
        // 如果我们是回溯过程中遇到的 ASCII，说明之前回溯过的字节（在 ASCII 之后）是孤立的或不完整的？
        // 比如 [ASCII, Cont, Cont]，我们在 Cont 回溯。
        // 遇到 ASCII，说明后面的 Cont 没有 Start byte，是无效的。
        // 但如果是 [ASCII]，backtrack=0，safeEnd=length。
        // 这里的逻辑：遇到 ASCII，说明前面的序列都结束了。
        // 那么从 i+1 到 length 的字节就是我们回溯过的“剩余字节”。
        safeEnd = combined.length - backtrack
        break
      }
      
      // Start byte (11xxxxxx)
      if ((b & 0xC0) === 0xC0) {
        let need = 2
        if ((b & 0xE0) === 0xE0) need = 3
        else if ((b & 0xF0) === 0xF0) need = 4
        
        const have = combined.length - i
        if (have < need) {
          // 不完整，需要保留从 i 开始的所有字节
          safeEnd = i
        } else {
          // 完整
          safeEnd = combined.length
        }
        break
      }
      
      i--
      backtrack++
    }
    
    // 如果 safeEnd 小于总长度，保存剩余字节
    if (safeEnd < combined.length) {
      this.pendingBytes = combined.slice(safeEnd)
      return utf8ArrayToString(combined.slice(0, safeEnd))
    }
    
    return utf8ArrayToString(combined)
  }

  // 微信小程序环境下的流式请求
  private async requestWeapp(config: StreamRequestConfig): Promise<void> {
    // #ifdef MP-WEIXIN
    return new Promise((resolve, reject) => {
      this.requestTask = uni.request({
        url: config.url,
        method: config.method,
        header: config.headers as any,
        data: config.body,
        enableChunked: true, // 启用分块传输
        responseType: 'arraybuffer', // 响应类型
        timeout: 1000*60*60*12, // 设置超时时间为 12小时
        success: (res) => {
          if (res.statusCode === 200) {
            // 流式数据通过 onChunkReceived 接收，success 仅表示请求建立成功
            // 实际的流式数据处理在 onChunkReceived 回调中
            config.onOpen?.(res)
            resolve() // 请求成功建立连接后即可 resolve
          } else {
            reject(new Error(`HTTP error! status: ${res.statusCode}`))
          }
        },
        fail: (err) => {
          if (!this.isAborted) {
            // 忽略超时错误，因为对于长连接流式请求，超时是预期内的行为
            // 只要 connection 还在接收数据，就不应该视为真正的错误
            if (err.errMsg && (err.errMsg.includes('time out') || err.errMsg.includes('timeout'))) {
              console.log('请求超时警告（流式请求正常现象）:', err)
              // 不 reject，也不触发 onError，保持连接继续接收数据
              return
            }

            config.onError?.(err)
            reject(err)
          }
        }
      })
      
      // 监听分块数据接收
      this.requestTask?.onChunkReceived?.((res) => {
        if (this.isAborted) return
        
        try {
          // 使用 decodeUTF8 处理分块数据，解决字符截断问题
          const str = this.decodeUTF8(res.data as ArrayBuffer)
          
          // console.log('[SSE] 接收到分块数据, 长度:', str.length)
          
          // 将新数据添加到缓冲区
          this.buffer += str
          
          // 按行分割，最后一行可能不完整
          const lines = this.buffer.split('\n')
          
          // 保存最后一行（可能不完整）
          this.buffer = lines.pop() || ''
          
          // 处理完整的行
          for (const line of lines) {
            if (line.startsWith('data:')) {
              // 1. 如果有之前缓存的消息，先处理它
              if (this.messageBuffer.length > 0) {
                this.processSSEMessage(this.messageBuffer, config, resolve)
                this.messageBuffer = ''
              }
              
              const content = line.slice(5).trim()
              
              // 检查是否是直接的结束标记
              if (content === '[DONE]') {
                console.log('[SSE] 收到完成标记 [DONE]')
                config.onComplete?.()
                resolve()
                return
              }
              
              this.messageBuffer = content
            } else {
              // 2. 不是 data: 开头，如果是后续行，拼接到当前缓存
              // 只有在已经在接收消息的过程中才拼接
              if (this.messageBuffer.length > 0) {
                this.messageBuffer += '\n' + line
              }
            }
          }
        } catch (error) {
          console.error('处理分块数据失败:', error)
          if (!this.isAborted) {
            config.onError?.(error)
          }
        }
      })
    })
    // #endif
  }

  // App环境下的流式请求
  private async requestApp(config: StreamRequestConfig): Promise<void> {
    // #ifdef APP-PLUS
    return new Promise((resolve, reject) => {
      this.requestTask = uni.request({
        url: config.url,
        method: config.method,
        header: config.headers as any,
        data: config.body,
        success: (res) => {
          if (res.statusCode === 200) {
            // 处理流式响应
            this.handleStreamResponse(res.data as string, config)
            resolve()
          } else {
            reject(new Error(`HTTP error! status: ${res.statusCode}`))
          }
        },
        fail: (err) => {
          if (!this.isAborted) {
            reject(err)
          }
        }
      })
    })
    // #endif
  }

  // 处理流式响应数据
  private handleStreamResponse(data: string, config: StreamRequestConfig): void {
    console.log('[SSE-APP] 处理流式响应数据, 长度:', data.length)
    const lines = data.split('\n')
    
    for (const line of lines) {
      if (line.trim() === '') continue
      
      if (line.startsWith('data:')) {
        const content = line.slice(5).trim()
        
        // 跳过空内容
        if (!content) {
          console.log('[SSE-APP] 跳过空内容行')
          continue
        }
        
        console.log('[SSE-APP] 处理数据行:', content)
        
        // 检查是否完成
        if (content === '[DONE]') {
          console.log('[SSE-APP] 收到完成标记 [DONE]')
          config.onComplete?.()
          return
        }
        
        // 检查是否看起来像 JSON (以 { 或 [ 开头)
        const looksLikeJSON = content.startsWith('{') || content.startsWith('[')
        
        if (looksLikeJSON) {
          // 尝试解析 JSON 数据
          try {
            const parseData = JSON.parse(content)
            if (parseData && parseData.completed) {
              console.log('[SSE-APP] 收到完成标记 completed')
              config.onComplete?.()
              return
            }
          } catch (e) {
            // JSON 解析失败，继续处理为普通数据
            console.log('[SSE-APP] JSON 解析失败，作为普通内容处理')
          }
        } else {
          console.log('[SSE-APP] 非 JSON 格式，直接处理')
        }
        
        // 处理数据块
        try {
          const chunk: StreamChunk = {
            type: 'content',
            data: content
          }
          config.onChunk?.(chunk)
        } catch (e) {
          console.error('[SSE-APP] 处理数据块失败:', e)
        }
      }
    }
  }

  // 中止请求
  abort(): void {
    this.isAborted = true
    this.buffer = '' // 清空缓冲区
    
    // #ifdef H5
    // 中止 H5 的 SSE 连接
    if (this.abortController) {
      this.abortController.abort()
      this.abortController = null
    }
    // #endif
    
    // #ifdef MP-WEIXIN || APP-PLUS
    // 中止小程序和 App 的请求
    if (this.requestTask) {
      this.requestTask.abort()
      this.requestTask = null
    }
    // #endif
  }
}

// 创建流式请求实例
export const streamRequest = new StreamRequest()
