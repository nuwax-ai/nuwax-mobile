import {useMarked, TokensList, NodesToken as MarkdownToken} from '@/uni_modules/kux-marked';
import {IToken, parseCode, ParseCodeRes} from '@/uni_modules/uni-ai-x/sdk/parseCode.uts'
import { 
//   getAllExtensions, 
  isExtensionTokenClosed, 
  isExtensionToken,
//   MathToken,
//   MermaidToken,
//   CustomBlockToken
} from '@/uni_modules/uni-ai-x/sdk/markdownExtensions.uts'
import mathExtension from './marked-katex-extension.uts';

const marked = useMarked()
marked.use(mathExtension({
    nonStandard: true
}));


type UpdateCallBack = (markdownTokenList: MarkdownToken[]) => void

export default class ParseMarkdown {
    updateCallBack: UpdateCallBack
    parseLock: boolean
    readyParseMdIndex: number
    nextTaskTimer: number
    oldMsgBodyLength: number
    parseMdIndex: number
    lastParseLineCodeText: string
    markdownTokenList: MarkdownToken[] = []
    // 新增：解析配置选项
    private options: ParseMarkdownOptions
    constructor(updateCallBack: UpdateCallBack, options: ParseMarkdownOptions = {}) {
        this.updateCallBack = updateCallBack
        this.parseLock = false
        this.readyParseMdIndex = 0
        this.parseMdIndex = 0
        this.lastParseLineCodeText = ''
        this.oldMsgBodyLength = 0
        this.nextTaskTimer = 0
        this.options = {
            disableKatex: false,
            ...options
        }
    }

     /**
     * 静态方法：将 markdown 文本转换为 token 数组
     * @param markdownText markdown 文本内容
     * @returns 返回解析后的 token 数组
     */
    static parseMarkdownToTokens(markdownText: string): MarkdownToken[] {
        if (!markdownText || markdownText.length === 0) {
            return []
        }
        
        // 使用 marked 解析器将 markdown 转换为 token
        const newTokenList: MarkdownToken[] = (marked.lexer(markdownText, null) as TokensList).tokens as MarkdownToken[]
        return newTokenList
    }

    doUpdateCallBack(){
        // 计算拷贝耗时
        // const startTime = Date.now()
        const copyMarkdownTokenList = JSON.parse<MarkdownToken[]>(JSON.stringify(this.markdownTokenList)) as MarkdownToken[]
        // console.log('拷贝耗时', Date.now() - startTime)
        this.updateCallBack(copyMarkdownTokenList)
    }
    
    runTask(msgBody: string, isDelay: boolean = false){
        // 输出当前运行在哪个线程
        // console.log('parseMarkdown.runTask Thread.currentThread().name', Thread.currentThread().name)				
        // console.log('parseMarkdown.runTask msgBody', msgBody, isDelay)				
        if (msgBody.length < this.oldMsgBodyLength) {
            // console.log('Error msgBody.length < oldMsgBodyLength', msgBody.length, this.oldMsgBodyLength)
            // console.log('Error msgBody', msgBody)
            return
        }
        this.oldMsgBodyLength = msgBody.length
        // console.log('runTask', this.oldMsgBodyLength)
        // 清除延迟任务
        if (this.nextTaskTimer != 0) {
            clearTimeout(this.nextTaskTimer)
            this.nextTaskTimer = 0
        }
        if (this.parseLock) {
            // console.log('parseLock', msgBody)
            // 被锁住了，延迟执行
            this.nextTaskTimer = setTimeout(() => {
                this.runTask(msgBody)
            }, 300)
            return
        }
        this.parseLock = true
        // 新增的 markdown 文本
        const newMd = msgBody.slice(this.readyParseMdIndex)
        // 更新准备解析的 markdown 文本 = 新增的 markdown 文本的\n 之前的部分
        this.readyParseMdIndex +=  (newMd.includes('\n') ? newMd.split('\n')[0] + '\n' : newMd).length
        // 拿到本次解析的文本
        let markdownText = msgBody.slice(this.parseMdIndex, this.readyParseMdIndex)
        // console.error('111markdownText', markdownText)
        this.parseCodeTask(markdownText).then((newMarkdownText: string) => {
            // console.log('222newMarkdownText', newMarkdownText)
            this.parseMarkdownTask(newMarkdownText)
            this.parseLock = false
            if (this.readyParseMdIndex < msgBody.length && this.parseMdIndex < msgBody.length) {
                // console.log('未满', msgBody, this.nextTaskTimer)
                // console.log('设置延迟任务')
                this.nextTaskTimer = setTimeout(() => {
                    this.runTask(msgBody, true)
                }, 300)
            }
        })
    }
    // 根据不同类型，判断是否闭合
    isClose(type: string, markdownText: string, token?: MarkdownToken): boolean {
        // 优先检查扩展类型
        if (token && isExtensionToken(token)) {
            return isExtensionTokenClosed(token, markdownText)
        }
        
        // 需要双换行闭合的类型
        const doubleNewlineTypes = ['list', 'table', 'code', 'blockquote']
        // 需要单换行闭合的类型
        const singleNewlineTypes = ['paragraph', 'heading', 'hr',  'def', 'space']
        // 不需要换行闭合的类型
        const noNewlineTypes = ['text', 'strong', 'em', 'del', 'link', 'image', 'codespan']
        
        if (doubleNewlineTypes.includes(type)) {
            return markdownText.includes('\n\n')
        } else if (singleNewlineTypes.includes(type)) {
            return markdownText.includes('\n')
        } else if (noNewlineTypes.includes(type)) {
            return markdownText.includes('\n') == false
        } else {
            // console.error('未找到闭合函数', type, markdownText)
            return false
        }
    }
    parseCodeTask(markdownText: string): Promise<string>{
        return new Promise((resolve) => {
            // 如果 lastToken 是代码块，并且以 ``` 开头 (无序列表不完整时可能会被解析成代码块)，则不继续解析 markdown
            // 从 this.markdownTokenList 中找到第一个未闭合的 codeToken，性能要好
            const codeTokenIndex: number = this.markdownTokenList.findIndex((token: MarkdownToken) => token.type == 'code' && token.isClose == false)
            if (codeTokenIndex == -1) {
                return resolve(markdownText)
            }
            const codeToken: MarkdownToken | null = this.markdownTokenList[codeTokenIndex]
            if (codeToken != null && markdownText.split('\n').length > 1 && markdownText.startsWith('```')) {
                // 更新代码块的 raw 属性
                codeToken.raw = markdownText
                // console.log('markdownText', markdownText)
                // 按行分割第 1 行是 ``` + lang，第 2 行起是代码内容
                const codeTokenArr = markdownText.split('\n')
                // console.error('codeTokenArr', codeTokenArr)
                const lang = codeTokenArr[0].slice(3)
                codeToken.lang = lang
                // console.log('lang', lang, codeToken.lang)
                // 去掉首行和末行的 ``` + 换行符
                let codeText = codeTokenArr.slice(1).join('\n')

                // 找到```+换行符的索引
                const codeEndIndex = codeText.indexOf('```\n')
                if (codeEndIndex != -1) {
                    codeText = codeText.slice(0, codeEndIndex)
                }
                // console.error('codeEndIndex', codeEndIndex, codeText)
                
                const lastLineText = codeTokenArr.slice(-1)[0]
                // console.log('lastLineText', lastLineText)
                if ('```'.includes(lastLineText) && lastLineText != '') {
                    codeText = codeText.slice(0, -1 * lastLineText.length)
                }
                codeToken.text = codeText.trim()


                // console.log('codeToken.codeTokens.length',codeToken.codeTokens!.length)
                // 当前已经解析的代码行数
                const codeTokneLength = codeToken.codeTokens?.length ?? 0
                // 1次只解析1行代码。按行分割代码
                const codeTextArr = codeText.split('\n')
                // 拿到本次要解析的代码
                let lineCodeText: string | null = null;
                // 拿到上一次解析过的那行代码所在位置的新代码
                const lastLineCodeIndex = codeTokneLength == 0 ? 0 : codeTokneLength - 1
                const lastLineCodeNewText: string = codeTextArr[lastLineCodeIndex]
                // 判断上一次解析过的那行代码是否更新了
                const lastLineCodeTextIsUpdate = this.lastParseLineCodeText != lastLineCodeNewText
                // console.log('lastLineCodeTextIsUpdate', lastLineCodeTextIsUpdate)
                let currentLineCodeIndex = lastLineCodeIndex
                if (lastLineCodeTextIsUpdate) {
                    // 如果更新了，设为本次要解析的代码
                    lineCodeText = lastLineCodeNewText
                } else if (codeTokneLength < codeTextArr.length) {
                    // 如果不变说明，应当解析下一行代码
                    currentLineCodeIndex += 1
                    lineCodeText = codeTextArr[currentLineCodeIndex]
                }
                let parseComplete = codeTokneLength == codeTextArr.length
                // console.log('parseComplete codeToken.codeTokens', codeToken.codeTokens)
                // 保存本次要解析的代码
                this.lastParseLineCodeText = lineCodeText ?? ''
                // 3. 解析代码
                if (lineCodeText != null) {
                    parseCode(lineCodeText,lang).then((parseCodeRes: ParseCodeRes) => {
                        const lineCodeToken: IToken[] = parseCodeRes.tokens
                        if (parseCodeRes.error != null) {
                            console.warn(`暂不支持${lang}语言的代码高亮解析，源代码：`, codeText)
                            parseComplete = true
                            markdownText = this.afterParseCodeTask(markdownText, codeEndIndex, codeToken, codeTokenIndex, parseComplete)
                            resolve(markdownText)
                            return
                        } else {
                            lineCodeToken.forEach((item: IToken, index: number) => {
                                item.uniqueId = codeToken.uniqueId + '_r_' + currentLineCodeIndex + '_c_' + index.toString() //+ item.text
                            })
                            if (codeToken.codeTokens == null) {
                                codeToken.codeTokens = [lineCodeToken] as IToken[][]
                            } else if (lastLineCodeTextIsUpdate) {
                                codeToken.codeTokens[codeTokneLength - 1] = lineCodeToken
                                // console.log('更新代码块', codeToken.codeTokens[codeTokneLength - 1])
                            } else {
                                codeToken.codeTokens.push(lineCodeToken)
                            }
                        }
                        // console.log('codeToken.codeTokens.length', codeToken.codeTokens?.length)
                        markdownText = this.afterParseCodeTask(markdownText, codeEndIndex, codeToken, codeTokenIndex, parseComplete)
                        // console.log('markdownText', markdownText)
                        // #ifdef APP-HARMONY
                        nextTick(() => {
                            // console.log('延迟完成代码解析')
                            resolve(markdownText)
                        })
                        // #endif
                        // #ifndef APP-HARMONY
                        resolve(markdownText)
                        // #endif
                    }).catch((error) => {
                        console.warn('代码高亮解析器返回的错误信息：',error)
                        resolve(markdownText)
                    })
                    return // 等待异步解析完成
                }
                markdownText = this.afterParseCodeTask(markdownText, codeEndIndex, codeToken, codeTokenIndex, parseComplete)
                // console.log('markdownText', markdownText)
            }
            return resolve(markdownText)
        })
    }
    afterParseCodeTask(markdownText: string, codeEndIndex: number, codeToken: MarkdownToken, codeTokenIndex: number, parseComplete: boolean): string {
        if (codeEndIndex == -1 || parseComplete == false) {
            this.doUpdateCallBack()
            // console.error('代码还没结束', markdownText, codeEndIndex, parseComplete)
            setTimeout(() => {
                this.runTask(markdownText)
            }, 300)
            return ''
        }
        // 闭合代码块
        codeToken.isClose = true
        this.doUpdateCallBack()
        // 更新代码块的索引
        this.parseMdIndex += markdownText.lastIndexOf('```') + 3
        markdownText = markdownText.slice(this.parseMdIndex)
        // console.log('CompleteParseCodeTask', markdownText)
        return markdownText
    }
    getUniqueId(index: number): string {
        const timestamp: string = Date.now().toString()
        const idx: string = index.toString()
        const randomSuffix: string = Math.floor(Math.random() * 100000).toString().padStart(5, '0')
        return `${timestamp}_${idx}_${randomSuffix}`
    }
    
    // 处理扩展 Token 的特殊逻辑
    handleExtensionToken(token: MarkdownToken) {
        switch (token.type) {
            case 'math':
                const mathToken = token
                // 数学公式的特殊处理逻辑
                this.handleMathToken(mathToken)
                break
            // case 'mermaid':
            //     const mermaidToken = token as MermaidToken
            //     // Mermaid 图表的特殊处理逻辑
            //     this.handleMermaidToken(mermaidToken)
            //     break
            // case 'customBlock':
            //     const customToken = token as CustomBlockToken
            //     // 自定义区块的特殊处理逻辑
            //     this.handleCustomBlockToken(customToken)
            //     break
        }
    }
    
    // 处理数学公式 Token
    handleMathToken(token) {
        // 数学公式的预处理逻辑
        // 验证公式语法、预处理 LaTeX 等
        console.log('处理数学公式:', token.mathType, token.text)
        
        // 如果禁用了 KaTeX，将数学公式当作普通文本处理
        if (this.options.disableKatex) {
            token.type = 'text'
            console.log('KaTeX 已禁用，数学公式转为普通文本')
        }
        
        // 可以在这里添加公式语法验证
        // 例如：检查括号匹配、验证 LaTeX 语法等
    }
    
    // 处理 Mermaid 图表 Token
    handleMermaidToken(token) {
        // 可以在这里添加 Mermaid 图表的预处理逻辑
        // 例如：验证图表语法、预解析图表类型等
        console.log('处理Mermaid图表:', token.chartType, token.code)
    }
    
    // 处理自定义区块 Token
    handleCustomBlockToken(token) {
        // 可以在这里添加自定义区块的预处理逻辑
        // 例如：验证区块类型、处理属性等
        console.log('处理自定义区块:', token.blockType, token.attributes)
    }
    markedLexer(markdownText: string): MarkdownToken[] {
        // 流式模式，使用原有的解析器
        const newTokenList: MarkdownToken[] = (marked.lexer(markdownText,null) as TokensList).tokens as MarkdownToken[]
        newTokenList.forEach((item: MarkdownToken, index: number) => {
            // 时间戳 + 序号 + 随机的 5 位尾数
            item.uniqueId = this.getUniqueId(index)
        })
        return newTokenList
    }
    parseMarkdownTask(markdownText: string){
        // console.log('parseMarkdownTask markdownText========>',markdownText)
        if (markdownText.length == 0) {
            // console.log('markdownText.length == 0')
            return // 空了，不继续执行
        }
        const newTokenList: MarkdownToken[] = this.markedLexer(markdownText)
        if (newTokenList.length == 0) {
            // console.log('newTokenList.length == 0')
            return
        }
        // 第一个新增的元素是否闭合
        let fntIsClose = this.isClose(newTokenList[0]!.type ?? '', markdownText, newTokenList[0])
        newTokenList[0]!.isClose = fntIsClose
        // #ifdef APP-HARMONY
        // TODO：临时方案解决鸿蒙平台的解析错误的 bug。如果是 paragraph 类型，且可能是代码块的开头，即包含 ```+语言名称 + 换行符，例如 ```javascript\n
        if (newTokenList[0]!.type == 'paragraph' && /```[a-zA-Z]+\n/.test(newTokenList[0]!.raw!)) {
            newTokenList[0]!.type = 'code'
            fntIsClose = false
            newTokenList[0]!.isClose = fntIsClose
        }
        // #endif
        
        // 处理扩展类型的特殊逻辑
        if (isExtensionToken(newTokenList[0]!)) {
            this.handleExtensionToken(newTokenList[0]!)
        }
        // console.log('parseMarkdownTask newTokenList', JSON.parse(JSON.stringify(newTokenList)))

        // 解析结果为闭合的，则直接添加到 markdownTokenList 中，否则添加到临时列表中
        // 找到第一个未闭合的项的索引
        const unCloseTokenIndex = this.markdownTokenList.findIndex(token => token.isClose == false || token.isClose == null)
        // console.log('unCloseTokenIndex', unCloseTokenIndex)
        // 更新的 markdown 文本长度差值
        let mdDiffIndex: number = 0
        if (unCloseTokenIndex != -1) {
            // 更新未闭合的旧元素。如果数量更多，需要新增
            for (let i = 0; i < newTokenList.length; i++) {
                const index = unCloseTokenIndex + i
                if (index < this.markdownTokenList.length) {
                    this.markdownTokenList[index] = newTokenList[i]!
                } else {
                    this.markdownTokenList.push(newTokenList[i]!)
                }
                if (fntIsClose) {
                    mdDiffIndex += newTokenList[i]!.raw!.length
                }
            }
        } else {
            if (fntIsClose) {
                mdDiffIndex += newTokenList[0]!.raw!.length
            }
            this.markdownTokenList.push(newTokenList[0]!)
        }
        if (fntIsClose) {
            // console.log('newTokenList[0]', newTokenList[0])
            // 游标向右移动
            this.parseMdIndex += mdDiffIndex
            // 尝试合并后两项，如果合并成功，则删除后两项，并添加合并后的元素
            const mdTLLength = this.markdownTokenList.length
            if (mdTLLength > 1 && newTokenList[0].type == 'paragraph') {
                // 最后2项闭合的 + 所有未闭合的
                const newMdText = this.markdownTokenList[mdTLLength - 2]!.raw! + this.markdownTokenList[mdTLLength - 1]!.raw!
                // console.log('newMdText', newMdText)
                const newTokenList2 = this.markedLexer(newMdText)
                if (newTokenList2.length == 1 && newTokenList2[0]!.type != newTokenList[0].type){
                    this.markdownTokenList[mdTLLength - 2] = newTokenList2[0]!
                    this.markdownTokenList.splice(mdTLLength - 1, 1)
                    // console.log('合并后', JSON.parse(JSON.stringify(this.markdownTokenList)))
                } else {
                    // console.log('合并失败')
                }
            }
            // 所有项都设置为闭合
            for (let unCloseTokenIndex = 0; unCloseTokenIndex < this.markdownTokenList.length; unCloseTokenIndex++) {
                const currentIndex: number = unCloseTokenIndex
                this.markdownTokenList[currentIndex]!.isClose = true
            }
        }
        this.doUpdateCallBack()
    }
}