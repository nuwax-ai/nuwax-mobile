import { StreamRequestConfig, StreamChunk } from '@/types/interfaces/chat'
import { createSSEConnection } from '@/servers/useRequest.uts'

// 全局错误处理 - 捕获未处理的 AbortError
if (typeof window !== 'undefined') {
  window.addEventListener('unhandledrejection', (event) => {
    if (event.reason && event.reason.name === 'AbortError') {
      console.log('捕获到未处理的 AbortError，已静默处理')
      event.preventDefault() // 阻止默认的错误处理
    }
  })
}

// 流式请求工具类
export class StreamRequest {
  private requestTask: RequestTask | null = null
  private isAborted: boolean = false
  private abortController: AbortController | null = null

  // 发起流式请求
  async request(config: StreamRequestConfig): Promise<void> {
    this.isAborted = false
    this.abortController = new AbortController()
    
    try {
      // #ifdef H5
      await this.requestH5(config)
      // #endif
      
      // #ifdef MP-WEIXIN
      await this.requestWeapp(config)
      // #endif
      
      // #ifdef APP-PLUS
      await this.requestApp(config)
      // #endif
      
    } catch (error) {
      // 如果是用户主动中止，不触发错误回调
      if (error.name === 'AbortError' || this.isAborted) {
        console.log('请求已被中止')
        return
      }
      config.onError?.(error)
    }
  }

  // H5环境下的流式请求
  private async requestH5(config: StreamRequestConfig): Promise<void> {
    // #ifdef H5
    try {
      await createSSEConnection({
        url: config.url,
        method: config.method,
        headers: config.headers as any,
        body: config.body,
        abortController: this.abortController,
        onMessage: (data: any) => {
          if (this.isAborted) return
          
          try {
            // 检查是否完成
            if (data && data.completed) {
              config.onComplete?.()
              return
            }
            
            // 处理数据块
            const chunk: StreamChunk = {
              type: 'content',
              data: data ? JSON.stringify(data) : ''
            }
            config.onChunk?.(chunk)
          } catch (e) {
            console.error('Parse chunk error:', e)
          }
        },
        onError: (error: Error) => {
          // 如果是中止错误，不触发错误回调
          if (error.name === 'AbortError' || this.isAborted) {
            console.log('SSE连接已被中止')
            return
          }
          config.onError?.(error)
        },
        onOpen: (response: any) => {
          console.log('SSE连接已建立:', response)
        },
        onClose: () => {
          console.log('SSE连接已关闭')
        }
      })
    } catch (error) {
      // 捕获所有可能的错误，包括 AbortError
      if (error.message === 'Connection aborted by user' || 
          error.name === 'AbortError' || 
          this.isAborted) {
        console.log('SSE连接已被中止')
        return
      }
      // 只有真正的错误才触发错误回调
      config.onError?.(error)
      throw error // 重新抛出非中止错误
    }
    // #endif
  }

  // 微信小程序环境下的流式请求
  private async requestWeapp(config: StreamRequestConfig): Promise<void> {
    // #ifdef MP-WEIXIN
    return new Promise((resolve, reject) => {
      this.requestTask = uni.request({
        url: config.url,
        method: config.method,
        header: config.headers as any,
        data: config.body,
        success: (res) => {
          if (res.statusCode === 200) {
            // 处理流式响应
            this.handleStreamResponse(res.data as string, config)
            resolve()
          } else {
            reject(new Error(`HTTP error! status: ${res.statusCode}`))
          }
        },
        fail: (err) => {
          if (!this.isAborted) {
            reject(err)
          }
        }
      })
    })
    // #endif
  }

  // App环境下的流式请求
  private async requestApp(config: StreamRequestConfig): Promise<void> {
    // #ifdef APP-PLUS
    return new Promise((resolve, reject) => {
      this.requestTask = uni.request({
        url: config.url,
        method: config.method,
        header: config.headers as any,
        data: config.body,
        success: (res) => {
          if (res.statusCode === 200) {
            // 处理流式响应
            this.handleStreamResponse(res.data as string, config)
            resolve()
          } else {
            reject(new Error(`HTTP error! status: ${res.statusCode}`))
          }
        },
        fail: (err) => {
          if (!this.isAborted) {
            reject(err)
          }
        }
      })
    })
    // #endif
  }

  // 处理流式响应数据
  private handleStreamResponse(data: string, config: StreamRequestConfig): void {
    const lines = data.split('\n')
    
    for (const line of lines) {
      if (line.trim() === '') continue
      
      if (line.startsWith('data:')) {
        const content = line.slice(5)
        if (content === '[DONE]') {
          config.onComplete?.()
          return
        }
				try {
				  const parseData = JSON.parse(data)
				  if (parseData.completed) {
				    config.onComplete?.()
				    return
				  }
				} catch (e) {
				  console.error('Parse chunk error:', e)
				}
        
        try {
          const chunk: StreamChunk = {
            type: 'content',
            data: content
          }
          config.onChunk?.(chunk)
        } catch (e) {
          console.error('Parse chunk error:', e)
        }
      }
    }
  }

  // 中止请求
  abort(): void {
    this.isAborted = true
    
    // 中止 H5 的 SSE 连接
    if (this.abortController) {
      this.abortController.abort()
      this.abortController = null
    }
    
    // 中止小程序和 App 的请求
    if (this.requestTask) {
      this.requestTask.abort()
      this.requestTask = null
    }
  }
}

// 创建流式请求实例
export const streamRequest = new StreamRequest()
