<template>
  <view class="voice-recorder-container">
    <!-- 录音按钮 -->
    <view 
      class="voice-button"
      :class="[
        `voice-button--${currentState}`,
        { 'voice-button--pressed': isPressing }
      ]"
      @click="handleClick"
    >
      <!-- 按钮图标 -->
      <view class="voice-icon">
        <uni-icons 
          v-if="currentState === 'default'"
          type="mic" 
          size="16" 
          color="#666"
        />
        <uni-icons 
          v-else-if="currentState === 'recording'"
          type="mic-filled" 
          size="16" 
          color="#fff"
        />
        <uni-icons 
          v-else-if="currentState === 'uploading'"
          type="reload" 
          size="16" 
          color="#fff"
        />
        <uni-icons 
          v-else-if="currentState === 'success'"
          type="checkmarkempty" 
          size="16" 
          color="#fff"
        />
        <uni-icons 
          v-else-if="currentState === 'error'"
          type="closeempty" 
          size="16" 
          color="#fff"
        />
      </view>
      
      <!-- 波形动画 -->
      <view v-if="showWaveform && currentState === 'recording'" class="waveform">
        <view 
          v-for="(bar, index) in waveformBars" 
          :key="index"
          class="waveform-bar"
          :style="{ height: `${bar.height}px`, animationDelay: `${bar.delay}ms` }"
        />
      </view>
    </view>
    
    <!-- 录音时长显示 -->
    <view v-if="currentState === 'recording'" class="recording-duration">
      {{ formatDuration(recordDuration) }}
    </view>
    
    <!-- 状态提示文字 -->
    <view class="voice-tips">
      <text v-if="currentState === 'default'">{{ buttonText }}</text>
      <text v-else-if="currentState === 'recording'">点击停止</text>
      <text v-else-if="currentState === 'uploading'">正在处理...</text>
      <text v-else-if="currentState === 'success'">转换成功</text>
      <text v-else-if="currentState === 'error'">{{ errorMessage }}</text>
    </view>
    
    <!-- 转换结果显示 -->
    <view v-if="transcriptResult && currentState === 'success'" class="transcript-result">
      <text>{{ transcriptResult }}</text>
    </view>
  </view>
</template>

<script lang="uts" setup>
import jzRecorder from '@/uni_modules/jz-h5-recorder-manager'
import { 
  createAudioUploader, 
  type AudioFile as UploaderAudioFile,
  type TranscriptResult as UploaderTranscriptResult,
  type UploadProgress
} from '@/servers/audioUploader'

// 组件Props类型定义
interface VoiceRecorderProps {
  // 录音配置
  duration?: number        // 最大录音时长 (ms)
  format?: string         // 音频格式
  sampleRate?: number     // 采样率
  
  // UI配置
  buttonText?: string     // 按钮文字
  buttonSize?: string     // 按钮尺寸
  showWaveform?: boolean  // 显示波形动画
  
  // 音频上传配置
  useRealApi?: boolean    // 是否使用真实API接口
  apiUrl?: string         // 真实API接口地址
  language?: string       // 语音识别语言
  
  // // 事件回调
  // onRecordStart?: () => void
  // onRecordStop?: (result: string) => void
  // onError?: (error: any) => void
  // onUploadProgress?: (progress: number) => void  // 上传进度回调
}

// 录音状态类型
type RecordState = 'default' | 'recording' | 'uploading' | 'success' | 'error'

// 音频文件接口
interface AudioFile {
  tempFilePath: string
  duration: number
  fileSize: number
  format?: string
}

// 转换结果接口
interface TranscriptResult {
  success: boolean
  text: string
  confidence: number
  duration: number
  error?: string
}

const props = withDefaults(defineProps<VoiceRecorderProps>(), {
  duration: 60000,
  format: 'mp3',
  sampleRate: 44100,
  buttonText: '长按录音',
  buttonSize: '60rpx',
  showWaveform: true,
  useRealApi: false,
  apiUrl: '',
  language: 'zh-CN'
})

const emit = defineEmits<{
  // 事件回调
  onRecordStart?: () => void,
  onRecordStop?: (result: string) => void,
  onError?: (error: any) => void,
  onUploadProgress?: (progress: number) => void  // 上传进度回调
}>()

// 响应式状态
const currentState = ref<RecordState>('default')
const isPressing = ref<boolean>(false)
const recordDuration = ref<number>(0)
const transcriptResult = ref<string>('')
const errorMessage = ref<string>('')

// 录音管理器
let recorderManager: any = null
let durationTimer: any = null

// 音频上传服务
let audioUploadService: any = null // 使用audioUploader

// 波形动画数据
const waveformBars = ref([
  { height: 10, delay: 0 },
  { height: 15, delay: 100 },
  { height: 8, delay: 200 },
  { height: 20, delay: 300 },
  { height: 12, delay: 400 }
])

// 初始化录音管理器
onMounted(() => {
  recorderManager = jzRecorder.getRecorderManager()
  setupRecorderEvents()
  
  // 初始化音频上传服务
  initializeAudioUploadService()
})

// 初始化音频上传服务
const initializeAudioUploadService = () => {
  if (props.useRealApi) {
    // 使用真实API
    if (props.apiUrl) {
      // 创建audioUploader实例，配置真实API
      audioUploadService = createAudioUploader({
        apiUrl: props.apiUrl,
        language: props.language,
        timeout: 30000
      })
      console.log('使用真实API服务:', props.apiUrl)
    } else {
      console.warn('启用了真实API但未配置API地址，将使用模拟服务')
      audioUploadService = createAudioUploader()
      console.log('使用模拟API服务')
    }
  } else {
    // 使用模拟服务
    audioUploadService = createAudioUploader()
    console.log('使用模拟API服务')
  }
}
// 重置状态
const resetState = () => {
  currentState.value = 'default'
  isPressing.value = false
  recordDuration.value = 0
  transcriptResult.value = ''
  errorMessage.value = ''
}

const handleRecordStart = () => {
  console.log('录音开始')
  currentState.value = 'recording'
  startDurationTimer()
  emit('onRecordStart')
}

const handleRecordError = (err: any) => {
    console.error('录音错误', err)
    errorMessage.value = err.errMsg || '录音失败'
    currentState.value = 'error'
    stopDurationTimer()
    // props.onError?.(err)
    emit('onError', err)
    
    // 3秒后重置状态
    setTimeout(() => {
      resetState()
    }, 3000)
  }

  const handleRecordStop = async (res: AudioFile) => {
    console.log('录音停止', res)
    stopDurationTimer()
    
    // 立即显示上传中状态，给用户明确反馈
    currentState.value = 'uploading'
    
    try {
      // 使用音频上传服务转换音频
      const result = await uploadAndConvertWithService(res)
      if (result.success) {
        transcriptResult.value = result.text
        currentState.value = 'success'
        // props.onRecordStop?.(result.text)
        emit('onRecordStop', result.text)
        
        // 2秒后重置状态
        setTimeout(() => {
          resetState()
        }, 2000)
      } else {
        throw new Error(result.error || '转换失败')
      }
    } catch (error: any) {
      handleRecordError(error)
    }
  }

// 设置录音事件监听
const setupRecorderEvents = async() => {
  if (!recorderManager) return
  
  // 录音开始
  recorderManager.onStart(handleRecordStart)
  // 录音错误
  recorderManager.onError(handleRecordError)
  // 录音停止
  recorderManager.onStop(handleRecordStop)
}

// 开始录音时长计时
const startDurationTimer = () => {
  recordDuration.value = 0
  durationTimer = setInterval(() => {
    recordDuration.value += 100
    updateWaveform()
  }, 100)
}

// 点击事件处理
const handleClick = () => {
  console.log('handleClick', currentState.value)
  if (currentState.value === 'default') {
    startRecording()
  } else if (currentState.value === 'recording') {
    stopRecording()
  }
}

// 停止录音时长计时
const stopDurationTimer = () => {
  if (durationTimer) {
    clearInterval(durationTimer)
    durationTimer = null
  }
}

// 更新波形动画
const updateWaveform = () => {
  waveformBars.value = waveformBars.value.map(bar => ({
    ...bar,
    height: Math.random() * 20 + 5
  }))
}

// 格式化录音时长
const formatDuration = (duration: number): string => {
  const seconds = Math.floor(duration / 1000)
  const milliseconds = Math.floor((duration % 1000) / 100)
  return `${seconds}.${milliseconds}s`
}

// 开始录音
const startRecording = () => {
  if (currentState.value !== 'default') return
  
  // 开始录音
  if (recorderManager) {
    try {
      recorderManager.start({
        duration: props.duration,
        sampleRate: props.sampleRate,
        numberOfChannels: 1,
        encodeBitRate: 192000,
        format: props.format
      })
    } catch (error: any) {
      console.error('启动录音失败:', error)
      errorMessage.value = '启动录音失败'
      currentState.value = 'error'
      props.onError?.(error)
    }
  }
}

// 停止录音
const stopRecording = () => {
  if (currentState.value !== 'recording') return
  
  if (recorderManager) {
    try {
      recorderManager.stop()
    } catch (error: any) {
      console.error('停止录音失败:', error)
      errorMessage.value = '停止录音失败'
      currentState.value = 'error'
      props.onError?.(error)
    }
  }
}

// 使用audioUploader转换音频
const uploadAndConvertWithService = async (audioFile: AudioFile): Promise<TranscriptResult> => {
  if (!audioUploadService) {
    throw new Error('音频上传服务未初始化')
  }

  try {
    // 转换音频文件格式
    const uploaderAudioFile: UploaderAudioFile = {
      tempFilePath: audioFile.tempFilePath,
      duration: audioFile.duration,
      fileSize: audioFile.fileSize,
      format: audioFile.format
    }

    // 调用audioUploader的上传方法
    const result = await audioUploadService.uploadAudio(
      uploaderAudioFile,
      (progress: UploadProgress) => {
        // 上传进度回调
        console.log('上传进度:', progress.percent + '%')
        props.onUploadProgress?.(progress.percent)
      }
    )

    // 转换结果格式
    return {
      success: result.success,
      text: result.text,
      confidence: result.confidence,
      duration: result.duration,
      error: result.error
    }
  } catch (error: any) {
    console.error('音频转换服务调用失败:', error)
    throw error
  }
}

// 上传并转换音频 (模拟实现 - 保留作为备用)
const uploadAndConvert = async (audioFile: AudioFile): Promise<TranscriptResult> => {
  // 模拟网络延迟
  await new Promise(resolve => setTimeout(resolve, 1500))
  
  // 模拟转换结果
  const mockTexts = [
    "这是一段测试语音转文本的内容",
    "语音识别功能正在正常工作", 
    "请检查录音质量是否清晰",
    "您好，这是语音转文本测试",
    "录音功能已经成功集成"
  ]
  
  // 模拟成功率
  const isSuccess = Math.random() > 0.1 // 90% 成功率
  
  if (isSuccess) {
    return {
      success: true,
      text: mockTexts[Math.floor(Math.random() * mockTexts.length)],
      confidence: 0.85 + Math.random() * 0.15,
      duration: audioFile.duration
    }
  } else {
    return {
      success: false,
      text: '',
      confidence: 0,
      duration: audioFile.duration,
      error: '网络错误，请重试'
    }
  }
}

// 组件卸载时清理资源
onUnmounted(() => {
  stopDurationTimer()
  if (recorderManager) {
    // 清理事件监听器
    recorderManager.offStart(handleRecordStart)
    recorderManager.offStop(handleRecordStop)
  }
})
</script>

<style lang="scss" scoped>
.voice-recorder-container {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 8rpx;
}

.voice-button {
  position: relative;
  width: 60rpx;
  height: 60rpx;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: row;
  transition: all 0.2s ease;
  user-select: none;
  
  // 默认状态
  &--default {
    background-color: #f5f5f5;
    border: 2rpx solid #ddd;
    
    &:active, &.voice-button--pressed {
      transform: scale(1.1);
      background-color: #ff4d4f;
      border-color: #ff4d4f;
      
      .voice-icon {
        color: #fff !important;
      }
    }
  }
  
  // 录音中状态
  &--recording {
    background-color: #ff4d4f;
    border-color: #ff4d4f;
    animation: recording-pulse 1s infinite;
  }
  
  // 上传中状态
  &--uploading {
    background-color: #1890ff;
    border-color: #1890ff;
    
    .voice-icon {
      animation: loading-spin 1s linear infinite;
    }
  }
  
  // 成功状态
  &--success {
    background-color: #52c41a;
    border-color: #52c41a;
  }
  
  // 错误状态
  &--error {
    background-color: #ff4d4f;
    border-color: #ff4d4f;
  }
}

.voice-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
}

.waveform {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4rpx;
  z-index: 1;
}

.waveform-bar {
  width: 6rpx;
  background-color: rgba(255, 255, 255, 0.8);
  border-radius: 3rpx;
  animation: waveform-bounce 0.6s ease-in-out infinite alternate;
}

.recording-duration {
  font-size: 28rpx;
  color: #ff4d4f;
  font-weight: 500;
}

.voice-tips {
  font-size: 24rpx;
  color: #666;
  text-align: center;
}

.transcript-result {
  max-width: 500rpx;
  padding: 16rpx;
  background-color: #f6ffed;
  border: 1rpx solid #b7eb8f;
  border-radius: 12rpx;
  
  text {
    font-size: 28rpx;
    color: #389e0d;
  }
}

// 动画定义
@keyframes recording-pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 77, 79, 0.7);
  }
  70% {
    box-shadow: 0 0 0 20rpx rgba(255, 77, 79, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(255, 77, 79, 0);
  }
}

@keyframes loading-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes waveform-bounce {
  from {
    transform: scaleY(0.5);
  }
  to {
    transform: scaleY(1.5);
  }
}
</style>