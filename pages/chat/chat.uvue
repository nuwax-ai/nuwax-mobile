<template>
	<view class="chat-box">
		<view class="nav-bar">
			<uni-icons type="left" size="20" color="#000"></uni-icons>
			<text class="chat-title">{{chatTitle}}</text>
			<!-- #ifndef MP-WEIXIN -->
			<addChat></addChat>
			<!-- #endif -->
			<!-- #ifdef MP-WEIXIN -->
			 <!-- 微信小程序端特殊占位 -->
			<view></view>
			<!-- #endif -->
		</view>
		<view class="chat" ref="chat">
			<view class="scroll-view-box">
				<scroll-view 
          direction="vertical"
          class="msg-list" 
          :scroll-into-view="scrollIntoView" 
          id="msg-list"
          :scroll-with-animation="scrollWithAnimation"
          @scroll="onScroll"
          @touchstart="scrollTouch = true"
          @touchend="scrollTouch = false"
				>
					<template v-for="item in msgList" :key="item._id">
						<uni-ai-x-msg v-if="item.from_uid == 'uni-ai'" :msg="item" @longpress="onlongTapMsg(item)" @changeThinkContent="changeThinkContent" :id="'msg-item-' + item._id"></uni-ai-x-msg>
						<text v-else class="user-msg" @longpress="onlongTapMsg(item)">{{item.body}}</text>
					</template>
					<view class="welcome-msg-box" v-if="msgList?.length == 0">
						<image class="logo" src="@/uni_modules/uni-ai-x/static/uni-chat-logo.png"/>
						<text class="title">嗨！我是 UNI-AI</text>
						<text class="text">我可以帮你回答问题、写代码、翻译、写诗等。</text>
					</view>
					<!-- 最后一项，用于快速滚动到最底部 -->
					<view style="height: 35px;" id="last-msg"></view>
				</scroll-view>
				<add-chat-btn :style="{visibility: scrollInBottom && state != 'processing' ? 'visible' : 'hidden'}" class="add-chat-btn" />
				<!-- 滚动到最底部 -->
				<view :style="{visibility: scrollInBottom || scrolling ? 'hidden' : 'visible'}" class="scroll-to-bottom" @click="scrollToLastMsg(true)">
					<uni-icons type="down" size="20" color="#555"></uni-icons>
				</view>
			</view>
			<view class="bottom">
				<textarea class="chat-input" v-model="chatInputContent" placeholder="给 uni-ai-x 发送消息"
					:adjust-position="false" @keyboardheightchange="onKeyboardheightchange" placeholder-class="chat-input-placeholder"
					@focus="scrollToLastMsg(true)" :auto-height="true"
				></textarea>
				<input-tool-bar @scrollToLastMsg="scrollToLastMsg(true)" />
				<!-- 开启键盘时，底部背景高度为键盘高度 -->
				<view class="keyboard-cover" :style="{height: keyboardHeight + 'px'}"></view>
			</view>
		</view>
	</view>
</template>

<script lang="uts" setup>
	import {uniAi, MsgItem, markdownElItem} from '@/uni_modules/uni-ai-x/sdk/'
	import addChat from '@/uni_modules/uni-ai-x/components/add-chat.uvue'
	import addChatBtn from '@/uni_modules/uni-ai-x/components/add-chat-btn.uvue'
	import inputToolBar from '@/uni_modules/uni-ai-x/components/input-tool-bar.uvue'
  import { chatService } from '@/utils/chatService'
  import { markdownParser } from '@/utils/markdownParser'
import { MarkdownConverter } from '@/utils/markdownConverter'

	const keyboardHeight = ref<number>(0)
	const scrollIntoView = ref<string>('')
	const scrollInBottom = ref<boolean>(true)
	const scrollWithAnimation = ref<boolean>(false)
	const scrollTouch = ref<boolean>(false)
	const scrolling = ref<boolean>(false)
	let autoToLastMsg = false
	let scrollingT = 0
	let mouseScroll = false
	let needSetLockAutoToLastMsg = true

  const msgList = ref<MsgItem[]>([])

  import { AgentManualComponentInfo, AgentSelectedComponentInfo } from '@/types/interfaces/agent'
  import { BindConfigWithSub, UploadFileInfo } from '@/types/interfaces/common'
  import { MessageStatusEnum, ProcessingEnum } from '@/types/enums/common'
  import { OpenCloseEnum } from '@/types/enums/space'
  import { RequestResponse } from '@/types/interfaces/request'
  import { MessageModeEnum, ConversationEventTypeEnum, AssistantRoleEnum, MessageTypeEnum } from '@/types/enums/agent'
  import { ConversationInfo, MessageInfo, ConversationChatParams, ConversationChatSuggestParams, ConversationChatResponse, ProcessingInfo, MessageQuestionExtInfo, AttachmentFile } from '@/types/interfaces/conversationInfo'
  import { TempChatCompletionsParams } from '@/types/interfaces/tempChat'
  import { apiAgentConversationChatSuggest, apiAgentConversationCreate } from '@/servers/conversation'
  import { ACCESS_TOKEN } from '@/constants/home.constants'
  import { SUCCESS_CODE } from '@/constants/codes.constants'
  import { v4 as uuidv4 } from 'uuid'
  import { MarkdownElement } from '@/types/interfaces/chat'
  import { NodesToken as MarkdownToken } from '@/uni_modules/kux-marked'

    // 会话信息
	const conversationInfo = ref<ConversationInfo | null>(null)
  // 会话消息ID
  const currentConversationRequestId = ref<string>('')
  // 是否用户问题建议
  const isSuggest = ref<boolean>(false)
  // 会话信息
  const messageList = ref<MessageInfo[]>([])
  // 会话问题建议
  const chatSuggestList = ref<string[]>([])
  // 会话请求ID
  const requestId = ref<string>('')
  // 会话消息ID
  const messageIdRef = ref<string>('')
  // 是否需要更新主题
  const needUpdateTopicRef = ref<boolean>(true)
  // 是否正在加载会话
  const isLoadingConversation = ref<boolean>(false)
  // 会话是否正在进行中（有消息正在处理）
  const isConversationActive = ref<boolean>(false)
  // 添加一个 ref 来控制是否允许自动滚动
  const allowAutoScrollRef = ref<boolean>(true)
  // 是否显示点击下滚按钮
  const showScrollBtn = ref<boolean>(false)
  // 可手动选择的组件列表
  const manualComponents = ref<AgentManualComponentInfo[]>([])
  // 变量参数
  const variables = ref<BindConfigWithSub[]>([])
  // 用户填写的变量参数
  const userFillVariables = ref<{ [key: string]: string | number }>(null)
  // 必填变量参数name列表
  const requiredNameList = ref<string[]>([])
  // 滚动定时器
  const scrollTimeoutRef = ref<number | null>(null);
  const abortConnectionRef = ref<any>(null);
  // 处理中的消息列表
  const processingList = ref<ProcessingInfo[]>([])

  // // 滚动到底部
  // const messageViewScrollToBottom = () => {
  //   // 滚动到底部
  //   // messageViewRef.current?.scrollTo({
  //   //   top: messageViewRef.current?.scrollHeight,
  //   //   behavior: 'smooth',
  //   // });
  // };

  //   // 修改 handleScrollBottom 函数，添加自动滚动控制
  //   const handleScrollBottom = () => {
  //   if (allowAutoScrollRef.value) {
  //     scrollTimeoutRef.value = setTimeout(() => {
  //       // 滚动到底部
  //       messageViewScrollToBottom();
  //     }, 400);
  //   }
  // };

  // 处理变量参数
  const handleVariables = (_variables: BindConfigWithSub[]) => {
    variables.value = _variables;
    // 必填参数name列表
    const _requiredNameList = _variables
      ?.filter(
        (item: BindConfigWithSub) => !item.systemVariable && item.require,
      )
      ?.map((item: BindConfigWithSub) => item.name);
    requiredNameList.value = _requiredNameList || [];
  };

  // 检查会话是否正在进行中（有消息正在处理）
  const checkConversationActive = (messages: MessageInfo[]) => {
    const hasActiveMessage =
      (messages?.length &&
        messages.some(
          (message) =>
            message.status === MessageStatusEnum.Loading ||
            message.status === MessageStatusEnum.Incomplete,
        )) ||
      false;
    isConversationActive.value = hasActiveMessage;
  };

  // 处理查询会话
  const handleQueryConversation = (result: RequestResponse<ConversationInfo>) => {
    isLoadingConversation.value = true;
    const { data } = result;
    conversationInfo.value = data as unknown as ConversationInfo;
    // 是否开启用户问题建议
    isSuggest.value = data?.agent?.openSuggest === OpenCloseEnum.Open;
    // 可手动选择的组件列表
    manualComponents.value = data?.agent?.manualComponents || [];
    // 变量参数
    const _variables = data?.agent?.variables || [];
    // 处理变量参数
    handleVariables(_variables);
    // 用户填写的变量参数
    userFillVariables.value = data?.variables as any;
    // 消息列表
    const _messageList = data?.messageList || [];
    const len = _messageList?.length || 0;
    if (len) {
      messageList.value = _messageList;
      // 检查会话状态
      checkConversationActive(_messageList);
      // 最后一条消息为"问答"时，获取问题建议
      const lastMessage = _messageList[len - 1];
      if (
        lastMessage.type === MessageModeEnum.QUESTION &&
        lastMessage.ext?.length
      ) {
        // 问题建议列表
        const suggestList = lastMessage.ext.map((item) => item.content) || [];
        chatSuggestList.value = suggestList;
      }
      // 如果消息列表大于1时，说明已开始会话，就不显示预置问题，反之显示
      else if (len === 1) {
        // 如果存在预置问题，显示预置问题
        chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
      }
    }
    // 不存在会话消息时，才显示开场白预置问题
    else {
      chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
    }

    // 使用 setTimeout 确保在 DOM 完全渲染后再滚动
    // setTimeout(() => {
    //   // 滚动到底部
    //   messageViewScrollToBottom();
    // }, 800);
  };

  const handleChatProcessingList = (_processingList: ProcessingInfo[]) => {
    //先清空
    // processingList.value = [];

    // 去重逻辑：保留一条，如果status状态不是 EXECUTING，如果成功或者失败都有就仅保留成功
    const processedMap = new Map<string, ProcessingInfo>();

    _processingList.forEach((item) => {
      const key = item.executeId || '';
      const existing = processedMap.get(key);

      if (!existing) {
        // 如果不存在，直接添加
        processedMap.set(key, item);
      } else {
        // 如果已存在，根据状态优先级决定保留哪一个
        // const shouldReplace = shouldReplaceProcessingItem(existing, item);
        // if (shouldReplace) {
        //   processedMap.set(key, item);
        // }
      }
    });

    const newProcessingList = Array.from(processedMap.values()) as ProcessingInfo[];
    processingList.value = newProcessingList;
  };

  // 修改消息列表
  const handleChangeMessageList = async (
    res: ConversationChatResponse,
    // 自定义随机id
    currentMessageId: string,
  ) => {
    const { data, eventType } = res;
    currentConversationRequestId.value = res.requestId;
    if (!messageList.value?.length) {
      return [];
    }
    // timeoutRef.current = setTimeout(() => {
        // 深拷贝消息列表
        const list = [...messageList.value];
        const index = list.findIndex((item) => item.id === currentMessageId);
        // 数组splice方法的第二个参数表示删除的数量，这里我们只需要删除一个元素，所以设置为1， 如果为0，则表示不删除元素。
        let arraySpliceAction = 1;
        // 当前消息
        const currentMessage = list.find(
          (item) => item.id === currentMessageId,
        ) as MessageInfo;
        // 消息不存在时
        if (!currentMessage) {
          // if (timeoutRef.current) {
          //   clearTimeout(timeoutRef.current);
          //   timeoutRef.current = null;
          // }
          // return messageList.value;
        }

        let newMessage: MessageInfo | null = null;

        // 更新UI状态...
        if (eventType === ConversationEventTypeEnum.PROCESSING) {
          const processingResult = data.result || {};
          data.executeId = processingResult.executeId;
          newMessage = {
            ...currentMessage,
            // todo: 需要处理markdown
            // text: getCustomBlock(currentMessage.text || '', data),
            status: MessageStatusEnum.Loading,
            processingList: [
              ...(currentMessage?.processingList || []),
              data,
            ] as ProcessingInfo[],
          };

          handleChatProcessingList([
            ...(currentMessage?.processingList || []),
            { ...data },
          ] as ProcessingInfo[]);
        }
        // MESSAGE事件
        if (eventType === ConversationEventTypeEnum.MESSAGE) {
          const { text, type, ext, id, finished } = data;

          const markdownElements: MarkdownElement[] = markdownParser.parse(text);
          // const markdownElList: markdownElItem[] = markdownElements.map((item) => ({
          //   uniqueId: item.uniqueId,
          //   type: item.type,
          //   datasList: item.datasList,
          // }));
          // if (markdownElements?.[0]?.type !== 'text') {
          //   console.log('text666666', markdownElements?.[0]?.content, markdownElements?.[0]?.type);
          // }

          console.log('markdownElements', markdownElements);

//           export type NodesToken = {
// 	type?: string | null;
// 	raw?: string | null;
// 	text?: string | null;
// 	tokens?: NodesToken[] | null;
// 	checked?: boolean | null;
// 	codeBlockStyle?: 'indented' | null;
// 	lang?: string | null;
// 	escaped?: boolean | null;
// 	tag?: string | null;
// 	href?: string | null;
// 	title?: string | null;
// 	depth?: number | null;
// 	pre?: boolean | null;
// 	block?: boolean | null;
// 	ordered?: boolean | null;
// 	start?: number | string | null;
// 	loose?: boolean | null;
// 	items?: NodesToken[] | null;
// 	task?: boolean | null;
// 	align?: Array<'center' | 'left' | 'right' | null> | null;
// 	header?: TableCell[] | null;
// 	rows?: TableCell[][] | null;
// 	inLink?: boolean | null;
// 	inRawBlock?: boolean | null;
// };

// // Markdown元素类型
// export interface MarkdownElement {
//   type: 'text' | 'code' | 'table' | 'list' | 'heading' | 'paragraph' | 'link' | 'image' | 'hr' | 'blockquote'
//   content: string
//   language?: string
//   level?: number
//   href?: string
//   alt?: string
//   children?: MarkdownElement[]
//   className?: string
// }

          // 使用转换器将MarkdownElement转换为MarkdownToken[][]格式
          const datasList: MarkdownToken[][] = MarkdownConverter.convertToTokenArray(markdownElements)

          const markdownElList: markdownElItem[] = [{
            uniqueId: '1',
            type: 'text',
            datasList,
          }];
          // 思考think
          if (type === MessageModeEnum.THINK) {
            newMessage = {
              ...currentMessage,
              think: `${currentMessage.think}${text}`,
              status: MessageStatusEnum.Incomplete,
            };
          }
          // 问答
          else if (type === MessageModeEnum.QUESTION) {
            newMessage = {
              ...currentMessage,
              text: `${currentMessage.text}${text}`,
              markdownElList,
              // 如果finished为true，则状态为null，此时不会显示运行状态组件，否则为Incomplete
              status: finished ? null : MessageStatusEnum.Incomplete,
            };
            if (ext?.length) {
              // 问题建议
              chatSuggestList.value = (
                ext.map((extItem: MessageQuestionExtInfo) => extItem.content) ||
                  [] as string[]
              );
            }
          } else {
            // 工作流过程输出
            if (
              (!messageIdRef.value || messageIdRef.value !== id) &&
              finished
            ) {
              newMessage = {
                ...currentMessage,
                id,
                text: `${currentMessage.text}${text}`, // 这里需要添加 展示MCP 或者其他工具调用
                markdownElList,
                status: null, // 隐藏运行状态
              };
              // 插入新的消息
              arraySpliceAction = 0;
            } else {
              messageIdRef.value = id;
              newMessage = {
                ...currentMessage,
                text: `${currentMessage.text}${text}`,
                markdownElList,
                status: MessageStatusEnum.Incomplete,
              };
            }
          }
        }
        // FINAL_RESULT事件
        if (eventType === ConversationEventTypeEnum.FINAL_RESULT) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Complete,
            finalResult: data,
            requestId: res.requestId,
          };

          // 调试结果
          requestId.value = res.requestId;
        }
        // ERROR事件
        if (eventType === ConversationEventTypeEnum.ERROR) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Error,
          };
        }

        // 会话事件兼容处理，防止消息为空时，页面渲染报length错误
        if (newMessage) {
          list.splice(index, arraySpliceAction, newMessage as MessageInfo);
        }

        // 检查会话状态
        checkConversationActive(list);

        console.log('list55555', list);
        messageList.value = list;
    // }, 200);
  };

  // 会话处理
  const handleConversation = async (
    params: ConversationChatParams,
    currentMessageId: string,
    // 是否同步会话记录
    // isSync: boolean = true,
  ) => {
    const token = uni.getStorageSync(ACCESS_TOKEN) ?? '';

    try {
      await chatService.sendMessage(
        params,
        // 处理流式数据
        (chunk: string) => {
          const result = JSON.parse(chunk)
          handleChangeMessageList(result, currentMessageId)
          // const {eventType, data} = result;
          // if (eventType !== 'MESSAGE') {
          //   return;
          // }
          // const text = data.text
          // const markdownElements = markdownParser.parse(text);
          // if (markdownElements?.[0]?.type !== 'text') {
          //   console.log('text666666', markdownElements?.[0]?.content, markdownElements?.[0]?.type);
          // }
  
          // if (currentAIMessage.value) {
          //   currentAIMessage.value.content += markdownElements?.[0]?.content ?? ''
          //   scrollToBottom()
          // }
        },
        // 完成回调
        () => {
          // 是否开启问题建议,可用值:Open,Close
          if (isSuggest.value) {
            // runChatSuggest(params as ConversationChatSuggestParams);
            const data = apiAgentConversationChatSuggest(params as ConversationChatSuggestParams);
            // setChatSuggestList(data);
            chatSuggestList.value = data as unknown as string[];
            // handleScrollBottom();
          }
        },
        // 错误回调
        (error: any) => {
          // if (currentAIMessage.value) {
          //   chatService.setMessageError(currentAIMessage.value, error.message || '请求失败')
          // }
          // isLoading.value = false
          // currentAIMessage.value = null
          // console.error('Chat error:', error)
        }
      )
    } catch (error) {
      // isLoading.value = false
      console.error('Chat error:', error)
    }
  };

  // 清除副作用
  const handleClearSideEffect = () => {
    chatSuggestList.value = [];
    // 清除滚动
    if (scrollTimeoutRef.value) {
      clearTimeout(scrollTimeoutRef.value);
      scrollTimeoutRef.value = null;
    }
  };

  // 发送消息
  const onMessageSend = async (
    id: number,
    messageInfo: string,
    files: UploadFileInfo[] = [],
    infos: AgentSelectedComponentInfo[] = [],
    variableParams?: { [key: string]: string | number },
    // debug: boolean = false,
    // // 是否同步会话记录
    // isSync: boolean = true,
  ) => {
    // 清除副作用
    handleClearSideEffect();

    // 附件文件
    const attachments: AttachmentFile[] =
      files?.map((file) => ({
        fileKey: file.key || '',
        fileUrl: file.url || '',
        fileName: file.name || '',
        mimeType: file.type || '',
      })) || [];
	  
	  let chatMessageId: string = '';
	  
	  // #ifdef MP-WEIXIN
	  chatMessageId = uni.getRandomValues({
	    length: 16,
	  }).then(res => res.randomValues.toString()) as string;
	  // #endif
	  
	  // #ifdef H5
	  chatMessageId = uuidv4() as string;
	  // #endif

    // 将文件和消息加入会话中
    const chatMessage = {
      role: AssistantRoleEnum.USER,
      type: MessageModeEnum.CHAT,
      text: messageInfo,
      time: new Date().toISOString(),
      attachments,
      id: chatMessageId,
      messageType: MessageTypeEnum.USER,
    };

    // const currentMessageId = process.env.TARO_ENV === 'weapp' ? await Taro.getRandomValues({
    //   length: 16,
    // }).then(res => res.randomValues.toString()) : uuidv4();

	let currentMessageId: string = '';
    // #ifdef MP-WEIXIN
    currentMessageId = uni.getRandomValues({
      length: 16,
    }).then(res => res.randomValues.toString()) as string;
    // #endif

    // #ifdef H5
    currentMessageId = uuidv4() as string;
    // #endif
    
    // 当前助手信息
    const currentMessage = {
      role: AssistantRoleEnum.ASSISTANT,
      type: MessageModeEnum.CHAT,
      text: '',
      think: '',
      time: new Date().toISOString(),
      id: currentMessageId,
      messageType: MessageTypeEnum.ASSISTANT,
      status: MessageStatusEnum.Loading,
    } as MessageInfo;

    // 将Incomplete状态的消息改为Complete状态
    const completeMessageList =
      messageList.value?.map((item: MessageInfo) => {
        if (item.status === MessageStatusEnum.Incomplete) {
          item.status = MessageStatusEnum.Complete;
        }
        return item;
      }) || [];
    const newMessageList = [
      ...completeMessageList,
      chatMessage,
      currentMessage,
    ] as MessageInfo[];
    checkConversationActive(newMessageList);
    messageList.value = newMessageList;
    // 缓存消息列表
    // messageListRef.current = newMessageList;

    // 允许滚动
    allowAutoScrollRef.value = true;
    // 隐藏点击下滚按钮
    showScrollBtn.value = false;
    // 滚动
    // handleScrollBottom();
    // 会话请求参数
    const params: ConversationChatParams = {
      conversationId: id,
      variableParams,
      message: messageInfo,
      attachments,
      debug: false,
      selectedComponents: infos,
    };
    // 处理会话
    handleConversation(params, currentMessageId);
  };

	onLoad(async () => {
    // 创建会话
    const { code, data } = await apiAgentConversationCreate({
      agentId: 547,
      devMode: true,
    })
    if (code === SUCCESS_CODE) {
      const id = data.id;
      // 发送消息
      onMessageSend(id, '测试发送消息');
    }
	})
	
	const state = computed<string>(() => {
		return uniAi.currentChat?.state ?? 'none'
	})

	const chatInputContent = ref<string>(uniAi.currentChat?.inputContent ?? '')
	
	watch(chatInputContent, (newValue: string) => {
		if (uniAi.currentChat != null) {
			uniAi.currentChat!.inputContent = newValue
		}
	})
	
	watch((): string | null => {
		return uniAi.currentChat?.inputContent ?? null
	}, (newValue: string | null) => {
		if (newValue != null) {
			chatInputContent.value = newValue
		}
	})
	
	const lastMsg = computed<MsgItem | null>(() => {
		return uniAi.lastAiMsg
	})
	
	const chatActiveId = computed<string>(() => {
		return uniAi.chat.activeId
	})
	
	const chatTitle = computed<string>(() => {
		const title = uniAi.currentChat?.title ?? ''
		if (title.length > 0) {
			return title.length > 10 ? title.slice(0, 10) + '...' : title
		}
		return '新对话'
	})
	function scrollToLastMsg(userClick: boolean){
		autoToLastMsg = true
		scrollIntoView.value = ""
		scrollWithAnimation.value = userClick
		nextTick(() => {
			scrollIntoView.value = "last-msg"
			scrollInBottom.value = true
		})
	}
	
	const setIsInScrollBottom = () => {
		nextTick(() => {
			const scrollList = uni.getElementById('msg-list')
			const diff: number = scrollList!.scrollHeight - scrollList!.scrollTop - scrollList!.offsetHeight
			scrollInBottom.value = diff < 30
			if (scrollTouch.value || mouseScroll) {
				autoToLastMsg = !(diff > 3)
			}
		})
	}
	
	watch(scrollInBottom, () => {
		uniAi.canRender = !scrollTouch.value && !scrolling.value
	}, { immediate: true })
	
	watch(scrolling, () => {
		uniAi.canRender = !scrollTouch.value && !scrolling.value
	}, { immediate: true })
	
	watch(chatActiveId, () => {
		scrollToLastMsg(false)
		nextTick(() => {
			if (lastMsg.value != null) lastMsg.value.rendered = true
		})
	}, { deep: true, immediate: true })
	
	const lockAutoToLastMsg = () => {
		if (!needSetLockAutoToLastMsg) return
		const lastMsgEl: UniElement | null = uni.getElementById('msg-item-' + lastMsg.value?._id)
		const scrollList: UniElement | null = uni.getElementById('msg-list')
		if (lastMsgEl == null || scrollList == null) return 
		// if (msgList.value.length < 3 || scrollList.offsetHeight < lastMsgEl.offsetHeight) {
		if (messageList.value.length < 3 || scrollList.offsetHeight < lastMsgEl.offsetHeight) {
			autoToLastMsg = false
			needSetLockAutoToLastMsg = false
		}
	}
	
	watch(lastMsg, async () => {
		setIsInScrollBottom()
		lockAutoToLastMsg()
		if (!scrollTouch.value && autoToLastMsg) {
			await nextTick()
			scrollToLastMsg(false)
		}
	}, { deep: true })
	
	const changeThinkContent = (hideThinkContent: boolean) => {
		setIsInScrollBottom()
	}
	
	const onlongTapMsg = (item: MsgItem) => {
		// console.log('onlongTapMsg', item)
		if (scrolling.value) {
			return
		}
		const itemList = ['复制'] as string[]
		const isAiMsg = item.from_uid == 'uni-ai'
		itemList.push(isAiMsg ? '选择' : '修改')
		uni.showActionSheet({
			itemList,
			success: (res: ShowActionSheetSuccess) => {
				if (res.tapIndex == 0) {
					uni.setClipboardData({
						data: item.body,
						success: () => {
							nextTick(()=>{
								uni.showToast({
									title: '复制成功',
									icon: 'success'
								})
							})
						}
					})
				} else if (res.tapIndex == 1) {
					if (isAiMsg) {
						console.log('选择')
						uni.navigateTo({
							url: '/uni_modules/uni-ai-x/pages/select-text/select-text?msgId=' + item._id,
							fail(err){
								console.error('err', err)
							}
						})
					} else {
						console.log('修改')
						chatInputContent.value = item.body
					}
				}
			},
			fail(err){
			}
		})
	}
	
	const onKeyboardheightchange = (res: UniInputKeyboardHeightChangeEvent) => {
		keyboardHeight.value = res.detail.height
	}
	
	const onScroll = (e: UniScrollEvent) => {
		setIsInScrollBottom()
		scrolling.value = true
		if (scrollingT != 0) {
			clearTimeout(scrollingT)
		}
		scrollingT = setTimeout(() => {
			scrolling.value = false
		}, 500)
	}
	
	onMounted(() => {
		uniAi.onBeforeRequestAi(() => {
			autoToLastMsg = true
			needSetLockAutoToLastMsg = true
			scrollToLastMsg(false)
		})
		// #ifdef H5
		window.addEventListener('wheel', (e: WheelEvent) => {
			mouseScroll = true
			let clear: number = 0
			clear = setTimeout(() => {
				mouseScroll = false
				clearTimeout(clear)
			}, 1000)
		})
		// #endif
	})
</script>

<style lang="scss">
.chat-box {
	width: 750rpx;
  height: 100%;
	padding-top: env(safe-area-inset-top);
	.nav-bar {
		flex-direction: row;
		align-items: center;
		justify-content: space-between;
		padding:10px;
		background-color: #FFF;
		.chat-title {
			font-size: 16px;
		}
		/* #ifdef MP-WEIXIN */
		padding-top: calc(var(--status-bar-height) + 35px);
		/* #endif */
	}
	.chat {
		flex: 1;
		background-color: #FFF;
		.scroll-view-box {
			flex: 1;
			position: relative;
			.msg-list {
				flex: 1;
				.user-msg {
					font-size: 16px;
					margin-left: auto;
					margin-right: 10px;
					margin-bottom: 10px;
					max-width: 600rpx;
					padding: 12px;
					border-radius: 15px 15px 0 15px;
					background-color: #eff6ff;
					/* #ifdef WEB */
					// 可以滑选 用于复制
					cursor: text;
					user-select: text;
					white-space: pre-wrap;
					word-break: break-all;
					/* #endif */;
				}
				.welcome-msg-box {
					margin: auto 20px;
					flex-direction: column;
					align-items: center;
					justify-content: center;
					.logo {
						width: 50px;
						height: 50px;
						margin-bottom: 20px;
					}
					.title {
						font-size: 24px;
						font-weight: bold;
						color: #333;
						margin-bottom: 10px;
					}
					.text {
						font-size: 16px;
						color: #666;
						text-align: center;
						line-height: 24px;
						margin: 0 30px;
					}
				}
			}
			.add-chat-btn {
				position: absolute;
				bottom: 5px;
				left: 50%;
				transform: translateX(-50%);
			}
			.scroll-to-bottom {
				position: absolute;
				bottom: 10px;
				right: 10px;
				width: 35px;
				height: 35px;
				justify-content: center;
				align-items: center;
				background-color: #FFF;
				border-radius: 50px;
				padding: 5px;
				box-shadow: 0 0 10px 0 rgba(0,0,0,0.3);
				// #ifdef APP-HARMONY
				border: 1px solid #efefef;
				// #endif
				z-index: 10;
			}
		}
		.bottom {
			flex-direction: column;
			background-color: #FFF;
			padding: 15px 15px 5px 15px;
			border-radius: 15px 15px 0 0;
			border: 1px solid #eee;
			// box-shadow: 10px 10px 0 0 rgba(0,0,0,0.1);
			.chat-input {
				min-height: 50px;
				max-height: 200px;
				width: 100%;
			}
			.chat-input-placeholder {
				color: #b9babc;
			}
			// 键盘弹出后，垫高底部。默认占位大小为底部安全区域高度
			.keyboard-cover {
				// Android 的键盘高度不包含安全区域高度，其他平台包含
				// #ifdef APP-ANDROID
				margin-bottom: env(safe-area-inset-bottom);
				// #endif
				// #ifndef APP-ANDROID
				padding-bottom: env(safe-area-inset-bottom);
				// #endif
			}
		}
	}
}
</style> 