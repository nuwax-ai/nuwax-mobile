<template>
	<view class="chat-box">
		<view class="nav-bar">
			<uni-icons type="left" size="20" color="#000"></uni-icons>
			<text class="chat-title">{{chatTitle}}</text>
			<!-- #ifndef MP-WEIXIN -->
			<addChat></addChat>
			<!-- #endif -->
			<!-- #ifdef MP-WEIXIN -->
			 <!-- å¾®ä¿¡å°ç¨‹åºç«¯ç‰¹æ®Šå ä½ -->
			<view></view>
			<!-- #endif -->
		</view>
		<view class="chat" ref="chat">
			<view class="scroll-view-box">
				<scroll-view
          direction="vertical"
          class="msg-list" 
          :scroll-into-view="scrollIntoView" 
          id="msg-list"
          :scroll-with-animation="scrollWithAnimation"
          @scroll="onScroll"
          @touchstart="scrollTouch = true"
          @touchend="scrollTouch = false"
				>
					<template v-for="item in msgItemsForRender" :key="item._id">
						<uni-ai-x-msg v-if="item.from_uid == 'uni-ai'" :msg="item" @longpress="onlongTapMsg(item)" @changeThinkContent="changeThinkContent" :id="'msg-item-' + item._id"></uni-ai-x-msg>
						<text v-else class="user-msg" @longpress="onlongTapMsg(item)">{{item.body}}</text>
					</template>
					<view class="welcome-msg-box" v-if="msgItemsForRender?.length == 0">
						<image class="logo" src="@/uni_modules/uni-ai-x/static/uni-chat-logo.png"/>
						<text class="title">å—¨ï¼æˆ‘æ˜¯ UNI-AI</text>
						<text class="text">æˆ‘å¯ä»¥å¸®ä½ å›ç­”é—®é¢˜ã€å†™ä»£ç ã€ç¿»è¯‘ã€å†™è¯—ç­‰ã€‚</text>
						<view class="usage-tip">
							<text class="tip-text">ğŸ’¡ åœ¨ä¸‹æ–¹è¾“å…¥æ¡†ä¸­è¾“å…¥æ‚¨çš„é—®é¢˜ï¼ŒæŒ‰å›è½¦é”®æˆ–ç‚¹å‡»å‘é€æŒ‰é’®å³å¯å¼€å§‹å¯¹è¯</text>
						</view>
					</view>
					<!-- æœ€åä¸€é¡¹ï¼Œç”¨äºå¿«é€Ÿæ»šåŠ¨åˆ°æœ€åº•éƒ¨ -->
					<view style="height: 35px;" id="last-msg"></view>
				</scroll-view>
				<add-chat-btn :style="{visibility: scrollInBottom && state != 'processing' ? 'visible' : 'hidden'}" class="add-chat-btn" />
				<!-- æ»šåŠ¨åˆ°æœ€åº•éƒ¨ -->
				<view :style="{visibility: scrollInBottom || scrolling ? 'hidden' : 'visible'}" class="scroll-to-bottom" @click="scrollToLastMsg(true)">
					<uni-icons type="down" size="20" color="#555"></uni-icons>
				</view>
			</view>
      <chat-input-phone />
			<!-- <view class="bottom"> -->
				<!-- <view class="input-container">
					<textarea class="chat-input" v-model="chatInputContent" placeholder="ç»™ uni-ai-x å‘é€æ¶ˆæ¯"
						:adjust-position="false" @keyboardheightchange="onKeyboardheightchange" placeholder-class="chat-input-placeholder"
						@focus="scrollToLastMsg(true)" :auto-height="true"
						@keydown="onInputKeydown"
					></textarea>
				</view> -->
        <!-- <chat-input-phone /> -->
				<!-- <input-tool-bar /> -->
				<!-- å¼€å¯é”®ç›˜æ—¶ï¼Œåº•éƒ¨èƒŒæ™¯é«˜åº¦ä¸ºé”®ç›˜é«˜åº¦ -->
				<!-- <view class="keyboard-cover" :style="{height: keyboardHeight + 'px'}"></view> -->
			<!-- </view> -->
		</view>
	</view>
</template>

<script lang="uts" setup>
  import {uniAi, MsgItem, markdownElItem} from '@/uni_modules/uni-ai-x/sdk/'
  import addChat from '@/uni_modules/uni-ai-x/components/add-chat.uvue'
  import addChatBtn from '@/uni_modules/uni-ai-x/components/add-chat-btn.uvue'
  import inputToolBar from '@/uni_modules/uni-ai-x/components/input-tool-bar.uvue'
  import uniAiXMsg from '@/uni_modules/uni-ai-x/components/uni-ai-x-msg/uni-ai-x-msg.uvue'
  import uniIcons from '@/uni_modules/uni-icons/components/uni-icons/uni-icons.uvue'
  import { chatService } from '@/utils/chatService'
  import { markdownParser } from '@/utils/markdownParser'
  import { MarkdownConverter } from '@/utils/markdownConverter'
  // å¯¼å…¥SSEæ•°æ®å¤„ç†å™¨
  import { createSSEProcessor, SSEChunk } from '@/utils/sseDataProcessor'
  // å¯¼å…¥Markdownè§£æå™¨
  import ParseMarkdown from '@/uni_modules/uni-ai-x/sdk/parseMarkdown.uts'
  // å¯¼å…¥Markdownç›¸å…³ç±»å‹
  import { NodesToken as MarkdownToken } from '@/uni_modules/kux-marked'
  // å¯¼å…¥treeToListå·¥å…·
  import treeToListSdk from '@/uni_modules/uni-ai-x/sdk/treeToList.uts'
  // å¯¼å…¥ä¼šè¯ç›¸å…³APIå’Œç±»å‹
  import { apiAgentConversationCreate } from '@/servers/conversation.uts'
  import { ConversationCreateParams } from '@/types/interfaces/conversationInfo.uts'

  import ChatInputPhone from '@/components/chat-input-phone/chat-input-phone.uvue'

	// æœ€åæ¥æ”¶çš„SSEæ•°æ®ï¼Œç”¨äºè°ƒè¯•
	const lastSSEData = ref<string>('')
	
	// ä¼šè¯ID
	const conversationId = ref<number | null>(null)

  // å»¶è¿Ÿåˆå§‹åŒ– uniAi
  let uniAiInstance: any = null;
  let isUniAiInitialized = false;

// è·å– uniAi å®ä¾‹çš„å®‰å…¨æ–¹æ³•
const getUniAi = () => {
  if (!isUniAiInitialized) {
    try {
      // å°è¯•ä»å…¨å±€è·å–
      // #ifdef WEB
      if (typeof window !== 'undefined' && (window as any).uniAi) {
        uniAiInstance = (window as any).uniAi;
      }
      // #endif
      
      // å¦‚æœå…¨å±€æ²¡æœ‰ï¼Œå°è¯•ç›´æ¥å¯¼å…¥
      if (!uniAiInstance) {
        uniAiInstance = uniAi;
      }
      
      // æ£€æŸ¥å®ä¾‹æ˜¯å¦æœ‰æ•ˆ
      if (uniAiInstance && typeof uniAiInstance === 'object') {
        isUniAiInitialized = true;
      } else {
        console.error('uniAi å®ä¾‹æ— æ•ˆ');
        return null;
      }
    } catch (error) {
      console.error('åˆå§‹åŒ– uniAi å¤±è´¥:', error);
      return null;
    }
  }
  return uniAiInstance;
};

	const keyboardHeight = ref<number>(0)
	const scrollIntoView = ref<string>('')
	const scrollInBottom = ref<boolean>(true)
	const scrollWithAnimation = ref<boolean>(false)
	const scrollTouch = ref<boolean>(false)
	const scrolling = ref<boolean>(false)
	let autoToLastMsg = false
	let scrollingT = 0
	let mouseScroll = false
	let needSetLockAutoToLastMsg = true

  // æ›¿æ¢åŸæœ‰çš„msgListä¸ºmsgItemsForRenderï¼Œç”¨äºuni-ai-xæ¸²æŸ“
  const msgItemsForRender = ref<MsgItem[]>([])
  // ä¿ç•™åŸæœ‰çš„msgListç”¨äºå…¼å®¹
  const msgList = ref<MsgItem[]>([])

  // ä½¿ç”¨uni-ai-xçš„ParseMarkdownç±»è¿›è¡Œè§£æ
  let parseMarkdownInstance: ParseMarkdown | null = null
  
  // åˆå§‹åŒ–ParseMarkdownå®ä¾‹
  const initParseMarkdown = () => {
    if (!parseMarkdownInstance) {
      parseMarkdownInstance = new ParseMarkdown((markdownTokenList: MarkdownToken[]) => {
        // å°†MarkdownTokenè½¬æ¢ä¸ºmarkdownElItem
        const markdownElList = (markdownTokenList as any[]).map((token: any) => {
          return {
            uniqueId: token.uniqueId || `token_${Date.now()}_${Math.random()}`,
            type: token.type || 'text',
            datasList: treeToListSdk.markTreeToList(token)
          }
        });
        
        // æ›´æ–°æœ€æ–°AIæ¶ˆæ¯çš„markdownElList
        if (msgItemsForRender.value.length > 0) {
          const lastMsg = msgItemsForRender.value[msgItemsForRender.value.length - 1];
          if (lastMsg.from_uid === 'uni-ai') {
            lastMsg.markdownElList = markdownElList;
            // å¼ºåˆ¶è§¦å‘å“åº”å¼æ›´æ–°
            msgItemsForRender.value = [...msgItemsForRender.value];
          }
        }
      });
    }
  };
  
  // ä½¿ç”¨uni-ai-xè§£æå™¨çš„å‡½æ•°
  const parseMarkdownToElList = (text: string, msgId: string): any[] => {
    if (!text || text.trim().length === 0) {
      return [];
    }
    
    // ç¡®ä¿ParseMarkdownå®ä¾‹å·²åˆå§‹åŒ–
    if (!parseMarkdownInstance) {
      initParseMarkdown();
    }
    
    // ä½¿ç”¨ParseMarkdownè§£æ
    parseMarkdownInstance!.runTask(text);
    
    // è¿”å›ç©ºæ•°ç»„ï¼Œå› ä¸ºç»“æœä¼šé€šè¿‡å›è°ƒå¼‚æ­¥æ›´æ–°
    return [];
  };

  import { AgentManualComponentInfo, AgentSelectedComponentInfo } from '@/types/interfaces/agent'
  import { BindConfigWithSub, UploadFileInfo } from '@/types/interfaces/common'
  import { MessageStatusEnum, ProcessingEnum } from '@/types/enums/common'
  import { OpenCloseEnum } from '@/types/enums/space'
  import { RequestResponse } from '@/types/interfaces/request'
  import { MessageModeEnum, ConversationEventTypeEnum, AssistantRoleEnum, MessageTypeEnum } from '@/types/enums/agent'
  import { ConversationInfo, MessageInfo, ConversationChatParams, ConversationChatSuggestParams, ConversationChatResponse, ProcessingInfo, MessageQuestionExtInfo, AttachmentFile } from '@/types/interfaces/conversationInfo'
  import { TempChatCompletionsParams } from '@/types/interfaces/tempChat'
  import { apiAgentConversationChatSuggest } from '@/servers/conversation'
  import { ACCESS_TOKEN } from '@/constants/home.constants'
  import { SUCCESS_CODE } from '@/constants/codes.constants'
  import { v4 as uuidv4 } from 'uuid'
  import { MarkdownElement } from '@/types/interfaces/chat'

    // ä¼šè¯ä¿¡æ¯
	const conversationInfo = ref<ConversationInfo | null>(null)
  // ä¼šè¯æ¶ˆæ¯ID
  const currentConversationRequestId = ref<string>('')
  // æ˜¯å¦ç”¨æˆ·é—®é¢˜å»ºè®®
  const isSuggest = ref<boolean>(false)
  // ä¼šè¯ä¿¡æ¯
  const messageList = ref<MessageInfo[]>([])
  // ä¼šè¯é—®é¢˜å»ºè®®
  const chatSuggestList = ref<string[]>([])
  // ä¼šè¯è¯·æ±‚ID
  const requestId = ref<string>('')
  // ä¼šè¯æ¶ˆæ¯ID
  const messageIdRef = ref<string>('')
  // æ˜¯å¦éœ€è¦æ›´æ–°ä¸»é¢˜
  const needUpdateTopicRef = ref<boolean>(true)
  // æ˜¯å¦æ­£åœ¨åŠ è½½ä¼šè¯
  const isLoadingConversation = ref<boolean>(false)
  // ä¼šè¯æ˜¯å¦æ­£åœ¨è¿›è¡Œä¸­ï¼ˆæœ‰æ¶ˆæ¯æ­£åœ¨å¤„ç†ï¼‰
  const isConversationActive = ref<boolean>(false)
  // æ·»åŠ ä¸€ä¸ª ref æ¥æ§åˆ¶æ˜¯å¦å…è®¸è‡ªåŠ¨æ»šåŠ¨
  const allowAutoScrollRef = ref<boolean>(true)
  // æ˜¯å¦æ˜¾ç¤ºç‚¹å‡»ä¸‹æ»šæŒ‰é’®
  const showScrollBtn = ref<boolean>(false)
  // å¯æ‰‹åŠ¨é€‰æ‹©çš„ç»„ä»¶åˆ—è¡¨
  const manualComponents = ref<AgentManualComponentInfo[]>([])
  // å˜é‡å‚æ•°
  const variables = ref<BindConfigWithSub[]>([])
  // ç”¨æˆ·å¡«å†™çš„å˜é‡å‚æ•°
  const userFillVariables = ref<{ [key: string]: string | number }>(null)
  // å¿…å¡«å˜é‡å‚æ•°nameåˆ—è¡¨
  const requiredNameList = ref<string[]>([])
  // æ»šåŠ¨å®šæ—¶å™¨
  const scrollTimeoutRef = ref<number | null>(null);
  const abortConnectionRef = ref<any>(null);
  // å¤„ç†ä¸­çš„æ¶ˆæ¯åˆ—è¡¨
  const processingList = ref<ProcessingInfo[]>([])
  // SSEæ•°æ®å¤„ç†å™¨
  let sseProcessor: any = null

  // æ»šåŠ¨åˆ°åº•éƒ¨
  // const messageViewScrollToBottom = () => {
  //   // æ»šåŠ¨åˆ°åº•éƒ¨
  //   // messageViewRef.current?.scrollTo({
  //   //   top: messageViewRef.current?.scrollHeight,
  //   //   behavior: 'smooth',
  //   // });
  // };

  //   // ä¿®æ”¹ handleScrollBottom å‡½æ•°ï¼Œæ·»åŠ è‡ªåŠ¨æ»šåŠ¨æ§åˆ¶
  //   const handleScrollBottom = () => {
  //   if (allowAutoScrollRef.value) {
  //     scrollTimeoutRef.value = setTimeout(() => {
  //       // æ»šåŠ¨åˆ°åº•éƒ¨
  //       messageViewScrollToBottom();
  //     }, 400);
  //   }
  // };

  // å¤„ç†å˜é‡å‚æ•°
  const handleVariables = (_variables: BindConfigWithSub[]) => {
    variables.value = _variables;
    // å¿…å¡«å‚æ•°nameåˆ—è¡¨
    const _requiredNameList = _variables
      ?.filter(
        (item: BindConfigWithSub) => !item.systemVariable && item.require,
      )
      ?.map((item: BindConfigWithSub) => item.name);
    requiredNameList.value = _requiredNameList || [];
  };

  // æ£€æŸ¥ä¼šè¯æ˜¯å¦æ­£åœ¨è¿›è¡Œä¸­ï¼ˆæœ‰æ¶ˆæ¯æ­£åœ¨å¤„ç†ï¼‰
  const checkConversationActive = (messages: MessageInfo[]) => {
    const hasActiveMessage =
      (messages?.length &&
        messages.some(
          (message) =>
            message.status === MessageStatusEnum.Loading ||
            message.status === MessageStatusEnum.Incomplete,
        )) ||
      false;
    isConversationActive.value = hasActiveMessage;
  };

  // å¤„ç†æŸ¥è¯¢ä¼šè¯
  const handleQueryConversation = (result: RequestResponse<ConversationInfo>) => {
    isLoadingConversation.value = true;
    const { data } = result;
    conversationInfo.value = data as unknown as ConversationInfo;
    // æ˜¯å¦å¼€å¯ç”¨æˆ·é—®é¢˜å»ºè®®
    isSuggest.value = data?.agent?.openSuggest === OpenCloseEnum.Open;
    // å¯æ‰‹åŠ¨é€‰æ‹©çš„ç»„ä»¶åˆ—è¡¨
    manualComponents.value = data?.agent?.manualComponents || [];
    // å˜é‡å‚æ•°
    const _variables = data?.agent?.variables || [];
    // å¤„ç†å˜é‡å‚æ•°
    handleVariables(_variables);
    // ç”¨æˆ·å¡«å†™çš„å˜é‡å‚æ•°
    userFillVariables.value = data?.variables as any;
    // æ¶ˆæ¯åˆ—è¡¨
    const _messageList = data?.messageList || [];
    const len = _messageList?.length || 0;
    if (len) {
      messageList.value = _messageList;
      // æ£€æŸ¥ä¼šè¯çŠ¶æ€
      checkConversationActive(_messageList);
      // æœ€åä¸€æ¡æ¶ˆæ¯ä¸º"é—®ç­”"æ—¶ï¼Œè·å–é—®é¢˜å»ºè®®
      const lastMessage = _messageList[len - 1];
      if (
        lastMessage.type === MessageModeEnum.QUESTION &&
        lastMessage.ext?.length
      ) {
        // é—®é¢˜å»ºè®®åˆ—è¡¨
        const suggestList = lastMessage.ext.map((item) => item.content) || [];
        chatSuggestList.value = suggestList;
      }
      // å¦‚æœæ¶ˆæ¯åˆ—è¡¨å¤§äº1æ—¶ï¼Œè¯´æ˜å·²å¼€å§‹ä¼šè¯ï¼Œå°±ä¸æ˜¾ç¤ºé¢„ç½®é—®é¢˜ï¼Œåä¹‹æ˜¾ç¤º
      else if (len === 1) {
        // å¦‚æœå­˜åœ¨é¢„ç½®é—®é¢˜ï¼Œæ˜¾ç¤ºé¢„ç½®é—®é¢˜
        chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
      }
    }
    // ä¸å­˜åœ¨ä¼šè¯æ¶ˆæ¯æ—¶ï¼Œæ‰æ˜¾ç¤ºå¼€åœºç™½é¢„ç½®é—®é¢˜
    else {
      chatSuggestList.value = data?.agent?.openingGuidQuestions || [];
    }

    // ä½¿ç”¨ setTimeout ç¡®ä¿åœ¨ DOM å®Œå…¨æ¸²æŸ“åå†æ»šåŠ¨
    // setTimeout(() => {
    //   // æ»šåŠ¨åˆ°åº•éƒ¨
    //   messageViewScrollToBottom();
    // }, 800);
  };

  const handleChatProcessingList = (_processingList: ProcessingInfo[]) => {
    //å…ˆæ¸…ç©º
    // processingList.value = [];

    // å»é‡é€»è¾‘ï¼šä¿ç•™ä¸€æ¡ï¼Œå¦‚æœstatusçŠ¶æ€ä¸æ˜¯ EXECUTINGï¼Œå¦‚æœæˆåŠŸæˆ–è€…å¤±è´¥éƒ½æœ‰å°±ä»…ä¿ç•™æˆåŠŸ
    const processedMap = new Map<string, ProcessingInfo>();

    _processingList.forEach((item) => {
      const key = item.executeId || '';
      const existing = processedMap.get(key);

      if (!existing) {
        // å¦‚æœä¸å­˜åœ¨ï¼Œç›´æ¥æ·»åŠ 
        processedMap.set(key, item);
      } else {
        // å¦‚æœå·²å­˜åœ¨ï¼Œæ ¹æ®çŠ¶æ€ä¼˜å…ˆçº§å†³å®šä¿ç•™å“ªä¸€ä¸ª
        // const shouldReplace = shouldReplaceProcessingItem(existing, item);
        // if (shouldReplace) {
        //   processedMap.set(key, item);
        // }
      }
    });

    const newProcessingList: ProcessingInfo[] = []
    processedMap.forEach((value) => {
      newProcessingList.push(value)
    })
    processingList.value = newProcessingList;
  };

  // ä¿®æ”¹æ¶ˆæ¯åˆ—è¡¨
  const handleChangeMessageList = async (
    res: ConversationChatResponse,
    // è‡ªå®šä¹‰éšæœºid
    currentMessageId: string,
  ) => {
    const { data, eventType } = res;
    currentConversationRequestId.value = res.requestId;
    if (!messageList.value?.length) {
      return [];
    }
    // timeoutRef.current = setTimeout(() => {
        // æ·±æ‹·è´æ¶ˆæ¯åˆ—è¡¨
        const list = [...messageList.value];
        const index = list.findIndex((item) => item.id === currentMessageId);
        // æ•°ç»„spliceæ–¹æ³•çš„ç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºåˆ é™¤çš„æ•°é‡ï¼Œè¿™é‡Œæˆ‘ä»¬åªéœ€è¦åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥è®¾ç½®ä¸º1ï¼Œ å¦‚æœä¸º0ï¼Œåˆ™è¡¨ç¤ºä¸åˆ é™¤å…ƒç´ ã€‚
        let arraySpliceAction = 1;
        // å½“å‰æ¶ˆæ¯
        const currentMessage = list.find(
          (item) => item.id === currentMessageId,
        ) as MessageInfo;
        // æ¶ˆæ¯ä¸å­˜åœ¨æ—¶
        if (!currentMessage) {
          // if (timeoutRef.current) {
          //   clearTimeout(timeoutRef.current);
          //   timeoutRef.current = null;
          // }
          // return messageList.value;
        }

        let newMessage: MessageInfo | null = null;

        // æ›´æ–°UIçŠ¶æ€...
        if (eventType === ConversationEventTypeEnum.PROCESSING) {
          const processingResult = data.result || {};
          data.executeId = processingResult.executeId;
          newMessage = {
            ...currentMessage,
            // todo: éœ€è¦å¤„ç†markdown
            // text: getCustomBlock(currentMessage.text || '', data),
            status: MessageStatusEnum.Loading,
            processingList: [
              ...(currentMessage?.processingList || []),
              data,
            ] as ProcessingInfo[],
          };

          handleChatProcessingList([
            ...(currentMessage?.processingList || []),
            { ...data },
          ] as ProcessingInfo[]);
        }
        // MESSAGEäº‹ä»¶
        if (eventType === ConversationEventTypeEnum.MESSAGE) {
          const { text, type, ext, id, finished } = data;

          const markdownElements: MarkdownElement[] = markdownParser.parse(text);
          // const markdownElList: markdownElItem[] = markdownElements.map((item) => ({
          //   uniqueId: item.uniqueId,
          //   type: item.type,
          //   datasList: item.datasList,
          // }));
          // if (markdownElements?.[0]?.type !== 'text') {
          //   console.log('text666666', markdownElements?.[0]?.content, markdownElements?.[0]?.type);
          // }

          // ä½¿ç”¨è½¬æ¢å™¨å°†MarkdownElementè½¬æ¢ä¸ºMarkdownToken[][]æ ¼å¼
          const datasList: MarkdownToken[][] = MarkdownConverter.convertToTokenArray(markdownElements)

          const markdownElList: markdownElItem[] = [{
            uniqueId: '1',
            type: 'text',
            datasList,
          }];
          // æ€è€ƒthink
          if (type === MessageModeEnum.THINK) {
            newMessage = {
              ...currentMessage,
              think: `${currentMessage.think}${text}`,
              status: MessageStatusEnum.Incomplete,
            };
          }
          // é—®ç­”
          else if (type === MessageModeEnum.QUESTION) {
            newMessage = {
              ...currentMessage,
              text: `${currentMessage.text}${text}`,
              markdownElList,
              // å¦‚æœfinishedä¸ºtrueï¼Œåˆ™çŠ¶æ€ä¸ºnullï¼Œæ­¤æ—¶ä¸ä¼šæ˜¾ç¤ºè¿è¡ŒçŠ¶æ€ç»„ä»¶ï¼Œå¦åˆ™ä¸ºIncomplete
              status: finished ? null : MessageStatusEnum.Incomplete,
            };
            if (ext?.length) {
              // é—®é¢˜å»ºè®®
              chatSuggestList.value = (
                ext.map((extItem: MessageQuestionExtInfo) => extItem.content) ||
                  [] as string[]
              );
            }
          } else {
            // å·¥ä½œæµè¿‡ç¨‹è¾“å‡º
            if (
              (!messageIdRef.value || messageIdRef.value !== id) &&
              finished
            ) {
              newMessage = {
                ...currentMessage,
                id,
                text: `${currentMessage.text}${text}`, // è¿™é‡Œéœ€è¦æ·»åŠ  å±•ç¤ºMCP æˆ–è€…å…¶ä»–å·¥å…·è°ƒç”¨
                markdownElList,
                status: null, // éšè—è¿è¡ŒçŠ¶æ€
              };
              // æ’å…¥æ–°çš„æ¶ˆæ¯
              arraySpliceAction = 0;
            } else {
              messageIdRef.value = id;
              newMessage = {
                ...currentMessage,
                text: `${currentMessage.text}${text}`,
                markdownElList,
                status: MessageStatusEnum.Incomplete,
              };
            }
          }
        }
        // FINAL_RESULTäº‹ä»¶
        if (eventType === ConversationEventTypeEnum.FINAL_RESULT) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Complete,
            finalResult: data,
            requestId: res.requestId,
          };

          // è°ƒè¯•ç»“æœ
          requestId.value = res.requestId;
        }
        // ERRORäº‹ä»¶
        if (eventType === ConversationEventTypeEnum.ERROR) {
          newMessage = {
            ...currentMessage,
            status: MessageStatusEnum.Error,
          };
        }

        // ä¼šè¯äº‹ä»¶å…¼å®¹å¤„ç†ï¼Œé˜²æ­¢æ¶ˆæ¯ä¸ºç©ºæ—¶ï¼Œé¡µé¢æ¸²æŸ“æŠ¥lengthé”™è¯¯
        if (newMessage) {
          list.splice(index, arraySpliceAction, newMessage as MessageInfo);
        }

        // æ£€æŸ¥ä¼šè¯çŠ¶æ€
        checkConversationActive(list);

        messageList.value = list;
    // }, 200);
  };

  // ä¼šè¯å¤„ç†
  const handleConversation = async (
    params: ConversationChatParams,
    currentMessageId: string,
    // æ˜¯å¦åŒæ­¥ä¼šè¯è®°å½•
    // isSync: boolean = true,
  ) => {
    const token = uni.getStorageSync(ACCESS_TOKEN) ?? '';
    
    try {
      // åˆå§‹åŒ–SSEå¤„ç†å™¨
      if (!sseProcessor) {
        sseProcessor = createSSEProcessor('chat-' + params.conversationId)
      }
      
      await chatService.sendMessage(
        params,
        // å¤„ç†æµå¼æ•°æ®
        (chunk: string) => {
          try {
            // è§£æSSEæ•°æ®
            const result = JSON.parse(chunk)
            
            // æ›´æ–°æœ€åæ¥æ”¶çš„SSEæ•°æ®ç”¨äºè°ƒè¯•
            lastSSEData.value = JSON.stringify(result, null, 2)
            
            // ä½¿ç”¨SSEå¤„ç†å™¨å¤„ç†æ•°æ®
            if (sseProcessor && result.eventType === 'MESSAGE') {
              const updatedMessages = sseProcessor.processChunk(result)
              
              // å¼ºåˆ¶æ›´æ–°æ¸²æŸ“åˆ—è¡¨
              msgItemsForRender.value = [...updatedMessages]
              
              // æ»šåŠ¨åˆ°åº•éƒ¨
              scrollToLastMsg(false)
            }
            
            // Direct SSE processing logic added to handleConversation
            if (result.eventType === 'MESSAGE' && result.data) {
              const { id, text, finished } = result.data;
              const existingMsgIndex = msgItemsForRender.value.findIndex(msg =>
                msg._id === id && msg.from_uid === 'uni-ai'
              );
              if (existingMsgIndex !== -1) {
                const existingMsg = msgItemsForRender.value[existingMsgIndex];
                existingMsg.body += text || '';
                
                // ç”Ÿæˆç®€å•çš„markdownElList
                if (existingMsg.body && existingMsg.body.length > 0) {
                  existingMsg.markdownElList = parseMarkdownToElList(existingMsg.body, existingMsg._id);
                }
                
                if (finished) {
                  existingMsg.state = 3;
                }
                msgItemsForRender.value = [...msgItemsForRender.value]; // Force reactive update
              } else {
                const newMsg: MsgItem = {
                  _id: id,
                  from_uid: 'uni-ai',
                  body: text || '',
                  create_time: Date.now(),
                  state: finished ? 3 : 2,
                  chat_id: 'chat-' + params.conversationId,
                  markdownElList: text ? parseMarkdownToElList(text, id) : [],
                  rendered: false
                };
                msgItemsForRender.value.push(newMsg);
              }
              scrollToLastMsg(false);
            }
            
            // åŒæ—¶ä¿æŒåŸæœ‰çš„å¤„ç†é€»è¾‘
            handleChangeMessageList(result, currentMessageId)
          } catch (error) {
            console.error('è§£æSSEæ•°æ®å¤±è´¥:', error, 'åŸå§‹æ•°æ®:', chunk)
          }
        },
        // å®Œæˆå›è°ƒ
        () => {
          // æ˜¯å¦å¼€å¯é—®é¢˜å»ºè®®,å¯ç”¨å€¼:Open,Close
          if (isSuggest.value) {
            // runChatSuggest(params as ConversationChatSuggestParams);
            const data = apiAgentConversationChatSuggest(params as ConversationChatSuggestParams);
            // setChatSuggestList(data);
            chatSuggestList.value = data as unknown as string[];
            // handleScrollBottom();
          }
        },
        // é”™è¯¯å›è°ƒ
        (error: any) => {
          // if (currentAIMessage.value) {
          //   chatService.setMessageError(currentAIMessage.value, error.message || 'è¯·æ±‚å¤±è´¥')
          // }
          // isLoading.value = false
          // currentAIMessage.value = null
          // console.error('Chat error:', error)
        }
      )
    } catch (error) {
      // isLoading.value = false
      console.error('Chat error:', error)
    }
  };

  // æ¸…é™¤å‰¯ä½œç”¨
  const handleClearSideEffect = () => {
    chatSuggestList.value = [];
    // æ¸…é™¤æ»šåŠ¨
    if (scrollTimeoutRef.value) {
      clearTimeout(scrollTimeoutRef.value);
      scrollTimeoutRef.value = null;
    }
  };

  // å‘é€æ¶ˆæ¯
  const onMessageSend = async (
    id: number,
    messageInfo: string,
    files: UploadFileInfo[] = [],
    infos: AgentSelectedComponentInfo[] = [],
    variableParams?: { [key: string]: string | number },
    // debug: boolean = false,
    // // æ˜¯å¦åŒæ­¥ä¼šè¯è®°å½•
    // isSync: boolean = true,
  ) => {
    
    // æ¸…é™¤å‰¯ä½œç”¨
    handleClearSideEffect();

    // é™„ä»¶æ–‡ä»¶
    const attachments: AttachmentFile[] =
      files?.map((file) => ({
        fileKey: file.key || '',
        fileUrl: file.url || '',
        fileName: file.name || '',
        mimeType: file.type || '',
      })) || [];
	  
	  let chatMessageId: string = '';
	  
	  // #ifdef MP-WEIXIN
	  chatMessageId = uni.getRandomValues({
	    length: 16,
	  }).then(res => res.randomValues.toString()) as string;
	  // #endif
	  
	  // #ifdef H5
	  chatMessageId = uuidv4() as string;
	  // #endif

    // å°†æ–‡ä»¶å’Œæ¶ˆæ¯åŠ å…¥ä¼šè¯ä¸­
    const chatMessage = {
      role: AssistantRoleEnum.USER,
      type: MessageModeEnum.CHAT,
      text: messageInfo,
      time: new Date().toISOString(),
      attachments,
      id: chatMessageId,
      messageType: MessageTypeEnum.USER,
    };

	let currentMessageId: string = '';
    // #ifdef MP-WEIXIN
    currentMessageId = uni.getRandomValues({
      length: 16,
    }).then(res => res.randomValues.toString()) as string;
    // #endif

    // #ifdef H5
    currentMessageId = uuidv4() as string;
    // #endif
    
    // å½“å‰åŠ©æ‰‹ä¿¡æ¯
    const currentMessage = {
      role: AssistantRoleEnum.ASSISTANT,
      type: MessageModeEnum.CHAT,
      text: '',
      think: '',
      time: new Date().toISOString(),
      id: currentMessageId,
      messageType: MessageTypeEnum.ASSISTANT,
      status: MessageStatusEnum.Loading,
    } as MessageInfo;

    // å°†IncompleteçŠ¶æ€çš„æ¶ˆæ¯æ”¹ä¸ºCompleteçŠ¶æ€
    const completeMessageList =
      messageList.value?.map((item: MessageInfo) => {
        if (item.status === MessageStatusEnum.Incomplete) {
          item.status = MessageStatusEnum.Complete;
        }
        return item;
      }) || [];
    const newMessageList = [
      ...completeMessageList,
      chatMessage,
      currentMessage,
    ] as MessageInfo[];
    checkConversationActive(newMessageList);
    messageList.value = newMessageList;
    
    // åŒæ—¶æ›´æ–°msgItemsForRenderï¼Œæ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    // åˆ›å»ºç”¨æˆ·æ¶ˆæ¯çš„MsgItem
    const userMsgItem = {
      _id: chatMessageId,
      from_uid: 'user',
      body: messageInfo,
      create_time: Date.now(),
      state: 3, // å®ŒæˆçŠ¶æ€
      chat_id: 'chat-' + id,
      markdownElList: parseMarkdownToElList(messageInfo, chatMessageId),
      rendered: false
    } as MsgItem;
    
    // åˆ›å»ºAIæ¶ˆæ¯å ä½
    const aiMsgItem = {
      _id: currentMessageId,
      from_uid: 'uni-ai',
      body: '',
      create_time: Date.now(),
      state: 2, // æœªå®ŒæˆçŠ¶æ€
      chat_id: 'chat-' + id,
      markdownElList: [],
      rendered: false
    } as MsgItem;
    
    // æ·»åŠ åˆ°æ¸²æŸ“åˆ—è¡¨
    msgItemsForRender.value.push(userMsgItem, aiMsgItem);
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    scrollToLastMsg(false);
    
    // ç¼“å­˜æ¶ˆæ¯åˆ—è¡¨
    // messageListRef.current = newMessageList;

    // å…è®¸æ»šåŠ¨
    allowAutoScrollRef.value = true;
    // éšè—ç‚¹å‡»ä¸‹æ»šæŒ‰é’®
    showScrollBtn.value = false;
    // æ»šåŠ¨
    // handleScrollBottom();
    // ä¼šè¯è¯·æ±‚å‚æ•°
    const params: ConversationChatParams = {
      conversationId: id,
      variableParams,
      message: messageInfo,
      attachments,
      debug: false,
      selectedComponents: infos,
    };
    // å¤„ç†ä¼šè¯
    handleConversation(params, currentMessageId);
  };

	// å¤‡ç”¨çš„æ¶ˆæ¯å‘é€æœºåˆ¶
	const fallbackMessageSend = async (content: string) => {
		if (!conversationId.value) {
			console.error('æ²¡æœ‰ä¼šè¯IDï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
			return;
		}
		
		try {
			// åˆ›å»ºç”¨æˆ·æ¶ˆæ¯
			const userMsg: MsgItem = {
				_id: 'user_' + Date.now(),
				from_uid: 'user',
				body: content,
				create_time: Date.now(),
				state: 3, // å®ŒæˆçŠ¶æ€
				chat_id: 'chat-' + conversationId.value,
				markdownElList: [],
				rendered: false
			};
			
			// åˆ›å»ºAIæ¶ˆæ¯å ä½ç¬¦
			const aiMsg: MsgItem = {
				_id: 'ai_' + Date.now(),
				from_uid: 'uni-ai',
				body: '',
				create_time: Date.now(),
				state: 2, // åŠ è½½çŠ¶æ€
				chat_id: 'chat-' + conversationId.value,
				markdownElList: [],
				rendered: false
			};
			
			// æ·»åŠ åˆ°æ¸²æŸ“åˆ—è¡¨
			msgItemsForRender.value.push(userMsg, aiMsg);
			
			// ä¸­æ­¢ä¹‹å‰çš„è¯·æ±‚ï¼ˆå¦‚æœæœ‰ï¼‰
			if (chatService.abort) {
				chatService.abort();
			}
			
			// ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿çŠ¶æ€é‡ç½®
			await new Promise(resolve => setTimeout(resolve, 100));
			
			// å‡†å¤‡chatService.sendMessageçš„å‚æ•°
			const chatParams = {
				conversationId: conversationId.value,
				message: content,
				messageId: userMsg._id
			};
			
			// è°ƒç”¨chatService.sendMessage
			await chatService.sendMessage(
				chatParams,
				// onChunkå›è°ƒ - å¤„ç†æµå¼æ•°æ®
				(chunk: string) => {
					try {
						// è§£æSSEæ•°æ®
						const result = JSON.parse(chunk);
						
						// æ›´æ–°AIæ¶ˆæ¯å†…å®¹
						if (result.eventType === 'MESSAGE' && result.data) {
							const { text, finished } = result.data;
							if (text) {
								aiMsg.body += text;
								// ä½¿ç”¨uni-ai-xè§£æå™¨æ›´æ–°markdownElList
								aiMsg.markdownElList = parseMarkdownToElList(aiMsg.body, aiMsg._id);
							}
							if (finished) {
								aiMsg.state = 3; // å®ŒæˆçŠ¶æ€
							}
							// å¼ºåˆ¶è§¦å‘å“åº”å¼æ›´æ–°
							msgItemsForRender.value = [...msgItemsForRender.value];
						}
					} catch (error) {
						console.error('è§£æSSEæ•°æ®å¤±è´¥:', error);
					}
				},
				// onCompleteå›è°ƒ
				() => {
					aiMsg.state = 3; // è®¾ç½®ä¸ºå®ŒæˆçŠ¶æ€
					msgItemsForRender.value = [...msgItemsForRender.value];
				},
				// onErrorå›è°ƒ
				(error: any) => {
					console.error('chatService.sendMessage é”™è¯¯:', error);
					aiMsg.state = 4; // è®¾ç½®ä¸ºé”™è¯¯çŠ¶æ€
					msgItemsForRender.value = [...msgItemsForRender.value];
					
					// å¦‚æœæ˜¯å¹¶å‘è¯·æ±‚é”™è¯¯ï¼Œå°è¯•é‡æ–°å‘é€
					if (error.message && error.message.includes('å·²æœ‰è¯·æ±‚æ­£åœ¨è¿›è¡Œä¸­')) {
						setTimeout(() => {
							fallbackMessageSend(content);
						}, 500);
					}
				}
			);
			
		} catch (error) {
			console.error('å¤‡ç”¨æ¶ˆæ¯å‘é€å¤±è´¥:', error);
		}
	};

	onLoad((options: any) => {
		// åˆå§‹åŒ–ParseMarkdown
		initParseMarkdown();
		
		// åˆ›å»ºä¼šè¯å¹¶å¤„ç†
		createConversationAndHandle();
	})
	
	// åˆ›å»ºä¼šè¯å¹¶å¤„ç†
	const createConversationAndHandle = async () => {
		try {
			const conversationParams: ConversationCreateParams = {
				agentId: 547,
				devMode: true
			};
			
			const { code, data } = await apiAgentConversationCreate(conversationParams);
			
			if (code === SUCCESS_CODE && data && data.id) {
				conversationId.value = data.id;
				
				// åˆå§‹åŒ–SSEå¤„ç†å™¨
				if (!sseProcessor) {
					sseProcessor = createSSEProcessor('chat-' + data.id);
				}
			} else {
				console.error('ä¼šè¯åˆ›å»ºå¤±è´¥ï¼Œé”™è¯¯ç :', code);
				// è®¾ç½®ä¸€ä¸ªä¸´æ—¶ä¼šè¯IDç”¨äºæµ‹è¯•
				conversationId.value = Date.now();
			}
		} catch (error) {
			console.error('åˆ›å»ºä¼šè¯è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
			conversationId.value = Date.now();
		}
	}
	
	const state = computed<string>(() => {
		return uniAi.currentChat?.state ?? 'none'
	})

	const chatInputContent = ref<string>(uniAi.currentChat?.inputContent ?? '')
	
	watch(chatInputContent, (newValue: string) => {
		if (uniAi.currentChat != null) {
			uniAi.currentChat!.inputContent = newValue
		}
	})
	
	watch((): string | null => {
		return uniAi.currentChat?.inputContent ?? null
	}, (newValue: string | null) => {
		if (newValue != null) {
			chatInputContent.value = newValue
		}
	})
	
	const lastMsg = computed<MsgItem | null>(() => {
		return uniAi.lastAiMsg
	})
	
	const chatActiveId = computed<string>(() => {
		return uniAi.chat.activeId
	})
	
	const chatTitle = computed<string>(() => {
		const title = uniAi.currentChat?.title ?? ''
		if (title.length > 0) {
			return title.length > 10 ? title.slice(0, 10) + '...' : title
		}
		return 'æ–°å¯¹è¯'
	})
	function scrollToLastMsg(userClick: boolean){
		autoToLastMsg = true
		scrollIntoView.value = ""
		scrollWithAnimation.value = userClick
		nextTick(() => {
			scrollIntoView.value = "last-msg"
			scrollInBottom.value = true
		})
	}
	
	const setIsInScrollBottom = () => {
		nextTick(() => {
			const scrollList = uni.getElementById('msg-list')
			const diff: number = scrollList!.scrollHeight - scrollList!.scrollTop - scrollList!.offsetHeight
			scrollInBottom.value = diff < 30
			if (scrollTouch.value || mouseScroll) {
				autoToLastMsg = !(diff > 3)
			}
		})
	}
	
	watch(scrollInBottom, () => {
		uniAi.canRender = !scrollTouch.value && !scrolling.value
	}, { immediate: true })
	
	watch(scrolling, () => {
		uniAi.canRender = !scrollTouch.value && !scrolling.value
	}, { immediate: true })
	
	watch(chatActiveId, () => {
		scrollToLastMsg(false)
		nextTick(() => {
			if (lastMsg.value != null) lastMsg.value.rendered = true
		})
	}, { deep: true, immediate: true })
	
	const lockAutoToLastMsg = () => {
		if (!needSetLockAutoToLastMsg) return
		const lastMsgEl: UniElement | null = uni.getElementById('msg-item-' + lastMsg.value?._id)
		const scrollList: UniElement | null = uni.getElementById('msg-list')
		if (lastMsgEl == null || scrollList == null) return 
		// if (msgList.value.length < 3 || scrollList.offsetHeight < lastMsgEl.offsetHeight) {
		if (messageList.value.length < 3 || scrollList.offsetHeight < lastMsgEl.offsetHeight) {
			autoToLastMsg = false
			needSetLockAutoToLastMsg = false
		}
	}
	
	watch(lastMsg, async () => {
		setIsInScrollBottom()
		lockAutoToLastMsg()
		if (!scrollTouch.value && autoToLastMsg) {
			await nextTick()
			scrollToLastMsg(false)
		}
	}, { deep: true })
	
	const changeThinkContent = (hideThinkContent: boolean) => {
		setIsInScrollBottom()
	}
	
	// é•¿æŒ‰æ¶ˆæ¯
	const onlongTapMsg = (item: any) => {
		// æ˜¾ç¤ºæ“ä½œèœå•
	}
		
	// é€‰æ‹©æ¶ˆæ¯
	const onSelectMsg = (item: any) => {
		// é€‰æ‹©æ¶ˆæ¯é€»è¾‘
	}
		
	// ä¿®æ”¹æ¶ˆæ¯
	const onEditMsg = (item: any) => {
		// ä¿®æ”¹æ¶ˆæ¯é€»è¾‘
	}
	
	const onKeyboardheightchange = (res: UniInputKeyboardHeightChangeEvent) => {
		keyboardHeight.value = res.detail.height
	}
	
	const onScroll = (e: UniScrollEvent) => {
		setIsInScrollBottom()
		scrolling.value = true
		if (scrollingT != 0) {
			clearTimeout(scrollingT)
		}
		scrollingT = setTimeout(() => {
			scrolling.value = false
		}, 500)
	}

	const onInputKeydown = (e: UniApp.KeyboardEvent) => {
		if (e.keyCode === 13) { // Enteré”®
			// ä½¿ç”¨æˆ‘ä»¬çš„å¤‡ç”¨æ¶ˆæ¯å‘é€æœºåˆ¶
			if (chatInputContent.value.trim()) {
				if (conversationId.value) {
					fallbackMessageSend(chatInputContent.value);
					chatInputContent.value = '';
				} else {
					// å…ˆåˆ›å»ºä¼šè¯ï¼Œç„¶åå‘é€æ¶ˆæ¯
					createConversationAndHandle().then(() => {
						if (conversationId.value) {
							fallbackMessageSend(chatInputContent.value);
							chatInputContent.value = '';
						}
					});
				}
			}
		}
	};
	
	// å®‰å…¨çš„å‘é€æ¶ˆæ¯æ–¹æ³•
	const safeSendMessage = async (content: string) => {
		try {
			// ç›´æ¥ä½¿ç”¨å¤‡ç”¨æœºåˆ¶ï¼Œé¿å…è°ƒç”¨æœ‰é—®é¢˜çš„uniAi.sendMsg
			await fallbackMessageSend(content);
		} catch (error) {
			console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
			// å¦‚æœå¤‡ç”¨æœºåˆ¶ä¹Ÿå¤±è´¥ï¼Œè‡³å°‘åˆ›å»ºç”¨æˆ·æ¶ˆæ¯
			if (conversationId.value) {
				const userMsg: MsgItem = {
					_id: 'user_' + Date.now(),
					from_uid: 'user',
					body: content,
					create_time: Date.now(),
					state: 3,
					chat_id: 'chat-' + conversationId.value,
					markdownElList: [],
					rendered: false
				};
				msgItemsForRender.value.push(userMsg);
			}
		}
	};
	
	onMounted(() => {
		// å»¶è¿Ÿåˆå§‹åŒ–uniAi
		setTimeout(() => {
			initUniAi();
		}, 1000);
	})
	
	// åˆå§‹åŒ– uniAi
	const initUniAi = () => {
		const uniAi = getUniAi();
		if (!uniAi) {
			console.error('æ— æ³•è·å– uniAi å®ä¾‹ï¼Œè·³è¿‡åˆå§‹åŒ–');
			return;
		}
		
		// æ£€æŸ¥å¹¶ä¿®å¤ uniAi.currentUser
		if (!uniAi.currentUser || !uniAi.currentUser._id) {
			uniAi.currentUser = {
				_id: 'tmp_user_' + Date.now(),
				name: 'ä¸´æ—¶ç”¨æˆ·',
				avatar: '',
				email: ''
			};
		}
		
		// è¦†ç›– uniAi.sendMsg æ–¹æ³•
		const originalSendMsg = uniAi.sendMsg;
		uniAi.sendMsg = async (inputContent: string = '') => {
			// å†æ¬¡æ£€æŸ¥ currentUser
			if (!uniAi.currentUser || !uniAi.currentUser._id) {
				console.error('currentUser ä»ç„¶æœªå®šä¹‰ï¼Œä½¿ç”¨ä¸´æ—¶å€¼');
				uniAi.currentUser = {
					_id: 'tmp_user_' + Date.now(),
					name: 'ä¸´æ—¶ç”¨æˆ·',
					avatar: '',
					email: ''
				};
			}
			
			if (inputContent && conversationId.value) {
				// ç¡®ä¿ conversationId æ˜¯ number ç±»å‹
				const convId = typeof conversationId.value === 'string' ? parseInt(conversationId.value) : conversationId.value;
				onMessageSend(convId, inputContent);
			} else {
				// ä¸å†è°ƒç”¨åŸå§‹çš„ sendMsgï¼Œç›´æ¥ä½¿ç”¨å¤‡ç”¨æœºåˆ¶
				await fallbackMessageSend(inputContent);
			}
		};
	};
	
	onUnmounted(() => {
		// ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
		uni.$off('input-tool-bar-send');
	});
</script>

<style lang="scss">
.chat-box {
	width: 750rpx;
  height: 100%;
	padding-top: env(safe-area-inset-top);
	.nav-bar {
		flex-direction: row;
		align-items: center;
		justify-content: space-between;
		padding:10px;
		background-color: #FFF;
		.chat-title {
			font-size: 16px;
		}
		/* #ifdef MP-WEIXIN */
		padding-top: calc(var(--status-bar-height) + 35px);
		/* #endif */
	}
	.chat {
		flex: 1;
		background-color: #FFF;
		.scroll-view-box {
			flex: 1;
			position: relative;
			.msg-list {
				flex: 1;
				.user-msg {
					font-size: 16px;
					margin-left: auto;
					margin-right: 10px;
					margin-bottom: 10px;
					max-width: 600rpx;
					padding: 12px;
					border-radius: 15px 15px 0 15px;
					background-color: #eff6ff;
					/* #ifdef WEB */
					// å¯ä»¥æ»‘é€‰ ç”¨äºå¤åˆ¶
					cursor: text;
					user-select: text;
					white-space: pre-wrap;
					word-break: break-all;
					/* #endif */;
				}
				.welcome-msg-box {
					margin: auto 20px;
					flex-direction: column;
					align-items: center;
					justify-content: center;
					.logo {
						width: 50px;
						height: 50px;
						margin-bottom: 20px;
					}
					.title {
						font-size: 24px;
						font-weight: bold;
						color: #333;
						margin-bottom: 10px;
					}
					.text {
						font-size: 16px;
						color: #666;
						text-align: center;
						line-height: 24px;
						margin: 0 30px;
					}
					.usage-tip {
						margin-top: 20px;
						padding: 10px 15px;
						background-color: #f0f0f0;
						border-radius: 8px;
						border: 1px solid #e0e0e0;
						.tip-text {
							font-size: 12px;
							color: #666;
							text-align: center;
						}
					}
				}
			}
			.add-chat-btn {
				position: absolute;
				bottom: 5px;
				left: 50%;
				transform: translateX(-50%);
			}
			.scroll-to-bottom {
				position: absolute;
				bottom: 10px;
				right: 10px;
				width: 35px;
				height: 35px;
				justify-content: center;
				align-items: center;
				background-color: #FFF;
				border-radius: 50px;
				padding: 5px;
				box-shadow: 0 0 10px 0 rgba(0,0,0,0.3);
				// #ifdef APP-HARMONY
				border: 1px solid #efefef;
				// #endif
				z-index: 10;
			}
		}
		.bottom {
			background-color: #FFF;
			padding: 15px 0 5px 0;
			border-radius: 15px 15px 0 0;
			border: 1px solid #eee;

			.input-container {
				background-color: #f8f9fa;
				border-radius: 20px;
				padding: 8px 12px;
				margin-bottom: 10px;
				border: 1px solid #e9ecef;
				
				.chat-input {
					width: 100%;
					min-height: 40px;
					max-height: 120px;
					padding: 8px 12px;
					font-size: 16px;
					line-height: 20px;
					background-color: transparent;
					border: none;
					outline: none;
				}
			}
			.chat-input-placeholder {
				color: #b9babc;
			}
			// é”®ç›˜å¼¹å‡ºåï¼Œå«é«˜åº•éƒ¨ã€‚é»˜è®¤å ä½å¤§å°ä¸ºåº•éƒ¨å®‰å…¨åŒºåŸŸé«˜åº¦
			.keyboard-cover {
				// Android çš„é”®ç›˜é«˜åº¦ä¸åŒ…å«å®‰å…¨åŒºåŸŸé«˜åº¦ï¼Œå…¶ä»–å¹³å°åŒ…å«
				// #ifdef APP-ANDROID
				margin-bottom: env(safe-area-inset-bottom);
				// #endif
				// #ifndef APP-ANDROID
				padding-bottom: env(safe-area-inset-bottom);
				// #endif
			}
		}
	}
}
</style> 