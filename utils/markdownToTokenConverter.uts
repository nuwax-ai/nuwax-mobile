import { MarkdownElement } from '@/types/interfaces/chat'
import { NodesToken as MarkdownToken } from '@/uni_modules/kux-marked'

// MarkdownElement到MarkdownToken[][]的转换器
export class MarkdownToTokenConverter {
  
  // 将MarkdownElement数组转换为MarkdownToken[][]格式
  static convertToTokenArray(elements: MarkdownElement[]): MarkdownToken[][] {
    const result: MarkdownToken[][] = []
    
    for (const element of elements) {
      const tokens = this.convertElementToTokens(element)
      if (tokens.length > 0) {
        result.push(tokens)
      }
    }
    
    return result
  }
  
  // 将单个MarkdownElement转换为MarkdownToken数组
  private static convertElementToTokens(element: MarkdownElement): MarkdownToken[] {
    const tokens: MarkdownToken[] = []
    
    switch (element.type) {
      case 'text':
        tokens.push(this.createTextToken(element.content))
        break
        
      case 'heading':
        tokens.push(this.createHeadingToken(element.content, element.level || 1))
        break
        
      case 'code':
        tokens.push(this.createCodeToken(element.content, element.language || ''))
        break
        
      case 'list':
        tokens.push(this.createListToken(element.content))
        break
        
      case 'blockquote':
        tokens.push(this.createBlockquoteToken(element.content))
        break
        
      case 'hr':
        tokens.push(this.createHrToken())
        break
        
      case 'link':
        tokens.push(this.createLinkToken(element.content, element.href || ''))
        break
        
      case 'image':
        tokens.push(this.createImageToken(element.content, element.href || '', element.alt || ''))
        break
        
      default:
        // 对于未知类型，作为普通文本处理
        tokens.push(this.createTextToken(element.content))
        break
    }
    
    return tokens
  }
  
  // 创建文本token
  private static createTextToken(text: string): MarkdownToken {
    return {
      type: 'text',
      raw: text,
      text: text,
      tokens: null
    }
  }
  
  // 创建标题token
  private static createHeadingToken(text: string, depth: number): MarkdownToken {
    const prefix = '#'.repeat(depth)
    const raw = `${prefix} ${text}`
    
    return {
      type: 'heading',
      raw: raw,
      text: text,
      depth: depth,
      tokens: [this.createTextToken(text)]
    }
  }
  
  // 创建代码token
  private static createCodeToken(text: string, lang: string): MarkdownToken {
    const raw = lang ? `\`\`\`${lang}\n${text}\n\`\`\`` : `\`\`\`\n${text}\n\`\`\``
    
    return {
      type: 'code',
      raw: raw,
      text: text,
      lang: lang || null,
      codeBlockStyle: null,
      escaped: false,
      tokens: null
    }
  }
  
  // 创建列表token
  private static createListToken(text: string): MarkdownToken {
    const raw = `- ${text}`
    
    return {
      type: 'list',
      raw: raw,
      text: text,
      ordered: false,
      start: null,
      loose: false,
      items: [{
        type: 'list_item',
        raw: raw,
        text: text,
        task: false,
        checked: null,
        loose: false,
        tokens: [this.createTextToken(text)]
      }],
      tokens: null
    }
  }
  
  // 创建引用token
  private static createBlockquoteToken(text: string): MarkdownToken {
    const raw = `> ${text}`
    
    return {
      type: 'blockquote',
      raw: raw,
      text: text,
      tokens: [this.createTextToken(text)]
    }
  }
  
  // 创建分割线token
  private static createHrToken(): MarkdownToken {
    return {
      type: 'hr',
      raw: '---',
      text: null,
      tokens: null
    }
  }
  
  // 创建链接token
  private static createLinkToken(text: string, href: string): MarkdownToken {
    const raw = `[${text}](${href})`
    
    return {
      type: 'link',
      raw: raw,
      text: text,
      href: href,
      title: null,
      tokens: [this.createTextToken(text)]
    }
  }
  
  // 创建图片token
  private static createImageToken(alt: string, src: string, title: string): MarkdownToken {
    const raw = title ? `![${alt}](${src} "${title}")` : `![${alt}](${src})`
    
    return {
      type: 'image',
      raw: raw,
      text: alt,
      href: src,
      title: title || null,
      tokens: null
    }
  }
  
  // 批量转换多个元素
  static convertElementsToTokenArray(elements: MarkdownElement[]): MarkdownToken[][] {
    return this.convertToTokenArray(elements)
  }
  
  // 从markdown文本直接转换
  static convertFromMarkdownText(markdownText: string): MarkdownToken[][] {
    // 这里可以集成更复杂的markdown解析逻辑
    // 暂时使用简单的行分割方式
    const lines = markdownText.split('\n')
    const elements: MarkdownElement[] = []
    
    for (const line of lines) {
      const trimmedLine = line.trim()
      if (!trimmedLine) continue
      
      if (trimmedLine.startsWith('#')) {
        // 标题
        const level = trimmedLine.match(/^#+/)?.[0].length || 1
        const content = trimmedLine.replace(/^#+\s*/, '')
        elements.push({
          type: 'heading',
          content: content,
          level: level
        })
      } else if (trimmedLine.startsWith('- ')) {
        // 列表
        const content = trimmedLine.replace(/^-\s*/, '')
        elements.push({
          type: 'list',
          content: content
        })
      } else if (trimmedLine.startsWith('> ')) {
        // 引用
        const content = trimmedLine.replace(/^>\s*/, '')
        elements.push({
          type: 'blockquote',
          content: content
        })
      } else if (trimmedLine === '---') {
        // 分割线
        elements.push({
          type: 'hr',
          content: ''
        })
      } else {
        // 普通文本
        elements.push({
          type: 'text',
          content: trimmedLine
        })
      }
    }
    
    return this.convertToTokenArray(elements)
  }
}

// 导出转换器实例
export const markdownToTokenConverter = new MarkdownToTokenConverter()
