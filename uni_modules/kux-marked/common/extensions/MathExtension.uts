import { TokenizerExtension, MathToken } from '../../utssdk/ExtensionTokens.interface';
import { NodesToken } from '../../utssdk/Tokens.interface';
import { I_Lexer } from '../../utssdk/Lexer.interface';

/**
 * 数学公式扩展实现
 * 支持行内数学公式和块级数学公式的解析
 */

/**
 * 行内数学公式扩展 - 支持 $formula$ 和 \(formula\) 语法
 */
export const mathInlineExtension: TokenizerExtension = {
	name: 'mathInline',
	level: 'inline',
	priority: 100,
	tokenizer: (lexer: I_Lexer, src: string, tokens: NodesToken[]): NodesToken | null => {
		// 匹配 $...$ 语法
		const dollarMatch = /^\$([^\$\n]+?)\$/.exec(src);
		if (dollarMatch && dollarMatch.length > 1) {
			return {
				type: 'math',
				raw: dollarMatch[0],
				text: dollarMatch[1].trim(),
				display: false,
				mathType: 'inline',
				tokens: [] as NodesToken[]
			} as MathToken;
		}
		
		// 匹配 \(...\) 语法
		const parenMatch = /^\\\(([^\\]*?)\\\)/.exec(src);
		if (parenMatch && parenMatch.length > 1) {
			return {
				type: 'math',
				raw: parenMatch[0],
				text: parenMatch[1].trim(),
				display: false,
				mathType: 'inline',
				tokens: [] as NodesToken[]
			} as MathToken;
		}
		
		return null;
	}
};

/**
 * 块级数学公式扩展 - 支持 $$formula$$ 和 \[formula\] 语法
 */
export const mathBlockExtension: TokenizerExtension = {
	name: 'mathBlock',
	level: 'block',
	priority: 90,
	tokenizer: (lexer: I_Lexer, src: string, tokens: NodesToken[]): NodesToken | null => {
		// 匹配 $$...$$ 语法
		const dollarMatch = /^(\${2,})([\s\S]*?)\1/.exec(src);
		if (dollarMatch && dollarMatch.length > 2) {
			return {
				type: 'math',
				raw: dollarMatch[0],
				text: dollarMatch[2].trim(),
				display: true,
				mathType: 'block',
				tokens: [] as NodesToken[]
			} as MathToken;
		}
		
		// 匹配 \[...\] 语法
		const bracketMatch = /^\\\[([\s\S]*?)\\\]/.exec(src);
		if (bracketMatch && bracketMatch.length > 1) {
			return {
				type: 'math',
				raw: bracketMatch[0],
				text: bracketMatch[1].trim(),
				display: true,
				mathType: 'block',
				tokens: [] as NodesToken[]
			} as MathToken;
		}
		
		return null;
	}
};

/**
 * 获取所有数学公式扩展
 * @returns 数学公式扩展数组
 */
export function getMathExtensions(): TokenizerExtension[] {
	return [mathInlineExtension, mathBlockExtension];
}

/**
 * 检测文本是否包含数学公式
 * @param text 要检测的文本
 * @returns 是否包含数学公式
 */
export function hasMathFormula(text: string): boolean {
	// 检测 $ 语法
	const dollarPattern = /\$[^\$\n]+?\$/;
	if (dollarPattern.test(text)) {
		return true;
	}
	
	// 检测 \( \) 语法
	const parenPattern = /\\\([^\\]*?\\\)/;
	if (parenPattern.test(text)) {
		return true;
	}
	
	// 检测 $$ 语法
	const doubleDollarPattern = /\${2,}[\s\S]*?\${2,}/;
	if (doubleDollarPattern.test(text)) {
		return true;
	}
	
	// 检测 \[ \] 语法
	const bracketPattern = /\\\[[\s\S]*?\\\]/;
	if (bracketPattern.test(text)) {
		return true;
	}
	
	return false;
}

/**
 * 提取文本中的所有数学公式
 * @param text 源文本
 * @returns 数学公式数组
 */
export function extractMathFormulas(text: string): Array<{ formula: string; type: 'inline' | 'block'; syntax: string }> {
	const formulas: Array<{ formula: string; type: 'inline' | 'block'; syntax: string }> = [];
	
	// 提取 $...$ 公式
	const dollarMatches = text.match(/\$([^\$\n]+?)\$/g);
	if (dollarMatches) {
		dollarMatches.forEach(match => {
			const formula = match.replace(/^\$|\$$/g, '').trim();
			formulas.push({ formula, type: 'inline', syntax: '$' });
		});
	}
	
	// 提取 \(...\) 公式
	const parenMatches = text.match(/\\\(([^\\]*?)\\\)/g);
	if (parenMatches) {
		parenMatches.forEach(match => {
			const formula = match.replace(/^\\\(|\\\)$/g, '').trim();
			formulas.push({ formula, type: 'inline', syntax: '\\(' });
		});
	}
	
	// 提取 $$...$$ 公式
	const doubleDollarMatches = text.match(/\${2,}([\s\S]*?)\${2,}/g);
	if (doubleDollarMatches) {
		doubleDollarMatches.forEach(match => {
			const formula = match.replace(/^\${2,}|\${2,}$/g, '').trim();
			formulas.push({ formula, type: 'block', syntax: '$$' });
		});
	}
	
	// 提取 \[...\] 公式
	const bracketMatches = text.match(/\\\[([\s\S]*?)\\\]/g);
	if (bracketMatches) {
		bracketMatches.forEach(match => {
			const formula = match.replace(/^\\\[|\\\]$/g, '').trim();
			formulas.push({ formula, type: 'block', syntax: '\\[' });
		});
	}
	
	return formulas;
}