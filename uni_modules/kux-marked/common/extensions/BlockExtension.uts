import { TokenizerExtension, ContainerToken } from '../../utssdk/ExtensionTokens.interface';
import { NodesToken } from '../../utssdk/Tokens.interface';
import { I_Lexer } from '../../utssdk/Lexer.interface';

/**
 * 自定义区块扩展实现
 * 支持容器区块的解析
 */

/**
 * 容器区块扩展 - 支持 ::: type 语法
 */
export const containerExtension: TokenizerExtension = {
	name: 'container',
	level: 'block',
	priority: 60,
	tokenizer: (lexer: I_Lexer, src: string, tokens: NodesToken[]): NodesToken | null => {
		// 匹配 ::: type 语法 - 支持单行和多行格式
		// 单行格式: :::type attr1="value1" attr2="value2":::
		// 多行格式: :::type attr1="value1"\ncontent\n:::
		const singleLineMatch = /^:::\s*(\w+)(?:\s+([^:\n]*?))?:::(?:\n|$)/.exec(src);
		const multiLineMatch = /^:::\s*(\w+)(?:\s+([^:\n]*?))?(?:\n([\s\S]*?))\n:::(?:\n|$)/.exec(src);
		
		// 优先尝试单行匹配，如果没有换行符的话
		const containerMatch = singleLineMatch || multiLineMatch;

		if (containerMatch && containerMatch.length > 1) {
			const containerType = containerMatch[1];
			const content = containerMatch[2] || '';//把属性 解析为对象 "executeId=\"bea8c141395341c7ab0b0375fb77226c\" type=\"Mcp\" status=\"EXECUTING\" name=\"get_hot_data\""
			const data = content.split(' ').reduce((acc, item) => {
				const [key, value] = item.split('=');
				acc[key] = value.replace(/^"|"$/g, '');
				return acc;
			}, {});
			return {
				type: 'container',
				raw: containerMatch[0],
				text: content.trim(),
				containerType: containerType,
				title: data.name,
				data: data,
				tokens: []
			} as ContainerToken;
		}
		
		return null;
	}
};

/**
 * 获取所有自定义区块扩展
 * @returns 自定义区块扩展数组
 */
export function getBlockExtensions(): TokenizerExtension[] {
	return [containerExtension];
}

/**
 * 检测文本是否包含容器区块
 * @param text 要检测的文本
 * @returns 是否包含容器区块
 */
export function hasContainerBlock(text: string): boolean {
	// 支持单行和多行容器格式
	const singleLinePattern = /^:::\s*\w+(?:\s+[^:\n]*?)?:::/m;
	const multiLinePattern = /^:::\s*\w+(?:\s+[^:\n]*?)?\n[\s\S]*?\n:::/m;
	return singleLinePattern.test(text) || multiLinePattern.test(text);
}

/**
 * 提取文本中的所有容器区块
 * @param text 源文本
 * @returns 容器区块数组
 */
export function extractContainerBlocks(text: string): Array<{ type: string; title: string; content: string; raw: string }> {
	const containers: Array<{ type: string; title: string; content: string; raw: string }> = [];
	
	// 匹配所有容器区块 - 支持单行和多行格式
	const singleLineMatches = text.match(/^:::\s*(\w+)(?:\s+([^:\n]*?))?:::/gm);
	const multiLineMatches = text.match(/^:::\s*(\w+)(?:\s+([^:\n]*?))?\n([\s\S]*?)\n:::/gm);
	
	// 处理单行容器
	if (singleLineMatches) {
		singleLineMatches.forEach(match => {
			const containerMatch = /^:::\s*(\w+)(?:\s+([^:\n]*?))?:::/m.exec(match);
			if (containerMatch && containerMatch.length > 1) {
				const containerType = containerMatch[1];
				const title = containerMatch[2] || '';
				containers.push({
					type: containerType,
					title: title.trim(),
					content: '',
					raw: match
				});
			}
		});
	}
	
	// 处理多行容器
	if (multiLineMatches) {
		multiLineMatches.forEach(match => {
			const containerMatch = /^:::\s*(\w+)(?:\s+([^:\n]*?))?\n([\s\S]*?)\n:::/m.exec(match);
			if (containerMatch && containerMatch.length > 1) {
				const containerType = containerMatch[1];
				const title = containerMatch[2] || '';
				const content = containerMatch[3] || '';
				containers.push({
					type: containerType,
					title: title.trim(),
					content: content.trim(),
					raw: match
				});
			}
		});
	}
	
	return containers;
}

/**
 * 获取支持的容器类型列表
 * @returns 容器类型数组
 */
export function getSupportedContainerTypes(): Array<{ type: string; name: string; description: string }> {
	return [
		{ type: 'tip', name: '提示', description: '提示信息容器' },
		{ type: 'warning', name: '警告', description: '警告信息容器' },
		{ type: 'danger', name: '危险', description: '危险信息容器' },
		{ type: 'info', name: '信息', description: '一般信息容器' },
		{ type: 'details', name: '详情', description: '可折叠的详细信息' },
		{ type: 'quote', name: '引用', description: '引用内容容器' },
		{ type: 'code', name: '代码', description: '代码示例容器' },
		{ type: 'example', name: '示例', description: '示例内容容器' }
	];
}

/**
 * 验证容器类型
 * @param type 容器类型
 * @returns 是否为有效类型
 */
export function isValidContainerType(type: string): boolean {
	const validTypes = ['tip', 'warning', 'danger', 'info', 'details', 'quote', 'code', 'example'];
	return validTypes.includes(type.toLowerCase());
}