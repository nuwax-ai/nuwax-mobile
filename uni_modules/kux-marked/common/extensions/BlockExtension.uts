import { TokenizerExtension, AlertToken, ContainerToken } from '../../utssdk/ExtensionTokens.interface';
import { NodesToken } from '../../utssdk/Tokens.interface';
import { I_Lexer } from '../../utssdk/Lexer.interface';

/**
 * è‡ªå®šä¹‰åŒºå—æ‰©å±•å®ç°
 * æ”¯æŒè­¦å‘Š/æç¤ºæ¡†å’Œå®¹å™¨åŒºå—çš„è§£æ
 */

/**
 * è­¦å‘Š/æç¤ºæ¡†æ‰©å±• - æ”¯æŒGitHubé£æ ¼çš„ > [!TYPE] è¯­æ³•
 */
export const alertExtension: TokenizerExtension = {
	name: 'alert',
	level: 'block',
	priority: 70,
	tokenizer: (lexer: I_Lexer, src: string, tokens: NodesToken[]): NodesToken | null => {
		// åŒ¹é… > [!TYPE] è¯­æ³•
		const alertMatch = /^> \[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]\n((?:> .*(?:\n|$))*)/i.exec(src);
		if (alertMatch && alertMatch.length > 2) {
			const alertType = alertMatch[1].toLowerCase();
			const content = alertMatch[2].replace(/^> /gm, '').trim();
			
			return {
				type: 'alert',
				raw: alertMatch[0],
				text: content,
				alertType: alertType as 'note' | 'tip' | 'important' | 'warning' | 'caution',
				tokens: content.length > 0 ? lexer.blockTokens(content, [], null) : []
			} as AlertToken;
		}
		
		return null;
	}
};

/**
 * å®¹å™¨åŒºå—æ‰©å±• - æ”¯æŒ ::: type è¯­æ³•
 */
export const containerExtension: TokenizerExtension = {
	name: 'container',
	level: 'block',
	priority: 60,
	tokenizer: (lexer: I_Lexer, src: string, tokens: NodesToken[]): NodesToken | null => {
		// åŒ¹é… ::: type è¯­æ³•
		const containerMatch = /^:::\s*(\w+)(?:\s+(.*))?(?:\n([\s\S]*?))?\n:::(?:\n|$)/.exec(src);
		if (containerMatch && containerMatch.length > 1) {
			const containerType = containerMatch[1];
			const title = containerMatch[2] || '';
			const content = containerMatch[3] || '';
			
			return {
				type: 'container',
				raw: containerMatch[0],
				text: content.trim(),
				containerType: containerType,
				title: title.trim(),
				tokens: content.trim().length > 0 ? lexer.blockTokens(content.trim(), [], null) : []
			} as ContainerToken;
		}
		
		return null;
	}
};

/**
 * è·å–æ‰€æœ‰è‡ªå®šä¹‰åŒºå—æ‰©å±•
 * @returns è‡ªå®šä¹‰åŒºå—æ‰©å±•æ•°ç»„
 */
export function getBlockExtensions(): TokenizerExtension[] {
	return [alertExtension, containerExtension];
}

/**
 * æ£€æµ‹æ–‡æœ¬æ˜¯å¦åŒ…å«è­¦å‘Šæ¡†
 * @param text è¦æ£€æµ‹çš„æ–‡æœ¬
 * @returns æ˜¯å¦åŒ…å«è­¦å‘Šæ¡†
 */
export function hasAlertBlock(text: string): boolean {
	const alertPattern = /^> \[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]/im;
	return alertPattern.test(text);
}

/**
 * æ£€æµ‹æ–‡æœ¬æ˜¯å¦åŒ…å«å®¹å™¨åŒºå—
 * @param text è¦æ£€æµ‹çš„æ–‡æœ¬
 * @returns æ˜¯å¦åŒ…å«å®¹å™¨åŒºå—
 */
export function hasContainerBlock(text: string): boolean {
	const containerPattern = /^:::\s*\w+/m;
	return containerPattern.test(text);
}

/**
 * æå–æ–‡æœ¬ä¸­çš„æ‰€æœ‰è­¦å‘Šæ¡†
 * @param text æºæ–‡æœ¬
 * @returns è­¦å‘Šæ¡†æ•°ç»„
 */
export function extractAlertBlocks(text: string): Array<{ type: string; content: string; raw: string }> {
	const alerts: Array<{ type: string; content: string; raw: string }> = [];
	
	// åŒ¹é…æ‰€æœ‰è­¦å‘Šæ¡†
	const alertMatches = text.match(/^> \[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]\n((?:> .*(?:\n|$))*)/gim);
	if (alertMatches) {
		alertMatches.forEach(match => {
			const alertMatch = /^> \[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]\n((?:> .*(?:\n|$))*)/i.exec(match);
			if (alertMatch && alertMatch.length > 2) {
				const alertType = alertMatch[1].toLowerCase();
				const content = alertMatch[2].replace(/^> /gm, '').trim();
				alerts.push({
					type: alertType,
					content,
					raw: match
				});
			}
		});
	}
	
	return alerts;
}

/**
 * æå–æ–‡æœ¬ä¸­çš„æ‰€æœ‰å®¹å™¨åŒºå—
 * @param text æºæ–‡æœ¬
 * @returns å®¹å™¨åŒºå—æ•°ç»„
 */
export function extractContainerBlocks(text: string): Array<{ type: string; title: string; content: string; raw: string }> {
	const containers: Array<{ type: string; title: string; content: string; raw: string }> = [];
	
	// åŒ¹é…æ‰€æœ‰å®¹å™¨åŒºå—
	const containerMatches = text.match(/^:::\s*(\w+)(?:\s+(.*))?\n([\s\S]*?)\n:::/gm);
	if (containerMatches) {
		containerMatches.forEach(match => {
			const containerMatch = /^:::\s*(\w+)(?:\s+(.*))?\n([\s\S]*?)\n:::/m.exec(match);
			if (containerMatch && containerMatch.length > 1) {
				const containerType = containerMatch[1];
				const title = containerMatch[2] || '';
				const content = containerMatch[3] || '';
				containers.push({
					type: containerType,
					title: title.trim(),
					content: content.trim(),
					raw: match
				});
			}
		});
	}
	
	return containers;
}

/**
 * è·å–æ”¯æŒçš„è­¦å‘Šæ¡†ç±»å‹åˆ—è¡¨
 * @returns è­¦å‘Šæ¡†ç±»å‹æ•°ç»„
 */
export function getSupportedAlertTypes(): Array<{ type: string; name: string; description: string; icon: string }> {
	return [
		{ type: 'note', name: 'æ³¨æ„', description: 'ä¸€èˆ¬æ€§çš„ä¿¡æ¯æç¤º', icon: 'â„¹ï¸' },
		{ type: 'tip', name: 'æç¤º', description: 'æœ‰ç”¨çš„å»ºè®®æˆ–æŠ€å·§', icon: 'ğŸ’¡' },
		{ type: 'important', name: 'é‡è¦', description: 'é‡è¦çš„ä¿¡æ¯', icon: 'â—' },
		{ type: 'warning', name: 'è­¦å‘Š', description: 'éœ€è¦æ³¨æ„çš„äº‹é¡¹', icon: 'âš ï¸' },
		{ type: 'caution', name: 'å°å¿ƒ', description: 'å¯èƒ½æœ‰å±é™©çš„æ“ä½œ', icon: 'ğŸš¨' }
	];
}

/**
 * è·å–æ”¯æŒçš„å®¹å™¨ç±»å‹åˆ—è¡¨
 * @returns å®¹å™¨ç±»å‹æ•°ç»„
 */
export function getSupportedContainerTypes(): Array<{ type: string; name: string; description: string }> {
	return [
		{ type: 'tip', name: 'æç¤º', description: 'æç¤ºä¿¡æ¯å®¹å™¨' },
		{ type: 'warning', name: 'è­¦å‘Š', description: 'è­¦å‘Šä¿¡æ¯å®¹å™¨' },
		{ type: 'danger', name: 'å±é™©', description: 'å±é™©ä¿¡æ¯å®¹å™¨' },
		{ type: 'info', name: 'ä¿¡æ¯', description: 'ä¸€èˆ¬ä¿¡æ¯å®¹å™¨' },
		{ type: 'details', name: 'è¯¦æƒ…', description: 'å¯æŠ˜å çš„è¯¦ç»†ä¿¡æ¯' },
		{ type: 'quote', name: 'å¼•ç”¨', description: 'å¼•ç”¨å†…å®¹å®¹å™¨' },
		{ type: 'code', name: 'ä»£ç ', description: 'ä»£ç ç¤ºä¾‹å®¹å™¨' },
		{ type: 'example', name: 'ç¤ºä¾‹', description: 'ç¤ºä¾‹å†…å®¹å®¹å™¨' }
	];
}

/**
 * éªŒè¯è­¦å‘Šæ¡†ç±»å‹
 * @param type è­¦å‘Šæ¡†ç±»å‹
 * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆç±»å‹
 */
export function isValidAlertType(type: string): boolean {
	const validTypes = ['note', 'tip', 'important', 'warning', 'caution'];
	return validTypes.includes(type.toLowerCase());
}

/**
 * éªŒè¯å®¹å™¨ç±»å‹
 * @param type å®¹å™¨ç±»å‹
 * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆç±»å‹
 */
export function isValidContainerType(type: string): boolean {
	const validTypes = ['tip', 'warning', 'danger', 'info', 'details', 'quote', 'code', 'example'];
	return validTypes.includes(type.toLowerCase());
}