import { _getDefaults } from './defaults';
import { Lexer } from './Lexer';
import { Parser } from './Parser';
import { _Hooks } from './Hooks';
import { Renderer } from './Renderer';
import { Tokenizer } from './Tokenizer';
import { TextRenderer } from './TextRenderer';
import { escape } from './helpers';
import { MarkedExtension, MarkedOptions, Token, Tokens, TokensList, MaybePromise, UnknownFunction, GenericRendererFunction, I_Marked, OverloadedParse, I_Lexer, NodesToken } from '../utssdk/interface';

export class Marked implements I_Marked {
	defaults: MarkedOptions = _getDefaults();
	parse = this.parseMarkdown(true);
	parseInline = this.parseMarkdown(false);
	constructor(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {
		this.use(...args);
	}
	
	/**
	   * Run callback for every token
	   */
	// walkTokens(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {
	// 	let values: MaybePromise[] = [] as MaybePromise[];
	// 	for (const token of tokens) {
	// 		values = values.concat(callback(token));
	// 		switch (token.type) {
	// 			case 'table': {
	// 				const tableToken = token as Tokens['Table'];
	// 				for (const cell of tableToken.header) {
	// 					values = values.concat(this.walkTokens(cell.tokens, callback));
	// 				}
	// 				for (const row of tableToken.rows) {
	// 					for (const cell of row) {
	// 						values = values.concat(this.walkTokens(cell.tokens, callback));
	// 					}
	// 				}
	// 				break;
	// 			}
	// 			case 'list': {
	// 				const listToken = token as Tokens['List'];
	// 				values = values.concat(this.walkTokens(listToken.items, callback));
	// 				break;
	// 			}
	// 			default: {
	// 				const genericToken = token as Tokens['Generic'];
	// 				if (this.defaults.extensions?.childTokens[genericToken['type']] != null) {
	// 					this.defaults.extensions.childTokens[genericToken['type']].forEach((childTokens) => {
	// 						const tokens = genericToken[childTokens]
	// 					})
	// 				}
	// 			}
	// 		}
	// 	}
	// }
	
	setOptions(opt: MarkedOptions): I_Marked {
		if (opt.async != null) {
			this.defaults.async = opt.async;
		}
		if (opt.breaks != null) {
			this.defaults.breaks = opt.breaks;
		}
		if (opt.extensions != null) {
			this.defaults.extensions = opt.extensions;
		}
		if (opt.gfm != null) {
			this.defaults.gfm = opt.gfm;
		}
		if (opt.hooks != null) {
			this.defaults.hooks = opt.hooks;
		}
		if (opt.pedantic != null) {
			this.defaults.pedantic = opt.pedantic;
		}
		if (opt.renderer != null) {
			this.defaults.renderer = opt.renderer;
		}
		if (opt.silent != null) {
			this.defaults.silent = opt.silent;
		}
		if (opt.tokenizer != null) {
			this.defaults.tokenizer = opt.tokenizer;
		}
		if (opt.walkTokens != null) {
			this.defaults.walkTokens = opt.walkTokens;
		}
		return this;
	}
	use(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {
    const extensions: MarkedOptions<ParserOutput, RendererOutput>['extensions'] = this.defaults.extensions || { renderers: {}, childTokens: {} };

    args.forEach((pack) => {
      // copy options to new object
      const opts = { ...pack } as MarkedOptions<ParserOutput, RendererOutput>;

      // set async to true if it was set to true before
      opts.async = this.defaults.async || opts.async || false;

      // ==-- Parse "addon" extensions --== //
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error('extension name required');
          }
          if ('renderer' in ext) { // Renderer extensions
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              // Replace extension with func to run new extension but fall back if false
              extensions.renderers[ext.name] = function(...args) {
                let ret = ext.renderer.apply(this, args);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ('tokenizer' in ext) { // Tokenizer Extensions
            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) { // Function to check for start of token
              if (ext.level === 'block') {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === 'inline') {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }

      // ==-- Parse "overwrite" extensions --== //
    //   if (pack.renderer) {
    //     const renderer = this.defaults.renderer || new _Renderer<ParserOutput, RendererOutput>(this.defaults);
    //     for (const prop in pack.renderer) {
    //       if (!(prop in renderer)) {
    //         throw new Error(`renderer '${prop}' does not exist`);
    //       }
    //       if (['options', 'parser'].includes(prop)) {
    //         // ignore options property
    //         continue;
    //       }
    //       const rendererProp = prop as Exclude<keyof _Renderer<ParserOutput, RendererOutput>, 'options' | 'parser'>;
    //       const rendererFunc = pack.renderer[rendererProp] as GenericRendererFunction;
    //       const prevRenderer = renderer[rendererProp] as GenericRendererFunction;
    //       // Replace renderer with func to run extension, but fall back if false
    //       renderer[rendererProp] = (...args: unknown[]) => {
    //         let ret = rendererFunc.apply(renderer, args);
    //         if (ret === false) {
    //           ret = prevRenderer.apply(renderer, args);
    //         }
    //         return (ret || '') as RendererOutput;
    //       };
    //     }
    //     opts.renderer = renderer;
    //   }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new Tokenizer<ParserOutput, RendererOutput>(this.defaults);
        for (const prop in pack.tokenizer) {
        //   if (!(prop in tokenizer)) {
        //     throw new Error(`tokenizer '${prop}' does not exist`);
        //   }
          if (['options', 'rules', 'lexer'].includes(prop)) {
            // ignore options, rules, and lexer properties
            continue;
          }
          const tokenizerProp = prop as Exclude<keyof _Tokenizer<ParserOutput, RendererOutput>, 'options' | 'rules' | 'lexer'>;
          const tokenizerFunc = pack.tokenizer[tokenizerProp] as UnknownFunction;
          const prevTokenizer = tokenizer[tokenizerProp] as UnknownFunction;
          // Replace tokenizer with func to run extension, but fall back if false
          // @ts-expect-error cannot type tokenizer function dynamically
          tokenizer[tokenizerProp] = (...args: unknown[]) => {
            let ret = tokenizerFunc.apply(tokenizer, args);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }

      // ==-- Parse Hooks extensions --== //
    //   if (pack.hooks) {
    //     const hooks = this.defaults.hooks || new _Hooks<ParserOutput, RendererOutput>();
    //     for (const prop in pack.hooks) {
    //       if (!(prop in hooks)) {
    //         throw new Error(`hook '${prop}' does not exist`);
    //       }
    //       if (['options', 'block'].includes(prop)) {
    //         // ignore options and block properties
    //         continue;
    //       }
    //       const hooksProp = prop as Exclude<keyof _Hooks<ParserOutput, RendererOutput>, 'options' | 'block'>;
    //       const hooksFunc = pack.hooks[hooksProp] as UnknownFunction;
    //       const prevHook = hooks[hooksProp] as UnknownFunction;
    //       if (_Hooks.passThroughHooks.has(prop)) {
    //         // @ts-expect-error cannot type hook function dynamically
    //         hooks[hooksProp] = (arg: unknown) => {
    //           if (this.defaults.async) {
    //             return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {
    //               return prevHook.call(hooks, ret);
    //             });
    //           }

    //           const ret = hooksFunc.call(hooks, arg);
    //           return prevHook.call(hooks, ret);
    //         };
    //       } else {
    //         // @ts-expect-error cannot type hook function dynamically
    //         hooks[hooksProp] = (...args: unknown[]) => {
    //           let ret = hooksFunc.apply(hooks, args);
    //           if (ret === false) {
    //             ret = prevHook.apply(hooks, args);
    //           }
    //           return ret;
    //         };
    //       }
    //     }
    //     opts.hooks = hooks;
    //   }

      // ==-- Parse WalkTokens extensions --== //
    //   if (pack.walkTokens) {
    //     const walkTokens = this.defaults.walkTokens;
    //     const packWalktokens = pack.walkTokens;
    //     opts.walkTokens = function(token) {
    //       let values: MaybePromise[] = [];
    //       values.push(packWalktokens.call(this, token));
    //       if (walkTokens) {
    //         values = values.concat(walkTokens.call(this, token));
    //       }
    //       return values;
    //     };
    //   }

      this.defaults = { ...this.defaults, ...opts };
    });

    return this;
  }
	
	private combineOptions(options: MarkedOptions | null = null): MarkedOptions {
		if (options == null) {
			return {} as MarkedOptions;
		}
		return {
			async: options.async,
			breaks: options.breaks,
			extensions: options.extensions,
			gfm: options.gfm,
			hooks: options.hooks,
			pedantic: options.pedantic,
			renderer: options.renderer,
			silent: options.silent,
			tokenizer: options.tokenizer,
			walkTokens: options.walkTokens,
		} as MarkedOptions;
	}
	
	lexer(src: string, options?: MarkedOptions): TokensList {
		return Lexer.lex(src, options ?? this.defaults);
	}
	
	parser(tokens: NodesToken[], options?: MarkedOptions): string {
		return Parser.parse(tokens, options ?? this.defaults);
	}
	
	private parseMarkdown(blockType: boolean): (src: string, options?: MarkedOptions | null) => string | Promise<string | Promise<string>> {
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const parse = async (src: string, options?: MarkedOptions | null): Promise<string | Promise<string>> => {
			const origOpt = this.combineOptions(options);
			this.setOptions(options ?? {} as MarkedOptions);
			const opt = this.defaults;
			
			const throwError = this.onError(opt.silent == null ? false : opt.silent!, opt.async == null ? false : opt.silent!);
			
			// throw error if an extension set async to true but parse was called with async: false
			if (this.defaults.async == true && origOpt.async == false) {
				return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));
			}
			
			// throw error in case of non string input
			if (opt.hooks != null) {
				opt.hooks!.options = opt;
				opt.hooks!.block = blockType;
			}
			
			// const lexer = opt.hooks != null ? opt.hooks!.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);
			let lexer: any | null;
			if (opt.hooks != null) {
				lexer = opt.hooks!.provideLexer();
			} else {
				if (blockType) {
					lexer = (src: string, options?: MarkedOptions): TokensList => {
						return Lexer.lex(src, options);
					}
				} else {
					lexer = (src: string, options?: MarkedOptions): NodesToken[] => {
						return Lexer.lexInline(src, options);
					}
				}
			}
			// const parser = opt.hooks != null ? opt.hooks!.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);
			let parser: any | null;
			if (opt.hooks!= null) {
				parser = opt.hooks!.provideParser();
			} else {
				parser = (tokens: NodesToken[], options?: MarkedOptions): string => {
					if (blockType) {
						return Parser.parse(tokens, options);
					}
					return Parser.parseInline(tokens, options);
				}
			}
			
			if (opt.async == true) {
				return Promise.resolve(opt.hooks != null ? opt.hooks!.preprocess(src) : src)
					// #ifndef APP-HARMONY
					// #ifdef APP-ANDROID
					.then((src): TokensList => lexer(src, opt))
					// #endif
					// #ifndef APP-ANDROID
					.then((src): TokensList => lexer!(src, opt))
					// #endif
					// #endif
					// #ifdef APP-HARMONY
					.then((src): TokensList => (lexer as Function)(src, opt))
					// #endif
					.then((tokens): any => opt.hooks != null ? opt.hooks!.processAllTokens(tokens) : tokens)
					// .then((tokens) => opt.walkTokens != null ? Promise.all())
					.then((tokens): string => (parser as (tokens: NodesToken[], options: MarkedOptions | null) => string)(tokens as NodesToken[], opt))
					.then((html): string => opt.hooks != null ? opt.hooks!.postprocess(html) : html)
					.catch((e): string | Promise<string> => {
						if (e instanceof Error) {
							return throwError(e as Error);
						}
						return throwError(new Error('Please report this to https://gitcode.com/uvuejs/kux-marked.'))
					});
			}
			
			try {
				if (opt.hooks != null) {
					src = opt.hooks!.preprocess(src);
				}
				let tokens: any | null;
				let html = '';
				await new Promise<any>((resolve, reject) => {
					// #ifdef APP-ANDROID
					UTSAndroid.getDispatcher('io').async((_) => {
					// #endif
						try {
							// #ifndef APP-HARMONY
							// #ifdef APP-ANDROID
							tokens = lexer(src, opt);
							// #endif
							// #ifndef APP-ANDROID
							tokens = lexer!(src, opt);
							// #endif
							// #endif
							// #ifdef APP-HARMONY
							tokens = (lexer as Function)(src, opt);
							// #endif
							if (opt.hooks != null) {
								tokens = opt.hooks!.processAllTokens(tokens as TokensList) as TokensList;
							}
							html = (parser as (tokens: NodesToken[], options: MarkedOptions | null) => string)(Array.isArray(tokens) ? (tokens as NodesToken[]) : (tokens as TokensList).tokens, opt);
							// #ifndef APP-HARMONY
							resolve(tokens!);
							// #endif
							// #ifdef APP-HARMONY
							resolve(tokens!);
							// #endif
						} catch (e) {
							reject(e);
						}
					// #ifdef APP-ANDROID
					}, null);
					// #endif
				});
				if (opt.hooks!= null) {
					html = opt.hooks!.postprocess(html);
				}
				return html;
			} catch (e) {
				if (e instanceof Error) {
					return throwError(e);
				}
				return throwError(new Error('Please report this to https://gitcode.com/uvuejs/kux-marked.'))
			}
		};
		
		return parse;
	}
	
	private onError(silent: boolean, async: boolean) {
		return (e: Error): string | Promise<string> => {
			e.message += '\nPlease report this to https://gitcode.com/uvuejs/kux-marked.';
			if (silent) {
				const msg = '<p>An error occurred:</p><pre>'
				  + escape(e.message + '', true)
				  + '</pre>';
				if (async) {
					return Promise.resolve(msg);
				}
				return msg;
			}
			if (async) {
				return Promise.reject(e);
			}
			throw e;
		};
	}
}

export { Renderer } from './Renderer';
export { TextRenderer } from './TextRenderer';

// export { _TextRenderer as TextRenderer } from './TextRenderer';
// export { _Tokenizer as Tokenizer } from './Tokenizer';

// export const Renderer = _Renderer;
// export const TextRenderer = _TextRenderer;
// export const Tokenizer = _Tokenizer;
// export const Lexer = _Lexer;