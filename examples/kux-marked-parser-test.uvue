<template>
	<view class="test-container">
		<!-- æ ‡é¢˜åŒºåŸŸ -->
		<view class="header">
			<text class="title">ğŸ” kux-marked è§£æåŠŸèƒ½æµ‹è¯•</text>
			<text class="subtitle">å®æ—¶æµ‹è¯•å„ç§æ‰©å±•åŠŸèƒ½çš„è§£æç»“æœ</text>
		</view>

		<!-- è¾“å…¥åŒºåŸŸ -->
		<view class="input-section">
			<text class="section-title">ğŸ“ è¾“å…¥ Markdown å†…å®¹</text>
			<textarea 
				class="markdown-input" 
				v-model="markdownInput" 
				placeholder="è¾“å…¥åŒ…å«æ‰©å±•åŠŸèƒ½çš„ Markdown å†…å®¹..."
				:maxlength="2000"
			></textarea>
			
					<view class="input-controls">
			<button class="test-btn primary" @click="parseMarkdown">è§£æå†…å®¹</button>
			<button class="test-btn" @click="loadMathSample">æ•°å­¦å…¬å¼ç¤ºä¾‹</button>
			<button class="test-btn" @click="clearInput">æ¸…ç©ºå†…å®¹</button>
		</view>
		</view>

		<!-- è§£æç»“æœå±•ç¤º -->
		<view class="result-section" v-if="parseResult">
			<text class="section-title">ğŸ“Š è§£æç»“æœ</text>
			
			<!-- åŸå§‹ Token ä¿¡æ¯ -->
			<view class="result-item">
				<text class="result-label">åŸå§‹ Token æ•°æ®ï¼š</text>
				<view class="token-info">
					<text class="token-count">Token æ•°é‡: {{ parseResult.tokens?.length || 0 }}</text>
					<text class="token-types">ç±»å‹: {{ getTokenTypes() }}</text>
				</view>
			</view>
			
			<!-- Token è¯¦ç»†åˆ—è¡¨ -->
			<view class="result-item">
				<text class="result-label">Token è¯¦ç»†åˆ—è¡¨ï¼š</text>
				<view class="token-list">
					<view 
						class="token-item" 
						v-for="(token, index) in parseResult.tokens" 
						:key="index"
						@click="showTokenDetail(token, index)"
					>
						<text class="token-index">#{{ index }}</text>
						<text class="token-type">{{ token.type }}</text>
						<text class="token-preview">{{ getTokenPreview(token) }}</text>
					</view>
				</view>
			</view>
			
			<!-- æ‰©å±•åŠŸèƒ½æ£€æµ‹ -->
			<view class="result-item">
				<text class="result-label">æ‰©å±•åŠŸèƒ½æ£€æµ‹ï¼š</text>
				<view class="extension-detection">
					<view class="detection-item" v-for="(detected, name) in detectedExtensions" :key="name">
						<text class="detection-name">{{ name }}</text>
						<text class="detection-status" :class="detected ? 'detected' : 'not-detected'">
							{{ detected ? 'âœ… å·²æ£€æµ‹åˆ°' : 'âŒ æœªæ£€æµ‹åˆ°' }}
						</text>
					</view>
				</view>
			</view>
		</view>

		<!-- ç¤ºä¾‹å†…å®¹é€‰æ‹© -->
		<view class="sample-section">
			<text class="section-title">ğŸ“š ç¤ºä¾‹å†…å®¹</text>
			<text class="section-desc">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åŠ è½½ä¸åŒçš„ç¤ºä¾‹å†…å®¹è¿›è¡Œæµ‹è¯•</text>
			
			<view class="sample-buttons">
				<button class="sample-btn" @click="loadMathSample">æ•°å­¦å…¬å¼ç¤ºä¾‹</button>
				<button class="sample-btn" @click="loadMermaidSample">Mermaidå›¾è¡¨ç¤ºä¾‹</button>
				<button class="sample-btn" @click="loadAlertSample">è­¦å‘Šæ¡†ç¤ºä¾‹</button>
				<button class="sample-btn" @click="loadContainerSample">å®¹å™¨ç¤ºä¾‹</button>
				<button class="sample-btn" @click="loadMixedSample">æ··åˆå†…å®¹ç¤ºä¾‹</button>
			</view>
		</view>

		<!-- Token è¯¦æƒ…å¼¹çª— -->
		<uni-popup ref="tokenPopup" type="center">
			<view class="token-detail-popup">
				<view class="popup-header">
					<text class="popup-title">Token è¯¦æƒ…</text>
					<button class="close-btn" @click="closeTokenDetail">Ã—</button>
				</view>
				<view class="popup-content">
					<view class="detail-item">
						<text class="detail-label">ç±»å‹:</text>
						<text class="detail-value">{{ selectedToken?.type }}</text>
					</view>
					<view class="detail-item">
						<text class="detail-label">åŸå§‹å†…å®¹:</text>
						<text class="detail-value raw">{{ selectedToken?.raw }}</text>
					</view>
					<view class="detail-item" v-if="selectedToken?.text">
						<text class="detail-label">æ–‡æœ¬å†…å®¹:</text>
						<text class="detail-value">{{ selectedToken?.text }}</text>
					</view>
					<view class="detail-item" v-if="selectedToken?.tokens?.length">
						<text class="detail-label">å­ Token æ•°é‡:</text>
						<text class="detail-value">{{ selectedToken?.tokens?.length }}</text>
					</view>
					<view class="detail-item" v-if="selectedToken?.mathType">
						<text class="detail-label">æ•°å­¦ç±»å‹:</text>
						<text class="detail-value">{{ selectedToken?.mathType }}</text>
					</view>
					<view class="detail-item" v-if="selectedToken?.display !== undefined">
						<text class="detail-label">æ˜¾ç¤ºæ¨¡å¼:</text>
						<text class="detail-value">{{ selectedToken?.display ? 'å—çº§' : 'è¡Œå†…' }}</text>
					</view>
					<view class="detail-item" v-if="selectedToken?.alertType">
						<text class="detail-label">è­¦å‘Šç±»å‹:</text>
						<text class="detail-value">{{ selectedToken?.alertType }}</text>
					</view>
					<view class="detail-item" v-if="selectedToken?.containerType">
						<text class="detail-label">å®¹å™¨ç±»å‹:</text>
						<text class="detail-value">{{ selectedToken?.containerType }}</text>
					</view>
					<view class="detail-item" v-if="selectedToken?.diagramType">
						<text class="detail-label">å›¾è¡¨ç±»å‹:</text>
						<text class="detail-value">{{ selectedToken?.diagramType }}</text>
					</view>
				</view>
			</view>
		</uni-popup>
	</view>
</template>

<script setup lang="ts">
	// å¯¼å…¥ kux-marked ç›¸å…³åŠŸèƒ½
	import { Lexer } from '@/uni_modules/kux-marked/common/Lexer';
	import { MarkedOptions } from '@/uni_modules/kux-marked/utssdk/MarkedOptions.interface';
	import { NodesToken } from '@/uni_modules/kux-marked/utssdk/Tokens.interface';
	
	// å“åº”å¼æ•°æ®
	const markdownInput = ref<string>('');
	const parseResult = ref<any>(null);
	const detectedExtensions = ref<Record<string, boolean>>({});
	const selectedToken = ref<NodesToken | null>(null);
	
	// å¼¹çª—å¼•ç”¨
	const tokenPopup = ref<any>(null);
	
	// åˆ›å»º Lexer å®ä¾‹
	const lexer = new Lexer();
	
	// è·å–æ‰©å±•æ³¨å†Œå™¨
	const extensionRegistry = lexer.getExtensionRegistry();
	
	// åœ¨é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
	onMounted(() => {
		console.log('=== kux-marked è§£ææµ‹è¯•é¡µé¢åˆå§‹åŒ– ===');
		console.log('æ‰©å±•æ³¨å†Œå™¨:', extensionRegistry);
		console.log('å·²æ³¨å†Œæ‰©å±•:', extensionRegistry.getRegisteredNames());
		
		// åŠ è½½é»˜è®¤ç¤ºä¾‹
		loadMathSample();
	});
	
	// è§£æ Markdown å†…å®¹
	const parseMarkdown = () => {
		if (!markdownInput.value.trim()) {
			uni.showToast({
				title: 'è¯·è¾“å…¥å†…å®¹',
				icon: 'none'
			});
			return;
		}
		
		try {
			console.log('å¼€å§‹è§£æ Markdown:', markdownInput.value);
			
			// è§£æ Markdown
			const tokens = lexer.lex(markdownInput.value);
			
			// ä¿å­˜è§£æç»“æœ
			parseResult.value = {
				tokens: tokens.tokens || tokens,
				links: tokens.links || {}
			};
			
			// æ£€æµ‹æ‰©å±•åŠŸèƒ½
			detectExtensions();
			
			console.log('è§£æå®Œæˆ:', parseResult.value);
			
			uni.showToast({
				title: 'è§£ææˆåŠŸ',
				icon: 'success'
			});
			
		} catch (error) {
			console.error('è§£æå¤±è´¥:', error);
			uni.showToast({
				title: 'è§£æå¤±è´¥',
				icon: 'error'
			});
		}
	};
	
	// é€’å½’æŸ¥æ‰¾æ‰€æœ‰æŒ‡å®šç±»å‹çš„ token
	const findAllTokensByType = (tokenList: any[], targetType: string): any[] => {
		const foundTokens: any[] = [];
		tokenList.forEach(token => {
			if (token.type === targetType) {
				foundTokens.push(token);
			}
			// é€’å½’æ£€æŸ¥å­ tokens
			if (token.tokens && Array.isArray(token.tokens)) {
				foundTokens.push(...findAllTokensByType(token.tokens, targetType));
			}
		});
		return foundTokens;
	};

	// æ£€æµ‹æ‰©å±•åŠŸèƒ½
	const detectExtensions = () => {
		if (!parseResult.value?.tokens) return;
		
		const tokens = parseResult.value.tokens;
		
		detectedExtensions.value = {
			'æ•°å­¦å…¬å¼': findAllTokensByType(tokens, 'math').length > 0,
			'Mermaidå›¾è¡¨': findAllTokensByType(tokens, 'mermaid').length > 0,
			'è­¦å‘Šæ¡†': findAllTokensByType(tokens, 'alert').length > 0,
			'å®¹å™¨åŒºå—': findAllTokensByType(tokens, 'container').length > 0
		};
	};
	
	// è·å– Token ç±»å‹åˆ—è¡¨
	const getTokenTypes = () => {
		if (!parseResult.value?.tokens) return '';
		
		const types = [...new Set(parseResult.value.tokens.map((token: any) => token.type))];
		return types.join(', ');
	};
	
	// è·å– Token é¢„è§ˆ
	const getTokenPreview = (token: any) => {
		if (token.text) {
			return token.text.length > 30 ? token.text.substring(0, 30) + '...' : token.text;
		}
		if (token.raw) {
			return token.raw.length > 30 ? token.raw.substring(0, 30) + '...' : token.raw;
		}
		return 'æ— å†…å®¹';
	};
	
	// æ˜¾ç¤º Token è¯¦æƒ…
	const showTokenDetail = (token: any, index: number) => {
		selectedToken.value = token;
		tokenPopup.value.open();
	};
	
	// å…³é—­ Token è¯¦æƒ…
	const closeTokenDetail = () => {
		tokenPopup.value.close();
		selectedToken.value = null;
	};
	
	// åŠ è½½ç¤ºä¾‹å†…å®¹
	const loadMathSample = () => {
		markdownInput.value = `# æ•°å­¦å…¬å¼ç¤ºä¾‹

è¿™æ˜¯ä¸€ä¸ªè¡Œå†…å…¬å¼ï¼š$E = mc^2$

è¿™æ˜¯ä¸€ä¸ªå—çº§å…¬å¼ï¼š

$$\int_{-\infty}^{\infty} e^{-x^2} dx = \sqrt{\pi}$$

ä½¿ç”¨ \\( \\) è¯­æ³•çš„è¡Œå†…å…¬å¼ï¼š\\(\\frac{a}{b} + \\frac{c}{d}\\)

ä½¿ç”¨ \\[ \\] è¯­æ³•çš„å—çº§å…¬å¼ï¼š

\\[\\sum_{i=1}^{n} x_i = x_1 + x_2 + \\cdots + x_n\\]`;
	};
	
	const loadMermaidSample = () => {
		markdownInput.value = `# Mermaidå›¾è¡¨ç¤ºä¾‹

## æµç¨‹å›¾
\`\`\`mermaid
graph TD
    A[å¼€å§‹] --> B{åˆ¤æ–­æ¡ä»¶}
    B -->|æ˜¯| C[æ‰§è¡Œæ“ä½œA]
    B -->|å¦| D[æ‰§è¡Œæ“ä½œB]
    C --> E[ç»“æŸ]
    D --> E
\`\`\`

## æ—¶åºå›¾
\`\`\`mermaid
sequenceDiagram
    participant A as ç”¨æˆ·
    participant B as ç³»ç»Ÿ
    A->>B: å‘é€è¯·æ±‚
    B-->>A: å“åº”æ•°æ®
\`\`\`

## é¥¼å›¾
\`\`\`mermaid
pie
    title å¸‚åœºä»½é¢
    "äº§å“A" : 30
    "äº§å“B" : 25
    "äº§å“C" : 45
\`\`\``;
	};
	
	const loadAlertSample = () => {
		markdownInput.value = `# è­¦å‘Šæ¡†ç¤ºä¾‹

> [!NOTE]
> è¿™æ˜¯ä¸€ä¸ªæ³¨æ„äº‹é¡¹ï¼Œç”¨äºæä¾›ä¸€èˆ¬æ€§çš„ä¿¡æ¯æç¤ºã€‚

> [!TIP]
> è¿™æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„æç¤ºï¼Œæä¾›å»ºè®®æˆ–æŠ€å·§ã€‚

> [!IMPORTANT]
> è¿™æ˜¯é‡è¦ä¿¡æ¯ï¼Œéœ€è¦ç‰¹åˆ«æ³¨æ„ã€‚

> [!WARNING]
> è¿™æ˜¯è­¦å‘Šä¿¡æ¯ï¼Œéœ€è¦æ³¨æ„çš„äº‹é¡¹ã€‚

> [!CAUTION]
> è¿™æ˜¯éœ€è¦å°å¿ƒçš„æƒ…å†µï¼Œå¯èƒ½æœ‰å±é™©çš„æ“ä½œã€‚`;
	};
	
	const loadContainerSample = () => {
		markdownInput.value = `# å®¹å™¨åŒºå—ç¤ºä¾‹

::: tip æç¤ºæ ‡é¢˜
è¿™æ˜¯ä¸€ä¸ªæç¤ºå®¹å™¨ï¼Œæ”¯æŒmarkdownæ ¼å¼å†…å®¹ã€‚
:::

::: warning è­¦å‘Šæ ‡é¢˜
è¿™æ˜¯ä¸€ä¸ªè­¦å‘Šå®¹å™¨ï¼Œç”¨äºæ˜¾ç¤ºéœ€è¦æ³¨æ„çš„å†…å®¹ã€‚
:::

::: info ä¿¡æ¯æ ‡é¢˜
è¿™æ˜¯ä¸€ä¸ªä¿¡æ¯å®¹å™¨ï¼Œç”¨äºæ˜¾ç¤ºä¸€èˆ¬ä¿¡æ¯ã€‚
:::

::: code ä»£ç ç¤ºä¾‹
\`\`\`javascript
function hello() {
    console.log('Hello World!');
}
\`\`\`
:::`;
	};
	
	const loadMixedSample = () => {
		markdownInput.value = `# æ··åˆå†…å®¹ç¤ºä¾‹

è¿™æ˜¯ä¸€ä¸ªåŒ…å«å¤šç§æ‰©å±•åŠŸèƒ½çš„å¤æ‚ç¤ºä¾‹ï¼š

> [!TIP]
> åœ¨æ•°å­¦å…¬å¼ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ $E = mc^2$ æ¥è¡¨ç¤ºè´¨èƒ½æ–¹ç¨‹ã€‚

å—çº§æ•°å­¦å…¬å¼ï¼š

$$\int_{a}^{b} f(x) dx = F(b) - F(a)$$

::: info æµç¨‹å›¾è¯´æ˜
ä¸‹é¢çš„æµç¨‹å›¾å±•ç¤ºäº†æ•´ä¸ªå¤„ç†æµç¨‹ï¼š
:::

\`\`\`mermaid
graph LR
    A[è¾“å…¥] --> B[å¤„ç†]
    B --> C[è¾“å‡º]
\`\`\`

## æ›´å¤šæ•°å­¦å…¬å¼

è¡Œå†…å…¬å¼ï¼š\\(\\alpha + \\beta = \\gamma\\)

å—çº§å…¬å¼ï¼š

\\[\\frac{d}{dx}\\int_a^x f(t)dt = f(x)\\]`;
	};
	
	// æ¸…ç©ºè¾“å…¥
	const clearInput = () => {
		markdownInput.value = '';
		parseResult.value = null;
		detectedExtensions.value = {};
	};
</script>

<style lang="scss" scoped>
	.test-container {
		padding: 32rpx;
		background-color: #f5f7fa;
		min-height: 100vh;
	}

	.header {
		text-align: center;
		margin-bottom: 48rpx;
		padding: 48rpx 32rpx;
		background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		border-radius: 24rpx;
		color: white;
	}

	.title {
		display: block;
		font-size: 48rpx;
		font-weight: bold;
		margin-bottom: 16rpx;
	}

	.subtitle {
		display: block;
		font-size: 28rpx;
		opacity: 0.9;
		line-height: 1.5;
	}

	.input-section, .result-section, .sample-section {
		background: white;
		border-radius: 20rpx;
		padding: 32rpx;
		margin-bottom: 32rpx;
		box-shadow: 0 4rpx 20rpx rgba(0, 0, 0, 0.08);
	}

	.section-title {
		display: block;
		font-size: 36rpx;
		font-weight: bold;
		color: #2c3e50;
		margin-bottom: 24rpx;
	}

	.section-desc {
		display: block;
		font-size: 26rpx;
		color: #7f8c8d;
		margin-bottom: 24rpx;
		line-height: 1.5;
	}

	.markdown-input {
		width: 100%;
		height: 300rpx;
		padding: 24rpx;
		border: 2rpx solid #e1e8ed;
		border-radius: 16rpx;
		font-size: 28rpx;
		line-height: 1.6;
		background-color: #f8f9fa;
		resize: none;
		margin-bottom: 24rpx;
	}

	.input-controls {
		display: flex;
		gap: 16rpx;
		flex-wrap: wrap;
	}

	.test-btn {
		padding: 20rpx 32rpx;
		border-radius: 12rpx;
		font-size: 28rpx;
		border: none;
		background-color: #e9ecef;
		color: #495057;
		transition: all 0.3s ease;
		
		&.primary {
			background-color: #007bff;
			color: white;
		}
		
		&:active {
			transform: scale(0.95);
		}
	}

	.result-item {
		margin-bottom: 32rpx;
		padding: 24rpx;
		background-color: #f8f9fa;
		border-radius: 16rpx;
		border-left: 6rpx solid #28a745;
	}

	.result-label {
		display: block;
		font-size: 30rpx;
		font-weight: 600;
		color: #2c3e50;
		margin-bottom: 16rpx;
	}

	.token-info {
		display: flex;
		gap: 32rpx;
		margin-bottom: 16rpx;
	}

	.token-count, .token-types {
		font-size: 26rpx;
		color: #495057;
		background-color: #e9ecef;
		padding: 8rpx 16rpx;
		border-radius: 8rpx;
	}

	.token-list {
		max-height: 400rpx;
		overflow-y: auto;
	}

	.token-item {
		display: flex;
		align-items: center;
		padding: 16rpx;
		background-color: white;
		border-radius: 12rpx;
		margin-bottom: 12rpx;
		border: 2rpx solid #e9ecef;
		transition: all 0.3s ease;
		
		&:active {
			background-color: #f8f9fa;
			transform: scale(0.98);
		}
	}

	.token-index {
		font-size: 24rpx;
		color: #6c757d;
		background-color: #e9ecef;
		padding: 4rpx 12rpx;
		border-radius: 6rpx;
		margin-right: 16rpx;
		min-width: 60rpx;
		text-align: center;
	}

	.token-type {
		font-size: 26rpx;
		font-weight: 600;
		color: #007bff;
		background-color: #e7f3ff;
		padding: 4rpx 12rpx;
		border-radius: 6rpx;
		margin-right: 16rpx;
		min-width: 120rpx;
		text-align: center;
	}

	.token-preview {
		flex: 1;
		font-size: 26rpx;
		color: #495057;
		line-height: 1.4;
	}

	.extension-detection {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 16rpx;
	}

	.detection-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 16rpx;
		background-color: white;
		border-radius: 12rpx;
		border: 2rpx solid #e9ecef;
	}

	.detection-name {
		font-size: 26rpx;
		color: #495057;
		font-weight: 500;
	}

	.detection-status {
		font-size: 24rpx;
		font-weight: 600;
		
		&.detected {
			color: #28a745;
		}
		
		&.not-detected {
			color: #dc3545;
		}
	}

	.sample-buttons {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 16rpx;
	}

	.sample-btn {
		padding: 20rpx 24rpx;
		border-radius: 12rpx;
		font-size: 26rpx;
		border: 2rpx solid #007bff;
		background-color: #f8f9ff;
		color: #007bff;
		transition: all 0.3s ease;
		
		&:active {
			background-color: #007bff;
			color: white;
			transform: scale(0.95);
		}
	}

	// Token è¯¦æƒ…å¼¹çª—æ ·å¼
	.token-detail-popup {
		background: white;
		border-radius: 20rpx;
		width: 600rpx;
		max-height: 80vh;
		overflow: hidden;
	}

	.popup-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 32rpx;
		border-bottom: 2rpx solid #e9ecef;
		background-color: #f8f9fa;
	}

	.popup-title {
		font-size: 32rpx;
		font-weight: bold;
		color: #2c3e50;
	}

	.close-btn {
		width: 60rpx;
		height: 60rpx;
		border-radius: 50%;
		border: none;
		background-color: #e9ecef;
		color: #6c757d;
		font-size: 32rpx;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	.popup-content {
		padding: 32rpx;
		max-height: 60vh;
		overflow-y: auto;
	}

	.detail-item {
		display: flex;
		margin-bottom: 24rpx;
		padding: 16rpx;
		background-color: #f8f9fa;
		border-radius: 12rpx;
	}

	.detail-label {
		font-size: 26rpx;
		font-weight: 600;
		color: #495057;
		min-width: 120rpx;
		margin-right: 16rpx;
	}

	.detail-value {
		flex: 1;
		font-size: 26rpx;
		color: #2c3e50;
		line-height: 1.4;
		
		&.raw {
			font-family: 'Courier New', monospace;
			background-color: #e9ecef;
			padding: 8rpx 12rpx;
			border-radius: 6rpx;
			word-break: break-all;
		}
	}

	// å“åº”å¼è®¾è®¡
	@media (max-width: 750rpx) {
		.extension-detection {
			grid-template-columns: 1fr;
		}
		
		.sample-buttons {
			grid-template-columns: 1fr;
		}
		
		.token-detail-popup {
			width: 90vw;
		}
	}
</style>
