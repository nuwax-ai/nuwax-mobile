import { reactive, watch } from 'vue';
import { defaultLLM, currentUser } from '../config';
import { Llm,ChatItem,Chunk,Chat, Provider, MsgItem, RequestAiCoMessage, Userinfo, BaseMsgItem, Setting, markdownElItem } from '@/uni_modules/uni-ai-x/types.uts';
export { MsgItem, ChatItem, BaseMsgItem, Userinfo, markdownElItem }
import {default as RequestAiWorker, RequestAiOptions, OnMessageOptions} from '@/uni_modules/uni-ai-x/sdk/requestAiWorker.uts';
let requestAiWorker: RequestAiWorker | null = null
type BeforeRequestAiFn = () => void
type MessageHandlerMapFn = () => void
class UniAi {
	canRenderVue: boolean = true
	get canRender(): boolean {
		return this.canRenderVue
	}
	set canRender(value: boolean) {
		if (this.canRenderVue != value) {
			this.canRenderVue = value
			requestAiWorker?.postMessage({
				type: 'setCanRender',
				value: value
			} as UTSJSONObject)
		}
	}
	// 当前用户
	currentUser: Userinfo = currentUser
	setting: Setting = reactive<Setting>({
		// UI 主题
		theme: 'light',
		// 语言
		language: 'zh-CN'
	})
	// 大模型
	llm: Llm = reactive<Llm>({
		// 当前提供商
		provider: defaultLLM.provider,
		// 当前模型
		model: defaultLLM.model,
		// 是否开启联网搜索
		webSearch: false
	})
	chat: Chat = reactive<Chat>({
		datas: reactive<ChatItem[]>([]) as ChatItem[],
		activeId: ''
	})
	// 当前对话
	get currentChat(): ChatItem | null {
		return this.chat.datas.find((item) => item.id == this.chat.activeId) as ChatItem | null
	}
	getLocalMsgId(): string {
		// 生成一个 local_ 开头的随机字符串
		return 'local_' + (this.currentUser._id ?? 'tmp_user') + "_"  + Date.now().toString(16) + "_" + Math.floor(Math.random() * 100000)
	}
	// 把 UTSAndroid.getDispatcher("io").async((_) => 封装成一个函数
	uniGetDispatcher(taskName: string, fn: () => void) {
		// #ifdef APP-ANDROID
		UTSAndroid.getDispatcher(taskName).async((_) => {
			fn()
		})
		// #endif
		// #ifndef APP-ANDROID
		fn()
		// #endif
	}
	addChat() {
		// 检查是否已经存在空会话，如果存在则直接选中，否则创建新会话
		const lastItem = this.chat.datas.length == 0 ? null : this.chat.datas[0] as ChatItem | null;
		if (lastItem?.msgList.length != 0) {
			const newChat: ChatItem = {
				id: this.getLocalMsgId(),
				title: "新对话",
				state: 'none',
				update_time: Date.now(),
				msgList: reactive<MsgItem[]>([]),
				inputContent: ''
			};
			this.chat.datas.unshift(newChat);
		}
		// 选中新创建的会话
		nextTick(() => {
			this.chat.activeId = this.chat.datas[0].id
		})
	}
	get lastAiMsg(): MsgItem | null {
		// 获取Ai的最后一条消息(因为 msg 是倒叙的，所以取第一条)
		if (this.currentChat != null) {
			const length = this.currentChat!.msgList.length
			return length > 0 ? this.currentChat!.msgList[length - 1] : null;
		} else {
			return null;
		}
	}
	constructor() {
		// 从 storage 中获取数据
		uni.getStorage({
			key: 'uni-ai-chatList',
			success: (res) => {
				if (res.data != null){
					// #ifdef WEB
					res.data = res.data as ChatItem[]
					// #endif
					// #ifndef WEB
					const data = JSON.parse<ChatItem[]>(JSON.stringify(res.data)) as ChatItem[] | null
					res.data = data == null ? [] : data as ChatItem[]
					// #endif
				} else {
					this.addChat()
					res.data = [] as ChatItem[]
				}

				// console.error('res.data 获取成功', res.data)
				this.chat.datas.push(...(res.data as ChatItem[]))

				// console.error('uni-ai-chatList 获取成功', this.chat.datas)
				const chatList = this.chat.datas as ChatItem[]
				// 收 chat 的 state 设置为 none
				chatList.forEach((item) => {
					item.state = 'none'
				})
				// 默认选中第一个会话
				if (chatList.length == 0) {
					this.addChat()
				}
				this.chat.activeId = chatList[0].id
				// console.log('uni-ai-chatList 获取成功', this.chat.datas)
			},
			fail: (err: UniError) => {
				// console.error('uni-ai-chatList 获取失败', err.errMsg)
				this.addChat()
				// 默认选中第一个会话
				this.chat.activeId = this.chat.datas[0].id
			}
		})
		
		// 获取 setting
		uni.getStorage({
			key: 'uni-ai-setting',
			success: (res) => {
				if (res.data != null) {
					const setting = JSON.parse<Setting>(JSON.stringify(res.data)) as Setting
					this.setting = reactive<Setting>(setting)
				}
			},
			fail: (err) => {
				// console.error('uni-ai-setting 获取失败', err)
			}
		})

		// 在 IO 线程执行存储操作
		let saveStorageTimer: number | null = null
		watch((): ChatItem[] => this.chat.datas as ChatItem[], (newVal: ChatItem[] | null) => {
			if (newVal != null) {
				// console.error('chatList 发生变化', newVal)
				// 防止短时间内重复触发存储
				if (saveStorageTimer != null) {
					// console.error('防止短时间内重复触发存储')
					clearTimeout(saveStorageTimer as number)
				}
				saveStorageTimer = setTimeout(() => {
					// 存储到 storage 中
					uni.setStorage({
						key: 'uni-ai-chatList',
						data: newVal,
						success: () => {
							// console.log('uni-ai-chatList 存储成功', newVal)
						},
						fail: (err) => {
							console.error('uni-ai-chatList 存储失败', err)
						}
					})
				}, 1000)
			}
		}, { deep: true })

		watch((): Setting => this.setting, (newVal: Setting | null) => {
			if (newVal != null) {
				uni.setStorage({
					key: 'uni-ai-setting',
					data: newVal,
					success: () => {
						// console.log('uni-ai-setting 存储成功', newVal)
					},
					fail: (err) => {
						console.error('uni-ai-setting 存储失败', err)
					}
				})
			}
		}, { deep: true })
	}
	addMsg(msg: BaseMsgItem): MsgItem {
		// 添加一条消息
		const msgList = this.currentChat!.msgList
		const newMsg: MsgItem = {
			chat_id: this.currentChat!.id,
			_id: this.getLocalMsgId(),
			about_msg_id: msg.about_msg_id,
			body: msg.body,
			from_uid: msg.from_uid,
			create_time: Date.now(),
			state: 0,
			markdownElList: [] as markdownElItem[],
			rendered: false
		}
		msgList.push(newMsg)
		if (msg.from_uid != 'uni-ai') {
			// 把用户提的问题 内容的前 20 个字符作为标题，去掉换行符
			const title = msg.body.substring(0, 20).replace(/\n/g, '')
			this.currentChat!.title = title
		}
		// 更新会话的更新时间
		this.currentChat!.update_time = Date.now()
		// 返回响应式的 msg
		return msgList[msgList.length - 1]
	}
	deleteMsg(msgId: string) {
		// 查出消息索引
		const msgList = this.currentChat!.msgList
		const index = msgList.findIndex((item) => item._id == msgId)
		if (index != -1) {
			msgList.splice(index, 1)
		} else {
			console.error('需要删除的消息未找到', msgId, this.currentChat!.msgList)
			throw new Error('需要删除的消息未找到')
		}
	}
	abortRequest() {
		// 终止请求
		requestAiWorker?.postMessage({
			type: 'abortRequest'
		} as UTSJSONObject)
	}
	async sendMsg(inputContent: string = ''): Promise<void> {
		// 发送消息
		if (inputContent == '') {
			inputContent = this.currentChat!.inputContent
		}
		// 去除前后空格
		inputContent = inputContent.trim()
		if (inputContent.length == 0) {
			throw new Error('发给 AI 的消息不能为空');
		}
		console.log('send inputContent', inputContent);
		// 生成用户提问的消息
		let baseUserMsg: BaseMsgItem = {
			body: inputContent,
			from_uid: this.currentUser._id ?? 'tmp_user_'
		}
		const userMsg: MsgItem = this.addMsg(baseUserMsg)
		// console.log('before-send-msg', userMsg)

		// 生成一条空的 ai 回复的内容
		let baseAiMsgItem: BaseMsgItem = {
			body: '', // 初始是空的，后面慢慢追加
			from_uid: "uni-ai",
			about_msg_id: userMsg._id
		}
		const aiMsgItem: MsgItem = this.addMsg(baseAiMsgItem)
		return this.answerQuestion(aiMsgItem)
	}
	// 回答问题
	answerQuestion(aiMsgItem: MsgItem) {
		this.currentChat!.update_time = Date.now()
		this.currentChat!.state = 'processing';	
		const messages = this.getMsgToAi(this.currentChat!)
		const requestAiOptions: RequestAiOptions = {
			type: 'requestAi',
			messages
		}
		requestAiWorker = new RequestAiWorker()
		requestAiWorker?.postMessage(requestAiOptions)
		requestAiWorker?.onMessage((message: any) => {
			if (!(message instanceof OnMessageOptions)){
				console.log('onMessage 类型错误', message)
				return
			}
			message = message as OnMessageOptions
			// console.log('answerQuestion message', message)
			const data = message.data
			const messageHandlerMap = new Map<string, MessageHandlerMapFn>([
				['setMarkdownElList', () => {
					if (this.currentChat!.state == 'stop') {
						console.log('setMarkdownElList 当前对话已停止，忽略消息')
						return
					}
					const action = message.action
					const markdownElList = message.markdownElList
					if (action == 'set' && markdownElList != null) {
						aiMsgItem.markdownElList = markdownElList!
					} else if (action == 'update') {
						if (message.index! < aiMsgItem.markdownElList.length) {
							aiMsgItem.markdownElList[message.index!] = message.markdownElList![0]
						} else {
							console.error('setMarkdownElList 索引越界', message.index!, aiMsgItem.markdownElList.length)
						}
					} else if (action == 'remove') {
						aiMsgItem.markdownElList.splice(message.index!, message.size!)
					} else if (action == 'add') {
						aiMsgItem.markdownElList.push(...markdownElList!)
					}
				}],
				['setThinkContent', () => {
					aiMsgItem.thinkContent = data as string
				}],
				['setMsgBody', () => {
					aiMsgItem.body = data as string
				}],
				['setMsgState', () => {
					this.currentChat!.state = data as string
				}],
				['setErrorMsg', () => {
					aiMsgItem.error_msg = data as string
				}],
				['setCurrentChatState', () => {
					this.currentChat!.state = data as string
				}],
				['setRendered', () => {
					aiMsgItem.rendered = data as boolean
				}],
				['setChatTitle', () => {
					this.currentChat!.title = data as string
				}]
			])
			const handler = messageHandlerMap.get(message.type)
			if (handler != null) {
				handler()
			} else {
				console.error('other answerQuestion message', message)
			}
		})
	}
	// 拿到消息列表，用于发给 AI 
	getMsgToAi(chatItem: ChatItem): RequestAiCoMessage[] {
		const messages: RequestAiCoMessage[] = [];
		chatItem.msgList.forEach((item) => {
			messages.push({
				role: item.from_uid == 'uni-ai' ? 'assistant' : 'user',
				content: item.body as string
			})
		})
		return messages
	}
	beforeRequestAiFns: BeforeRequestAiFn[] = []
	onBeforeRequestAi(fn: BeforeRequestAiFn) {
		this.beforeRequestAiFns.push(fn)
	}
	emitBeforeRequestAi() {
		this.beforeRequestAiFns.forEach((fn) => {
			fn()
		})
	}
	// 让阿里百联总结更新
	async updateChatTitle(currentChat: ChatItem, messages: RequestAiCoMessage[]): Promise<void> {
		messages.push({
			role: 'user',
			content: '请总结一下这段对话的内容，不包含本对话，用于更新会话的标题。注意：可以直接使用的不要有多余的文字，只保留总结的内容。字数控制在 10 个字以内。'
		})
		console.error('requestBailian is undefined')
		// await this.requestBailian({
		// 	messages,
		// 	stream: false,
		// 	onError: (err: UTSJSONObject) => {
		// 		console.error('updateChatTitle error', err)
		// 	},
		// 	onSuccess: (chunkObj: Chunk) => {
		// 		// console.log('updateChatTitle success', chunkObj, typeof chunkObj)
		// 		const newTitle = chunkObj.choices?.[0]?.message?.content
		// 		this.uniGetDispatcher("main", () => {
		// 			currentChat.title = newTitle ?? '更新失败'
		// 			// console.log('updateChatTitle success', 'newTitle', newTitle, chunkObj)
		// 		})
		// 	}
		// })
	}
}

const uniAi = new UniAi()
export { uniAi }
export default uniAi

// #ifdef WEB
// 方便在控制台观察
window.uniAi = uniAi
// #endif